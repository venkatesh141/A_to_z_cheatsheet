
abstract class Animal {
    
    abstract void makeSound();

    
    void sleep() {
        System.out.println("This animal is sleeping.");
    }
}


class Dog extends Animal {
    // The body of makeSound() is provided here
    @Override
    void makeSound() {
        System.out.println("Woof Woof");
    }
}


class Cat extends Animal {
    // The body of makeSound() is provided here
    @Override
    void makeSound() {
        System.out.println("Meow Meow");
    }
}


public class AbstractionExample {
    public static void main(String[] args) {
        // Create objects of Dog and Cat
        Animal myDog = new Dog();
        Animal myCat = new Cat();
        
        // Call the makeSound() method on both objects
        myDog.makeSound(); // Outputs: Woof Woof
        myCat.makeSound(); // Outputs: Meow Meow
        
        // Call the sleep() method on both objects
        myDog.sleep(); // Outputs: This animal is sleeping.
        myCat.sleep(); // Outputs: This animal is sleeping.
    }
}
Abstract classes set up a common structure (like requiring makeSound() for all animals).
They allow each subclass (like Dog or Cat) to have its own behavior while still following the same basic rules.
-----------trust the process you will win .
Interface

  package railway;

public interface Vehicle {

	void speedInfo();
	void vehicleInfo();
}

package railway;

public class Car implements Vehicle {

	@Override
	public void speedInfo() {
		// TODO Auto-generated method stub
		System.out.println("500 km");
		
	}

	@Override
	public void vehicleInfo() {
		// TODO Auto-generated method stub
		System.out.println("it is car");
	}

}
package railway;

public class Bike implements Vehicle {

	@Override
	public void speedInfo() {
		// TODO Auto-generated method stub
		System.out.println("180 km ");		
	}

	@Override
	public void vehicleInfo() {
		// TODO Auto-generated method stub
		System.out.println("it is bike");
	}

}
package railway;

public class Main {

	public static void main(String[] args)
	{
		Vehicle car = new Car();
		Vehicle bike = new Bike();
		
		car.vehicleInfo();
		car.speedInfo();
		bike.vehicleInfo();
		bike.speedInfo();
	}
}
-----------trust the process you will win .
Thread 

Real Time Use of Stack
 Web Browser
When you open a webpage, a browser uses one thread to load the page text and another thread to load images and videos. 
This way, the page doesn’t freeze while everything loads—each part loads at the same time.

In a chat app like WhatsApp:
One thread is used to display incoming messages in real-time.
Another thread is used to send messages and deliver notifications

Two methods to implement thread
one is using thread
public class Main extends Thread {
  public static void main(String[] args) {
    Main thread = new Main();
    thread.start();
    System.out.println("This code is outside of the thread");
  }
  public void run() {
    System.out.println("This code is running in a thread");
  }
}

another way is using Runnable
public class Main implements Runnable {
  public static void main(String[] args) {
    Main obj = new Main();
    Thread thread = new Thread(obj);
    thread.start();
    System.out.println("This code is outside of the thread");
  }
  public void run() {
    System.out.println("This code is running in a thread");
  }
}
-----------trust the process you will win .
Inheritance In Java

Java, Inheritance is an important pillar of OOP(Object-Oriented Programming). 
It is the mechanism in Java by which one class is allowed to inherit the features(fields and methods) of another class. 

Single Inheritance

import java.io.*;
import java.lang.*;
import java.util.*;

// Parent class
class One {
    public void print_geek()
    {
        System.out.println("Geeks");
    }
}

class Two extends One {
    public void print_for() { System.out.println("for"); }
}

// Driver class
public class Main {
      // Main function
    public static void main(String[] args)
    {
        Two g = new Two();
        g.print_geek();
        g.print_for();
        g.print_geek();
    }
}

Multilevel Inheritance

class One {
    // Method to print "Geeks"
    public void print_geek() {
        System.out.println("Geeks");
    }
}

// Child class Two inherits from class One
class Two extends One {
    // Method to print "for"
    public void print_for() {
        System.out.println("for");
    }
}

// Child class Three inherits from class Two
class Three extends Two {
    // Method to print "Geeks"
    public void print_lastgeek() {
        System.out.println("Geeks");
    }
}

// Driver class
public class Main {
    public static void main(String[] args) {
        // Creating an object of class Three
        Three g = new Three();
        
        // Calling method from class One
        g.print_geek();
        
        // Calling method from class Two
        g.print_for();
        
        // Calling method from class Three
        g.print_lastgeek();
    }
}



Hierarchical Inheritance

class A {
    public void print_A() 
    { 
    System.out.println("Class A"); 
    }
}

class B extends A {
    public void print_B() 
    {
     System.out.println("Class B"); 
    }
}

class C extends A {
    public void print_C() { 
    System.out.println("Class C");
     }
}

class D extends A {
    public void print_D() {
     System.out.println("Class D");
      }
}

// Driver Class
public class Test {
    public static void main(String[] args)
    {
        B obj_B = new B();
        obj_B.print_A();
        obj_B.print_B();

        C obj_C = new C();
        obj_C.print_A();
        obj_C.print_C();

        D obj_D = new D();
        obj_D.print_A();
        obj_D.print_D();
    }
}

Multiple Inheritance (Through Interfaces)

interface One {
    public void print_geek();
}

interface Two {
    public void print_for();
}

interface Three extends One, Two {
    public void print_geek();
}
class Child implements Three {
    @Override public void print_geek()
    {
        System.out.println("Geeks");
    }

    public void print_for() { System.out.println("for"); }
}

// Drived class
public class Main {
    public static void main(String[] args)
    {
        Child c = new Child();
        c.print_geek();
        c.print_for();
        c.print_geek();
    }
}


Hybrid Inheritance


// Base class
class Animal {
    void eat() {
        System.out.println("Animal is eating");
    }
}

// First interface
interface Pet {
    void beFriendly();
}

// Second interface
interface Wild {
    void hunt();
}

// Derived class using hybrid inheritance
class Dog extends Animal implements Pet, Wild {
    public void beFriendly() {
        System.out.println("Dog is being friendly");
    }    
    public void hunt() {
        System.out.println("Dog is hunting");
    }
    
    void bark() {
        System.out.println("Dog is barking");
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        
        // Calling methods from different parts of the inheritance structure
        dog.eat();          // Inherited from Animal class
        dog.bark();         // Defined in Dog class
        dog.beFriendly();   // Implemented from Pet interface
        dog.hunt();         // Implemented from Wild interface
    }
}

Usage of Inheritance 

class Account {
    double balance;

    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited: " + amount);
    }

    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrew: " + amount);
        } else {
            System.out.println("Insufficient balance");
        }
    }
}

class SavingsAccount extends Account {
    double interestRate = 0.03;

    public void applyInterest() {
        balance += balance * interestRate;
        System.out.println("Interest applied at rate: " + interestRate);
    }
}

class CheckingAccount extends Account {
    double overdraftLimit = 500.0;

    @Override
    public void withdraw(double amount) {
        if (balance + overdraftLimit >= amount) {
            balance -= amount;
            System.out.println("Withdrew: " + amount + " with overdraft");
        } else {
            System.out.println("Overdraft limit reached");
        }
    }
}
Code Reusability: Both SavingsAccount and CheckingAccount inherit common functionality (deposit and withdraw) from Account, 
so the code doesn’t need to be duplicated.

Method Overriding and Polymorphism: CheckingAccount overrides withdraw to allow overdrafts, while SavingsAccount 
uses the default withdrawal behavior from Account.

Code Organization and Extensibility: The account hierarchy (general Account with specific SavingsAccount and CheckingAccount) 
makes it easy to add new account types in the future.

Maintaining Centralized Code: Any update to deposit or the basic withdraw logic
 in Account will propagate to all account types automatically, making maintenance easy.

-----------trust the process you will win .
1. JVM (Java Virtual Machine)
What it is: The JVM is a virtual "engine" that runs Java applications.
What it does: It converts Java bytecode (compiled Java code) into machine code that your computer’s hardware understands, 
so it can actually run the program.
Why it’s important: The JVM allows Java programs to be "write once, run anywhere" 
because it handles converting Java code to run on any operating system, like Windows, Mac, or Linux.


2. JRE (Java Runtime Environment)
What it is: The JRE is a package that includes the JVM along with some additional libraries and tools needed to run Java applications.
What it does: It provides the environment required to run Java programs, 
but it doesn’t include any tools to develop Java applications.
Why it’s important: The JRE is needed if you only want to run Java applications (not develop or compile them). For instance,
 if you're downloading a Java app or game, you’d need the JRE installed on your computer.
   
   
 
3. JDK (Java Development Kit)
What it is: The JDK is a complete package that includes the JRE, JVM, and
 additional tools for developing Java applications, like the compiler (javac), debuggers, and other tools.
What it does: The JDK provides everything needed to write, compile, and run Java programs. 
It’s required if you want to create Java applications.
Why it’s important: If you’re a Java developer, you need the JDK because it allows you to write and compile Java code.



In Summary:
JVM: Runs the compiled Java code.
JRE: Runs Java applications by including the JVM and essential libraries.
JDK: Develops and runs Java applications by including the JRE, JVM, and development tools.
If you want to just run Java apps, you need the JRE. If you want to develop Java apps, you need the JDK. And 
the JVM is the engine that makes Java code runnable on any system.


Compiler (javac): Converts .java (source code) to .class (bytecode).
JVM: Executes .class files by converting bytecode to machine code, enabling the program to run on the system.
-----------------------------------------------------------------------------------trust the process you will win .
Real time use of stack,queue,ll,tree,graph

Here’s a breakdown of the real-time applications of stacks, queues, linked lists, trees, and graphs:

1. Stack
Undo Functionality: In applications like text editors, the stack stores previous states. Each action is pushed to a stack, and "Undo" pops the last action.
Web Browser Navigation: Browsers use stacks to store the history of pages you visited. Pressing "Back" pops the last page, returning to the previous one.
Expression Evaluation: Compilers and interpreters use stacks to evaluate arithmetic expressions or syntax parsing.
Recursive Function Calls: Stacks help manage function calls in programming languages, especially with recursion, where each function call is stacked on top of the last one.

2. Queue
Scheduling Processes in Operating Systems: OS schedulers use queues to manage processes and tasks waiting to be executed.
Customer Service Lines: Any system handling requests in a first-come, first-served manner uses queues, like customer support chat systems or bank teller queues.
Printers: Print jobs are placed in a queue to be processed in order.
Data Streaming (e.g., IoT, Media): Data packets are queued and processed in the order they are received, ensuring consistent streaming.

3. Linked List
Music and Video Playlists: Applications often use linked lists to allow for easy insertion and deletion of items (songs, videos) without reordering the entire structure.
Undo/Redo Functionality: Linked lists can be used to store states, allowing easy navigation back and forth through user actions.
Memory Management: In low-level memory allocation, free blocks of memory can be stored in a linked list, allowing for dynamic memory allocation and deallocation.
File Systems: Many file systems use linked lists to store blocks of files, especially for files that aren’t contiguous in memory.

4. Tree
File Systems: File directories are often organized as a tree structure, where folders and files are stored hierarchically.
Databases (e.g., B-Trees in indexing): Databases use tree structures for efficient data indexing and retrieval, enabling quick searches.
XML/HTML Document Object Model (DOM): The DOM represents the structure of HTML or XML documents as a tree, allowing easy traversal and manipulation.
Artificial Intelligence (e.g., Decision Trees): Decision trees are used for various AI applications, including decision-making algorithms and machine learning models.


5. Graph
Social Networks: Graphs represent relationships between users. Nodes are people, and edges are connections (friendships, follows).
Navigation Systems (Google Maps, GPS): Graphs represent locations as nodes and paths as edges, allowing algorithms to find the shortest or optimal routes.
Network Routing: Graphs model networks where routers and switches are nodes, and data connections are edges, supporting efficient routing of data packets.
Recommendation Systems: In recommendation engines, graphs model relationships between users and items (e.g., products, movies) to suggest items based on user interactions.
Each of these structures is essential for different types of applications due to their unique ways of managing data and allowing efficient data access, manipulation, and traversal.

-----------------------------------------------------------------------------------trust the process you will win .












