1. You are climbing a staircase. It takes n steps to reach the top.  (Leetcode 70)

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


class Solution {
    public int climbStairs(int n) {
        int dp[] = new int[n+1];
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
}


------------------------------------------------------------Trust the work you will win
2. Given a number of stairs and a frog, the frog wants to climb from the 0th stair to the (N-1)th stair. At a time the frog can climb either one or two steps. 
A height[N] array is also given. Whenever the frog jumps from a stair i to stair j, 
the energy consumed in the jump is abs(height[i]- height[j]), where abs() means the absolute difference. We need to return the minimum energy that can be used by the frog to jump from stair 0 to stair N-1.(TUF question)

public static void main(String args[]) {

  int height[]={30,10,60,10,60,50};
  int n=height.length;
  int dp[]=new int[n];
  Arrays.fill(dp,-1);
  dp[0]=0;
  for(int ind=1;ind<n;ind++){
      int jumpTwo = Integer.MAX_VALUE;
        int jumpOne= dp[ind-1] + Math.abs(height[ind]-height[ind-1]);
        if(ind>1)
            jumpTwo = dp[ind-2] + Math.abs(height[ind]-height[ind-2]);
    
        dp[ind]=Math.min(jumpOne, jumpTwo);
  }
  System.out.println(dp[n-1]);
}
------------------------------------------------------------Trust the work you will win
3. In this article, we will learn about "Dynamic Programming: Frog Jump with k Distances (DP 4)"

Problem Statement:  Frog Jump with K Distance/ Learn to write 1D DP
Problem Statement:
This is a follow-up question to “Frog Jump” discussed in the previous article. In the previous question, 
the frog was allowed to jump either one or two steps at a time. In this question, 
the frog is allowed to jump up to ‘K’ steps at a time. If K=4, the frog can jump 1,2,3, or 4 steps at every index.

  static int solveUtil(int n, int[] height, int[] dp, int k) {
        dp[0] = 0;

        // Loop through the array to fill in the dp array
        for (int i = 1; i < n; i++) {
            int mmSteps = Integer.MAX_VALUE;

            // Loop to try all possible jumps from '1' to 'k'
            for (int j = 1; j <= k; j++) {
                if (i - j >= 0) {
                    int jump = dp[i - j] + Math.abs(height[i] - height[i - j]);
                    mmSteps = Math.min(jump, mmSteps);
                }
            }
            dp[i] = mmSteps;
        }
        return dp[n - 1]; // The result is stored in the last element of dp
    }

    // Function to find the minimum cost to reach the end of the array
    static int solve(int n, int[] height, int k) {
        int[] dp = new int[n]; // Initialize a memoization array to store calculated results
        Arrays.fill(dp, -1);
        return solveUtil(n, height, dp, k);
    }


------------------------------------------------------------Trust the work you will win
4. . House Robber Leetcode 198

class Solution {
    public int rob(int[] nums) {
        
        int prev_prev=nums[0];

        if(nums.length == 1)
        {
            return prev_prev;
        }

        int prev = Math.max(nums[0],nums[1]);

        for(int i=2;i<nums.length;i++)
        {
          int curr = Math.max(prev,prev_prev+ nums[i]);
          prev_prev=prev;
          prev=curr;
        }
        return prev;
    }
}
------------------------------------------------------------Trust the work you will win
5.  House Robber II Leetcode 213

class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==0)
           return n;
        if(n<2)
           return nums[0];

       int[] dp1 = new int[n+1];
       int[] dp2 = new int[n+1];

       dp1[0]=dp2[0]=dp2[1]=0;
       dp1[1]=nums[0];
       for(int i=2;i<=n;i++)
       {
           dp1[i] = Math.max(dp1[i-1],dp1[i-2]+nums[i-1]);
           dp2[i] = Math.max(dp2[i-1],dp2[i-2]+nums[i-1]);
       }
       
       return Math.max(dp1[n-1],dp2[n]);
    }
}
------------------------------------------------------------Trust the work you will win
6
Problem Statement: A Ninja has an ‘N’ Day training schedule. He has to perform one of these 
three activities (Running, Fighting Practice, or Learning New Moves) each day. 
There are merit points associated with performing an activity each day. The same activity can’t be performed on two consecutive days.
We need to find the maximum merit points the ninja can attain in N Days.




We are given a 2D Array POINTS of size ‘N*3’ which tells us the merit point of specific activity on that particular day. Our task is to calculate the maximum number of merit points that the ninja can earn.


------------------------------------------------------------Trust the work you will win
7 unique paths leetcode 62

class Solution {
    //bottom up approach
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
         
         for(int i=0;i<m;i++)
         {
             dp[i][0]=1;
         }
         for(int j=0;j<n;j++)
         {
             dp[0][j]=1;
         }
         for(int i=1;i<m;i++)
         {
             for(int j=1;j<n;j++)
             {
                 dp[i][j]=dp[i-1][j]+dp[i][j-1];
             }
         }
         return dp[m-1][n-1];
    }
}
------------------------------------------------------------Trust the work you will win
