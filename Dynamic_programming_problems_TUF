1. You are climbing a staircase. It takes n steps to reach the top.  (Leetcode 70)

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


class Solution {
    public int climbStairs(int n) {
        int dp[] = new int[n+1];
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
}


------------------------------------------------------------Trust the work you will win
2. Given a number of stairs and a frog, the frog wants to climb from the 0th stair to the (N-1)th stair. 
At a time the frog can climb either one or two steps. 
A height[N] array is also given. Whenever the frog jumps from a stair i to stair j, 
the energy consumed in the jump is abs(height[i]- height[j]), where abs() means the absolute difference.
We need to return the minimum energy that can be used by the frog to jump from stair 0 to stair N-1.(TUF question)

public static void main(String args[]) {

  int height[]={30,10,60,10,60,50};
  int n=height.length;
  int dp[]=new int[n];
  Arrays.fill(dp,-1);
  dp[0]=0;
  for(int ind=1;ind<n;ind++){
      int jumpTwo = Integer.MAX_VALUE;
        int jumpOne= dp[ind-1] + Math.abs(height[ind]-height[ind-1]);
        if(ind>1)
            jumpTwo = dp[ind-2] + Math.abs(height[ind]-height[ind-2]);
    
        dp[ind]=Math.min(jumpOne, jumpTwo);
  }
  System.out.println(dp[n-1]);
}
------------------------------------------------------------Trust the work you will win
3. In this article, we will learn about "Dynamic Programming: Frog Jump with k Distances (DP 4)"

Problem Statement:  Frog Jump with K Distance/ Learn to write 1D DP
Problem Statement:
This is a follow-up question to “Frog Jump” discussed in the previous article. In the previous question, 
the frog was allowed to jump either one or two steps at a time. In this question, 
the frog is allowed to jump up to ‘K’ steps at a time. If K=4, the frog can jump 1,2,3, or 4 steps at every index.

  static int solveUtil(int n, int[] height, int[] dp, int k) {
        dp[0] = 0;

        // Loop through the array to fill in the dp array
        for (int i = 1; i < n; i++) {
            int mmSteps = Integer.MAX_VALUE;

            // Loop to try all possible jumps from '1' to 'k'
            for (int j = 1; j <= k; j++) {
                if (i - j >= 0) {
                    int jump = dp[i - j] + Math.abs(height[i] - height[i - j]);
                    mmSteps = Math.min(jump, mmSteps);
                }
            }
            dp[i] = mmSteps;
        }
        return dp[n - 1]; // The result is stored in the last element of dp
    }

    // Function to find the minimum cost to reach the end of the array
    static int solve(int n, int[] height, int k) {
        int[] dp = new int[n]; // Initialize a memoization array to store calculated results
        Arrays.fill(dp, -1);
        return solveUtil(n, height, dp, k);
    }


------------------------------------------------------------Trust the work you will win
4. . House Robber Leetcode 198

class Solution {
    public int rob(int[] nums) {
        
        int prev_prev=nums[0];

        if(nums.length == 1)
        {
            return prev_prev;
        }

        int prev = Math.max(nums[0],nums[1]);

        for(int i=2;i<nums.length;i++)
        {
          int curr = Math.max(prev,prev_prev+ nums[i]);
          prev_prev=prev;
          prev=curr;
        }
        return prev;
    }
}
------------------------------------------------------------Trust the work you will win
5.  House Robber II Leetcode 213

class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==0)
           return n;
        if(n<2)
           return nums[0];

       int[] dp1 = new int[n+1];
       int[] dp2 = new int[n+1];

       dp1[0]=dp2[0]=dp2[1]=0;
       dp1[1]=nums[0];
       for(int i=2;i<=n;i++)
       {
           dp1[i] = Math.max(dp1[i-1],dp1[i-2]+nums[i-1]);
           dp2[i] = Math.max(dp2[i-1],dp2[i-2]+nums[i-1]);
       }
       
       return Math.max(dp1[n-1],dp2[n]);
    }
}
------------------------------------------------------------Trust the work you will win
6  Longest common subsequence leetcode 1143

public static int longestCommonSubsequence(String text1, String text2) {
    int n1 = text1.length();
    int n2 = text2.length();
    int[][] dp = new int[n1 + 1][n2 + 1];

    // Step 1: Fill dp table
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Step 2: Traceback to print LCS
    StringBuilder ans = new StringBuilder();
    int i = n1, j = n2;

    while (i > 0 && j > 0) {
        if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
            ans.append(text1.charAt(i - 1)); // add matched char
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    ans.reverse(); // reverse to get correct order
    System.out.println("LCS: " + ans.toString());
    return dp[n1][n2];
}


------------------------------------------------------------Trust the work you will win
7 unique paths leetcode 62

class Solution {
    //bottom up approach
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
         
         for(int i=0;i<m;i++)
         {
             dp[i][0]=1;
         }
         for(int j=0;j<n;j++)
         {
             dp[0][j]=1;
         }
         for(int i=1;i<m;i++)
         {
             for(int j=1;j<n;j++)
             {
                 dp[i][j]=dp[i-1][j]+dp[i][j-1];
             }
         }
         return dp[m-1][n-1];
    }
}
------------------------------------------------------------Trust the work you will win

8 Unique paths II leetcode 63

class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n=obstacleGrid.length, m=obstacleGrid[0].length;
        int[][] dp=new int[n][m];
        dp[0][0]=1;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(obstacleGrid[i][j]==1)   
                 dp[i][j]=0;
                else{
                    if(i>0)    dp[i][j]+=dp[i-1][j];
                    if(j>0)    dp[i][j]+=dp[i][j-1];
                }
            }
        }
        return dp[n-1][m-1];
    }
}
------------------------------------------------------------Trust the work you will win
9 Minimum Path Sum leetcode 64
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    continue; //Starting Point
                }
                if (i == 0) {
                    grid[i][j] += grid[i][j - 1]; // Only from left
                } else if (j == 0) {
                    grid[i][j] += grid[i - 1][j]; // Only from above
                } else {
                    grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); // Minimum from left or above
                }
            }
        }

        return grid[m - 1][n - 1];
    }
}
------------------------------------------------------------Trust the work you will win
10 Longest common substring

static void lcs(String s1, String s2) {
    int n = s1.length();
    int m = s2.length();

    int[][] dp = new int[n + 1][m + 1];
    int ans = 0; // stores max length
    int endIndex = 0; // stores end position of substring in s1

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];

                if (dp[i][j] > ans) {
                    ans = dp[i][j];
                    endIndex = i; // store where substring ends in s1
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }

    // Extract substring using endIndex and length
    String substring = s1.substring(endIndex - ans, endIndex);

    System.out.println("Length of Longest Common Substring: " + ans);
    System.out.println("Longest Common Substring: " + substring);
}
------------------------------------------------------------Trust the work you will win
11 print all substrings
public class Main {
    public static void main(String[] args) {
        String str = "abc";
        printSubstrings(str, 0, 0);
    }

    static void printSubstrings(String str, int start, int end) {
        // Base case: if we reach end of string
        if (start == str.length()) {
            return;
        }

        // If end reached, move start to next index
        if (end == str.length()) {
            printSubstrings(str, start + 1, start + 1);
        } else {
            // Print substring from start to end
            System.out.println(str.substring(start, end + 1));
            printSubstrings(str, start, end + 1);
        }
    }
}
------------------------------------------------------------Trust the work you will win
12 print all subsequence

public class Main {
    public static void main(String[] args) {
        String str = "abc";
        printSubsequence(str, "");
    }

    static void printSubsequence(String str, String ans) {
        // Base case: when string becomes empty
        if (str.length() == 0) {
            System.out.println(ans);
            return;
        }

        char ch = str.charAt(0);
        String remaining = str.substring(1);

        // Include the character
        printSubsequence(remaining, ans + ch);

        // Exclude the character
        printSubsequence(remaining, ans);
    }
}
------------------------------------------------------------Trust the work you will win
13 Triangle minpath leetcode 120 
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();   
        int[][] dp = new int[n][n];
        for(int j=0; j<n; j++)
            dp[n-1][j] = triangle.get(n-1).get(j);
        for(int i=n-2; i>=0; i--){
            for(int j=i; j>=0; j--){
                dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i+1][j],dp[i+1][j+1]);
            }
        }
    return dp[0][0];    
    }
}
------------------------------------------------------------Trust the work you will win



 




