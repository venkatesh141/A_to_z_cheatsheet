Cn Spring boot notes part 2


Persistence Explained in Simple Terms
Persistence means storing data permanently so that it remains available even after the application or system stops running. In programming,
it ensures that data created or modified by an application is saved in a persistent storage medium like a database, file system, or disk.
-----------------------------------------------------------------
In Spring Boot, derived queries refer to methods in Spring Data JPA repositories that automatically generate SQL queries based on the method name. 
This feature is a part of the Spring Data JPA framework, which allows developers to write database query methods without explicitly writing SQL code.

Derived queries are named methods in repository interfaces that follow a specific naming convention. Spring Data JPA interprets these method names and generates the required query dynamically.

Key Features of Derived Queries:
Method Naming Convention: The method name defines the query operation (e.g., findBy, readBy, countBy, etc.) and the fields used in the query.
No Need for Manual SQL: You don't have to write the actual SQL or JPQL query; Spring automatically generates it based on the method name.
Easy to Use: It simplifies the process of writing basic CRUD and simple conditional queries.
-----------------------------------------------------------------
Spring Data JPA is a part of the Spring Data project that simplifies the implementation of JPA (Java Persistence API)-based repositories. 
It provides a consistent way to interact with databases and helps developers focus on business logic 
by eliminating much of the boilerplate code associated with data access layers.
--------------------------------------------------------------------------
	public interface ToDoRepository: This declares an interface named ToDoRepository. It's a way to define how your application will interact with the database to manage Todo objects.

extends CrudRepository<Todo, Long>: This means that ToDoRepository is using the CrudRepository interface provided by Spring Data.

Todo: This is the type of object the repository will manage. It's usually a class representing a table in your database.
Long: This is the type of the ID field in the Todo class (the primary key).
Purpose:
By extending CrudRepository, your ToDoRepository automatically gets basic methods like:

save(Todo entity): Save a Todo object to the database.
findById(Long id): Find a Todo by its ID.
findAll(): Get all Todo objects.
deleteById(Long id): Delete a Todo by its ID.
In simple terms:
This code is saying:
"I want to create a way to easily save, update, retrieve, and delete Todo items from the database,
 and I don't need to write the code for these operations manually because Spring will handle it for me."
-------------------------------------------------------------------------------------------------------------
1. What is JpaRepository?

    JpaRepository is an interface provided by Spring Data JPA that helps you interact with the database without writing SQL queries.
    It provides built-in methods like s

    ave(), findById(), findAll(), delete(), etc., to perform basic CRUD operations (Create, Read, Update, Delete).
    It works with JPA (Java Persistence API), which is a standard for managing database tables as Java objects (called entities).

When you extend JpaRepository, you automatically get all these database-related methods for free.
2. What does this line mean?

public interface ItemDetailsRepository extends JpaRepository<ItemDetails, Integer>

    ItemDetailsRepository: This is your custom repository interface.
    extends JpaRepository<ItemDetails, Integer>:
        ItemDetails: This is the entity class that represents a table in your database.
        Integer: This is the data type of the primary key in your ItemDetails table (e.g., ID column is of type Integer).

So, this repository interface is linked to your ItemDetails table, and it will let you perform all database operations on this table.
3. What is a derived query?

Derived queries are methods in Spring Data JPA where you don‚Äôt write SQL. Instead, you create a method name that follows certain rules, and Spring automatically generates the query for you.
Example:

List<ItemDetails> findByPriceGreaterThan(double price);

    Method Name: findByPriceGreaterThan
        findBy: Means you want to retrieve data.
        Price: Refers to the column name in your ItemDetails table.
        GreaterThan: Means you want to find rows where the price is greater than the provided value.

What does it do?

This method will:

    Find all rows in the ItemDetails table where the value of the price column is greater than the value you pass as a parameter.
    It will return a list of ItemDetails objects.
------------------------------------------------------------------------
Let me explain these three types of queries in a simple way:
1. Derived Query

    Derived queries are built automatically by Spring Data JPA based on the method name.
    You don‚Äôt need to write SQL or JPQL; just follow the naming conventions, and Spring will do the rest.
    Example:

    public interface UserRepository extends JpaRepository<User, Long> {
        List<User> findByFirstName(String firstName); // Automatically generates a query like: SELECT * FROM users WHERE first_name = ?
    }

    Key point: No custom query is needed, just method names like findBy, countBy, etc.

2. JPQL (Java Persistence Query Language)

    JPQL is object-oriented. Instead of working with database tables, you write queries using entity names and their fields.
    Example:

    @Query("SELECT u FROM User u WHERE u.firstName = :firstName")
    List<User> findUsersByFirstName(@Param("firstName") String firstName);

        Here, User is the entity class, and firstName is the field in the class.
        JPQL is database-independent, making it portable.

3. Native Query

    Native queries are raw SQL queries written exactly as the database understands them.
    These queries are specific to the database you are using.
    Example:

    @Query(value = "SELECT * FROM users WHERE first_name = :firstName", nativeQuery = true)
    List<User> findUsersByFirstNameNative(@Param("firstName") String firstName);

        You are directly working with table names (users) and column names (first_name).

Key Differences:
Type	What it uses	When to use
Derived Query	Method names	When queries are simple and follow common patterns.
JPQL	Entity and field names	When you want a query that is portable and uses object-oriented concepts.
Native Query	Raw SQL and table/columns	When you need complex queries or database-specific features not supported by JPQL.

Let me know if you'd like to see more examples!

---------------------------------------------------------------------------------


	@Query("SELECT c.name FROM Course c where: student MEMBER OF c.students")
	List<String> getCoursesByStudentId(@Param("student") Student student);


This is a Spring Data JPA query used to retrieve a list of course names for a specific student. Let me explain it step by step:

Purpose:
The query fetches the names of courses that a given student is enrolled in.

Query Explanation:

SELECT c.name FROM Course c:
This selects the name of all courses (Course is the table or entity name).
where :student MEMBER OF c.students:
This checks if the given student (:student) is a member of the students list in a course.
(The c.students represents the list of students enrolled in that course.)
Method Explanation:

@Query(...):
Defines a custom JPQL (Java Persistence Query Language) query.
@Param("student"):
Maps the student parameter in the method to the :student placeholder in the query.
How it works:

You call this method and pass a Student object as input.
It checks which courses the student belongs to and retrieves their names as a list of strings.
Example in Action:
If the database contains:

Course A with students [John, Alice]
Course B with students [Alice]
Course C with students [John]
And you pass a Student object representing "John," the query will return:
["Course A", "Course C"].

Simplified Analogy:
Think of Course as a classroom, and students as the people in it.
This query finds all classrooms where the given student is present and returns their names.

-------------------------------------------------------------------------------------------------


	@Query(value="SELECT * FROM item WHERE description LIKE CONCAT(?1,'%') LIMIT 4",nativeQuery=true)
	List<Item> getItemByDesc(@Param("desc") String desc);

What does this code do?
The @Query annotation is used to define a custom SQL query that retrieves a list of items from a database table named item, 
where the description column starts with a specified value (desc). It limits the result to a maximum of 4 rows.

Breaking it down:
Annotation:

java
Copy
Edit
@Query
This annotation is used to write a custom SQL query in a Spring Data JPA repository.
The nativeQuery=true part means this is a native SQL query (not JPQL).
SQL Query:

sql
Copy
Edit
SELECT * FROM item WHERE description LIKE CONCAT(?1, '%') LIMIT 4
SELECT * FROM item: Retrieves all columns of rows from the item table.
WHERE description LIKE CONCAT(?1, '%'): Filters the rows to include only those where the description starts with the value provided by the first parameter (?1).
?1: Refers to the first method argument (desc).
CONCAT(?1, '%'): Combines the input string with the % wildcard, so it matches any value that starts with desc.
LIMIT 4: Restricts the number of results to a maximum of 4 rows.
Method Signature:

java
Copy
Edit
List<Item> getItemByDesc(@Param("desc") String desc);
List<Item>: The method returns a list of Item objects (mapped to the item table in the database).
@Param("desc"): This binds the method parameter desc to the query's placeholder (?1).


--------------------------------------------------------------------------------------
What is JPA?
JPA (Java Persistence API) is a Java specification that provides a standard way to interact with relational databases in Java applications. It defines a set of rules and interfaces to manage data between Java objects (entities) and a database.

Key Features of JPA:
Object-Relational Mapping (ORM):

JPA maps Java classes (objects) to database tables.
Each Java object corresponds to a row in the table, and the fields in the class map to the columns in the table.
Abstraction:

JPA abstracts away most of the complex SQL operations. Developers can work with objects instead of writing raw SQL for basic CRUD operations.
Annotations for Configuration:

JPA uses annotations like @Entity, @Table, @Id, and @Column to configure mappings between Java objects and database tables.
Querying with JPQL:

JPA provides a query language called JPQL (Java Persistence Query Language), which is similar to SQL but operates on Java objects instead of database tables.
Transaction Management:

JPA integrates with Java's transaction management to handle operations like commit and rollback.

-----------------------------------------------------------------------------------------


Why Use JPA?
Simplified Database Operations: No need to write complex SQL for common tasks.
Portability: JPA works with different databases without requiring major changes in the code.
Productivity: Built-in methods (e.g., findById) and tools reduce boilerplate code.
Integration: JPA integrates seamlessly with Spring Framework, making it a preferred choice for enterprise applications.
---------------------------------------------------------------------------------------------


Let‚Äôs simplify this!

In Hibernate, @NamedQuery and @NamedNativeQuery are like predefined queries that you can reuse in your code.

1. @NamedQuery
Think of it as a query written in HQL (Hibernate Query Language), which works with Java objects (entities).
You don‚Äôt write SQL here; instead, you refer to the entity and its fields.
Example:
java
Copy
Edit
@NamedQuery(
    name = "findEmployeeByName",
    query = "FROM Employee WHERE name = :name"
)
This says: "Find all employees whose name matches the given value."
How to use it:

java
Copy
Edit
TypedQuery<Employee> query = session.createNamedQuery("findEmployeeByName", Employee.class);
query.setParameter("name", "Venkatesh");
List<Employee> employees = query.getResultList();
2. @NamedNativeQuery
This is for raw SQL queries. You work directly with tables and columns in the database.
Use this when HQL can‚Äôt do what you need, or if the database-specific SQL is required.
Example:
java
Copy
Edit
@NamedNativeQuery(
    name = "findEmployeeByDept",
    query = "SELECT * FROM employee WHERE department = :dept",
    resultClass = Employee.class
)
This says: "Find all employees from a specific department (e.g., IT)."
How to use it:

java
Copy
Edit
Query query = session.createNamedQuery("findEmployeeByDept");
query.setParameter("dept", "IT");
List<Employee> employees = query.getResultList();
Difference in Simple Words:
@NamedQuery:

Works with objects (entities).
You use field names from your Java class.
Example: Employee.name
@NamedNativeQuery:

Works with database tables.
You use column names from your database.
Example: employee.name
If you want to search using objects, use @NamedQuery.
If you need to run a pure SQL query, use @NamedNativeQuery.


-----------------------------------------------------------------------------
Spring Security is a framework in Spring that helps secure your application by managing authentication 
(who you are) and authorization (what you're allowed to do). Here‚Äôs a simple explanation:

1. What Spring Security Does:
Authentication: Confirms the identity of the user (e.g., username and password check).
Authorization: Decides what actions the authenticated user can perform (e.g., viewing pages or accessing APIs).
Protects your application from common security risks like:
Cross-Site Scripting (XSS)
Cross-Site Request Forgery (CSRF)
Session Hijacking
2. How It Works:
Filters: Spring Security uses a chain of filters to intercept requests. For example:
Checks if the user is logged in.
Confirms if the user has permission to access the resource.
User Details: It verifies user credentials against stored data (e.g., a database).
Roles and Permissions: You can assign roles like ADMIN or USER and allow access based on these roles.
3. Basic Features:
Login and Logout: Adds default login and logout pages.
Password Management: Handles secure storage and validation of passwords.
URL Protection: Allows you to restrict certain URLs (e.g., /admin is only for admins).
Custom Security Rules: Lets you define custom rules like "Users can only access their own data."
4. Simple Example:
Imagine you‚Äôre building a banking website:

Authentication: Users must log in with a valid username and password.
Authorization: Only users with the "Manager" role can view all accounts. Regular users can only see their own account.
5. Key Terms to Know:
@EnableWebSecurity: Activates Spring Security in your application.
WebSecurityConfigurerAdapter: A class where you define your security rules.
CSRF Protection: Prevents attackers from making unauthorized actions on behalf of a logged-in user.

------------------------------------------------------------------------------

Session management in Spring Security ensures that a user's session is handled securely when they log in to your application. Here's a simple explanation:

Key Concepts:
What is a Session?

A session is like a container that stores user-specific data (e.g., login status) during their interaction with a website.
Why Session Management?

To track if the user is logged in.
To protect against unauthorized access and session-related attacks.
How Spring Security Manages Sessions:
Session Creation:

When a user logs in, Spring Security can create a session to keep them authenticated for the duration of their visit.
Session Timeout:

Sessions automatically expire after a specific time (e.g., 30 minutes). This prevents unauthorized access if the user leaves their device unattended.
Session Fixation Protection:

Prevents session hijacking by generating a new session ID after login. This ensures a safe session.
Concurrent Session Control:

Limits the number of active sessions per user. For example, you can restrict a user to be logged in on only one device at a time.
Session Invalidity:

If the user logs out or the session expires, Spring Security invalidates the session to ensure the user is logged out.
------------------------------------------------------------------------------------------
Remember ME
The "Remember Me" feature in Spring Security allows users to stay logged in even after they close their browser or their session expires. Here's a simple explanation:

How It Works:
Without "Remember Me":

When the session ends (like when you close the browser), the user has to log in again.
With "Remember Me":

When the user selects "Remember Me" (usually a checkbox), Spring Security stores their login details securely. Even if the session ends or the browser is closed, the user will stay logged in.
Key Steps:
Token Generation:

When the user logs in and selects "Remember Me," Spring Security generates a unique token tied to their account.
Token Storage:

The token is stored in a cookie on the user's browser.
Token Validation:

When the user revisits the site, Spring Security checks the cookie. If the token is valid, it automatically logs the user in.

-----------------------------------------------------------------------------------
CSRF protection in Spring Security ensures that malicious websites can't trick a logged-in user into performing unwanted actions on your web application. Here's a simple explanation:

Without CSRF Protection:
You are logged into your Amazon account in one browser tab.
An attacker tricks you into clicking a fake link or opening a malicious website.
Example: The malicious link might look like this:

If Amazon doesn‚Äôt have CSRF protection, this fake link could place an order on your behalf without your consent (because you're already logged in).
With CSRF Protection:
When you log in to Amazon, the server gives your browser a CSRF token (a secret code).
This token is unique to your session.
When you add items to your cart or place an order, Amazon includes this token in every request.
If a fake website or link tries to make a request (like placing an order), it won‚Äôt have the CSRF token.
Amazon checks for the token, sees it‚Äôs missing or invalid, and blocks the request.



What is CSRF?
CSRF (Cross-Site Request Forgery) is an attack where an attacker tricks a user into performing actions (like transferring money or changing a password) on a website where they're logged in.
For example:
You're logged into your bank's website in one browser tab.
An attacker tricks you into clicking a malicious link in another tab or email.
That link secretly sends a request to your bank to transfer money, using your login session.
How CSRF Protection Works:
CSRF Token:

Spring Security generates a random, unique CSRF token for each user session.
This token is included in every form or request sent by the user to the server.
Token Verification:

When the server receives a request, it checks if the CSRF token in the request matches the one stored for the user session.
If the token is missing or incorrect, the server rejects the request.
Steps in Spring Security:
Token Generation:

When a user loads a page with a form, Spring Security adds a hidden CSRF token to the form.
Token Submission:

When the user submits the form, the token is sent along with the request.
Token Validation:

The server validates the token. If it's valid, the request is processed. If not, it's rejected.

--------------------------------------------------------------------------------------------------------

1. Two-Factor Authentication (2FA)
What it is:
It adds an extra layer of security when you log in by requiring two steps to prove your identity:

Something you know (like your password).
Something you have (like your phone or a code).
Example (Amazon):

You enter your username and password.
Amazon sends a one-time code (OTP) to your phone or email.
You enter the OTP, and only then can you log in.
Why it‚Äôs important:
Even if someone steals your password, they can‚Äôt log in without the second factor (your phone or code).

2. OAuth Authentication (Login with Google/Facebook)
What it is:
OAuth is a way to let you log in to one application (like a website or app) using your account from another service (like Google, Facebook, or Twitter).

It delegates authentication to a trusted provider, so you don‚Äôt need a separate password for every app.
Example:
You want to log in to an e-commerce website. Instead of creating a new account, you click "Log in with Google":

The e-commerce website redirects you to Google‚Äôs login page.
You log in to Google, and it asks, ‚ÄúDo you allow this app to access your basic info?‚Äù
If you approve, Google sends your info (like your name and email) back to the e-commerce website.
You‚Äôre logged in without creating a new account.
Why it‚Äôs important:

Easier for users (fewer passwords to remember).
Safer for apps (they don‚Äôt store your passwords).
3.What is OpenID Connect?
OpenID Connect is a way to confirm who you are when logging into an application.
It's built on top of OAuth 2.0 but focuses on identity verification.
Imagine This Scenario:
You want to log in to an online shopping site (like Amazon). Instead of creating a new account, you click "Log in with Google." Here's what happens:

Redirect to Google:

The shopping site redirects you to Google‚Äôs login page.
You enter your Google username and password.
Google Confirms Your Identity:

After you log in, Google generates an ID token that includes details like:
Your name.
Your email address.
A unique user ID.
Send Back to the Shopping Site:

Google sends the ID token back to the shopping site.
The shopping site verifies the token to ensure it came from Google and confirms you are who you claim to be.
Logged In:

You‚Äôre logged into the shopping site without creating a separate account.
Key Terms in OpenID Connect:
ID Token: A digital ‚Äúproof‚Äù from the identity provider (e.g., Google) that says, ‚ÄúThis is John Doe.‚Äù
Identity Provider: The trusted service (e.g., Google, Facebook) that verifies your identity.
Relying Party: The app or website (e.g., Amazon) that uses OpenID Connect to log you in.

4. Integrate with Other Frameworks
What it means:
You can combine Spring Security with other frameworks like React, Angular, or any backend system to secure the whole application.

Example:
You‚Äôre building an app with React for the frontend and Spring Boot for the backend.

In the frontend, you use a React library to log in the user via OAuth or OpenID Connect (like with Google).
In the backend, Spring Security validates the token to ensure the user is authenticated.
The user can now access secure features like their profile or order history.
Why it‚Äôs important:
You can secure modern, multi-layered applications while allowing smooth integration between frontend and backend.

------------------------------------------------------------------------------------
In Spring Boot, @Param is used to pass values into queries when you are writing custom database queries in a repository.

Think of it like this:
If you have a query that needs extra information (like filtering by a name or ID), @Param allows you to pass that information to the query.
---------------------------------------------------------------------------------------
1. HTTP Basic Authentication
Imagine you go to a secure office. Every time you want to enter, you must tell the guard your name and password.
The guard checks the information and lets you in if it's correct.

How it works:
Your name and password (like a username and password in coding) are sent every single time you make a request to the server.
üõë Risk: If someone sees your name and password, they can pretend to be you.
2. Form-Based Authentication
Now, let‚Äôs say you go to the same secure office, but this time you fill out a login form at the entrance.
Once you are logged in, the office gives you a pass (like a session ID or cookie).
Now, instead of telling your name and password again, you just show the pass every time you want to enter.

How it works:
You fill out a login form (username and password), and the server gives you a pass (session ID).
For future requests, you don‚Äôt send your username and password again. You just show your pass.
üõë Risk: If someone steals your pass, they can enter the office.
3. JWT Authentication (JSON Web Token)
This is like getting a badge from the secure office after you log in.
The badge not only proves who you are but also contains some extra information about you (e.g., your role: employee, manager, etc.).
You show this badge every time you want to enter. The guard checks the badge to ensure it‚Äôs real and valid.

How it works:
After logging in, the server gives you a special badge (JWT). This badge has:
Your identity (e.g., username).
Some other details (e.g., your role or permissions).
An expiry date.
You send this badge every time you make a request. The server checks your badge to allow or deny access.
üõë Risk: If someone steals your badge, they can use it until it expires.


1. OAuth (Open Authorization)
Imagine you want to play a game on your phone, but instead of creating a new account, the game gives you an option to "Login with Google" or "Login with Facebook."

What happens:
You click "Login with Google."
Google asks you, "Do you allow this game to use your account?"
If you say yes, Google tells the game, "This is Venkatesh, and he is logged in."
The game never gets your Google password, only permission to access your account.
Simple idea: OAuth lets you use another account (like Google) to log in safely without sharing your password.

2. OpenID Connect (OIDC)
OpenID Connect is just like OAuth but with extra details.

Imagine you log in with Google again, but now the app also needs to know:

Your name
Your email address
Maybe even your profile picture
OpenID Connect adds this extra information to the process, so the app knows more about you.

Simple idea: OpenID Connect is OAuth with extra personal information like your name or email.

3. LDAP (Lightweight Directory Access Protocol)
Imagine you work in a big company. The company gives you one login (username and password) that works for:

Your email
Your office computer
Company apps (like HR systems)
How does this work?

The company has a big directory (like a phonebook) where it stores all employee usernames and passwords.
Whenever you log in to any system, it checks this central directory to confirm who you are.
Simple idea: LDAP is like a company phonebook that manages logins for all employees in one place.


----------------------------------------------------------------------------------------------

1. Lombok
Lombok is like a helper tool in Java that saves you from writing boring, repetitive code.

The Problem Without Lombok
When you create a class (e.g., a Person class), you often need to write:

Getters and Setters (to access or update fields like name or age).
Constructors (to create objects).
toString() method (to print details of the object).
Equals and HashCode methods (to compare objects).
Writing all these can take a lot of time and make your code messy.

How Lombok Helps
Lombok generates all that code for you automatically!

Just add annotations like @Getter, @Setter, or @ToString, and Lombok does the work.
Example Without Lombok
java
Copy
Edit
public class Person {
    private String name;
    private int age;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }

    // Constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // toString method
    @Override
    public String toString() {
        return "Person{name=" + name + ", age=" + age + "}";
    }
}
With Lombok
java
Copy
Edit
import lombok.*;

@Data  // Combines @Getter, @Setter, @ToString, @EqualsAndHashCode
@AllArgsConstructor
@NoArgsConstructor
public class Person {
    private String name;
    private int age;
}
‚úÖ Result: Clean, short, and easy-to-read code.

2. DTO (Data Transfer Object)
A DTO is like a messenger that carries data from one part of your program to another.

The Problem Without DTO
Imagine you have a big object with lots of details (e.g., User with name, email, password, etc.). When sending data to the frontend or another system, you may only want to send specific details (e.g., just name and email but not the password).

Why Use a DTO?
To filter out unnecessary data (e.g., hide passwords).
To format data differently for specific needs.
Example Without DTO
You send the whole User object directly to the frontend:

java
Copy
Edit
public class User {
    private String name;
    private String email;
    private String password;
}
Risk: The frontend may accidentally get sensitive data like the password.

Using DTO
You create a UserDTO to send only the required fields:

java
Copy
Edit
public class UserDTO {
    private String name;
    private String email;

    public UserDTO(String name, String email) {
        this.name = name;
        this.email = email;
    }
}
Now, instead of sending the full User object, you send the filtered UserDTO with just name and email.

Summary Table
Concept	What It Does	Why It Helps
Lombok	Auto-generates boring code like getters, setters, constructors, etc.	Saves time and keeps your code clean and readable.
DTO	A simple object to transfer specific data between parts of a program.	Ensures only necessary data is shared, improving security and clarity.
Let me know if you‚Äôd like further clarification!





Code Breakdown
java
Copy
Edit
import lombok.*;
This imports all the Lombok annotations like @Data, @AllArgsConstructor, @NoArgsConstructor, etc.
Lombok helps you generate repetitive code (e.g., getters, setters, constructors, etc.) automatically.
java
Copy
Edit
@Data
The @Data annotation is like a shortcut. It combines the following Lombok annotations:
@Getter - Generates get methods for all fields. (e.g., getName() and getAge())
@Setter - Generates set methods for all fields. (e.g., setName(String name))
@ToString - Generates a toString() method to print the object details.
@EqualsAndHashCode - Generates methods to compare objects (equals() and hashCode()).
What it does:
It creates code for accessing, updating, printing, and comparing your Person object, so you don‚Äôt have to write it manually.

java
Copy
Edit
@AllArgsConstructor
The @AllArgsConstructor annotation tells Lombok to generate a constructor that takes all the fields as parameters.
Example (Generated Code):

java
Copy
Edit
public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
How it helps:
You can create a Person object with all the field values directly:

java
Copy
Edit
Person person = new Person("Venkatesh", 25);
java
Copy
Edit
@NoArgsConstructor
The @NoArgsConstructor annotation tells Lombok to generate a default constructor with no parameters.
Example (Generated Code):

java
Copy
Edit
public Person() {
    // No-argument constructor
}
How it helps:
You can create an empty Person object and set values later:

java
Copy
Edit
Person person = new Person();
person.setName("Venkatesh");
person.setAge(25);
java
Copy
Edit
public class Person {
    private String name;
    private int age;
}
This is your Person class with two fields:
name - A String to store the person's name.
age - An int to store the person's age.

----------------------------------------------------------------------

1. Authentication Filter

    Think of it as the gatekeeper.
    Its job is to intercept every request that comes in.
    It checks: "Does this request have the information (credentials) needed for authentication?"
    For example:
        If it's a username and password, the filter collects them.
        If it's a token (like JWT), it extracts the token.

What happens here:

    The filter grabs the authentication details (username, password, or token).
    It creates an authentication object and passes it to the Authentication Manager for verification.

2. Authentication Manager

    The Authentication Manager is like the boss.
    It decides whether the user is valid or not.
    But the manager doesn't check the credentials directly. Instead, it delegates the work to one of its providers.

What happens here:

    It takes the authentication object from the filter.
    Passes it to the correct provider for validation.

3. Authentication Providers

    These are the specialized workers under the manager.
    Each provider knows how to authenticate a specific type of request. For example:
        One provider might validate username and password.
        Another provider might validate a JWT token.
        Another might handle OAuth-based logins (like Google or Facebook).

What happens here:

    The manager forwards the authentication object to the correct provider.
    The provider checks the credentials (e.g., matches username/password with the database, verifies the token, etc.).
    If everything is valid, it returns a success response.
    If not, it returns an authentication failure.

Flow: Request to Authentication Process

    Request comes in (HTTP Request):
        User sends their credentials (username/password or token).

    Authentication Filter:
        Intercepts the request.
        Extracts the credentials.
        Creates an authentication object and sends it to the manager.

    Authentication Manager:
        Receives the authentication object.
        Delegates the validation to the appropriate provider.

    Authentication Provider:
        Validates the credentials.
        Returns success or failure to the manager.

    Response:
        If authentication succeeds:
            The user is granted access (e.g., assigned a security context).
        If authentication fails:
            An error response is sent back (e.g., "Unauthorized").

Simple Analogy

Imagine you're entering a building:

    Authentication Filter: The security guard at the entrance asks for your ID.
    Authentication Manager: The head office checks whether you're allowed in.
    Authentication Providers: Different departments verify your credentials based on the type of ID you presented (employee badge, guest pass, or spe

    cial invitation).

Let me know if you'd like further clarification or an example with Java code! üòä

-------------------------------------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class HotelSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception 
	{
		http.csrf().disable()
			.authorizeHttpRequests()
			.anyRequest()
			.authenticated()
			.and()
			.formLogin();
		return http.build();
		
	}
	
	
}

explain me everything in a simple form 
ChatGPT said:
ChatGPT
Let's break down this code step by step in simple terms.

1. Overview
This is a Spring Security configuration class that protects your application by enabling user authentication and login forms. It's part of the Spring Security framework, which helps secure web applications by controlling access to different parts of the application.

2. Annotations Used
@Configuration

Tells Spring that this class contains configuration details for your application.
It‚Äôs like a setup file for defining beans (objects managed by Spring).
@EnableWebSecurity

Activates Spring Security for your application.
Without this, Spring Security won‚Äôt kick in.
3. Defining a Security Filter Chain
The filterChain(HttpSecurity http) method configures how security works in your app. It returns a SecurityFilterChain, which is a series of steps Spring uses to secure requests.

Inside filterChain:
http.csrf().disable()

CSRF (Cross-Site Request Forgery) is a security feature in Spring Security.
Here, it‚Äôs disabled because you might not need it in some cases (e.g., APIs).
If you're handling forms with sensitive actions, you should avoid disabling CSRF unless you understand its impact.
authorizeHttpRequests()

This tells Spring Security how to handle requests.
anyRequest().authenticated()

Ensures that all requests to your app require authentication.
If a user isn‚Äôt logged in, they‚Äôll be redirected to a login page.
formLogin()

Enables a built-in login form provided by Spring Security.
When a user tries to access a secured page, they‚Äôll see a default login form.
http.build()

Finalizes and builds the security configuration.
4. How It Works
When a request comes to your application:
Spring Security checks if the user is authenticated (logged in).
If not, the user is redirected to the login page.
After logging in, the user can access secured pages.
5. What This Code Does
Secures the entire application.
Redirects unauthenticated users to a login form.
Disables CSRF protection (not ideal for production unless you know the implications).
6. What Happens in the Browser?
User tries to access a secured page.
Spring Security detects the user is not logged in and redirects to /login.
User enters a username and password (you‚Äôll need to configure these separately).
After successful login, the user can access the secured pages.
Example Behavior
If you try to visit http://localhost:8080/some-page, you‚Äôll be redirected to the login form.
After logging in, you‚Äôll be able to view the page.
Key Points to Remember
CSRF Disabled: Only do this for APIs or if you are handling security another way.
Default Login Form: Spring provides a built-in login form. You can customize it later.
anyRequest().authenticated(): Protects all pages. You can modify it to allow public access to some pages.


-----------------------------------------------------------------------------------------------------------------

The @ResponseStatus(HttpStatus.OK) is like telling Spring Boot, "Always send back the HTTP 200 OK status when this API is called."

What is HTTP 200 OK?
It's a code that means "Everything is fine, your request worked!"
-----------------------------------------------------------------------------------------------------------------------------------


Basic authentication and ant matchers
Basic authentication is a way to secure your application where the user must provide a username and password to access certain resources.

    When a user tries to access a secured page, the browser asks for a username and password.
    The credentials are sent in encoded format (Base64) in the request header.
    The server checks if the credentials are valid.
        If valid ‚Üí access is granted.
        If invalid ‚Üí access is denied.
        
        
Ant Matchers (Simple Explanation)

Ant matchers are URL patterns used in Spring Security to define which URLs are protected and which are public.
Examples:

    Allow Public Access to Some URLs

http
    .authorizeHttpRequests(auth -> auth
        .requestMatchers("/public/**").permitAll() // Anyone can access URLs starting with /public/
        .anyRequest().authenticated() // Other requests need authentication
    )
    .httpBasic();

    "/public/**" ‚Üí Any URL starting with /public/ is accessible without login.
    anyRequest().authenticated() ‚Üí All other URLs require authentication.

Restrict Access to Admin Users

    http
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin/**").hasRole("ADMIN") // Only users with ADMIN role can access
            .anyRequest().authenticated()
        )
        .httpBasic();

        "/admin/**" ‚Üí Only users with the ADMIN role can access URLs starting with /admin/.

Key Takeaways

‚úÖ Basic Authentication ‚Üí Users need a username & password to access secured resources.
‚úÖ Ant

Matchers ‚Üí Used to define which URLs are protected and who can access them.

Would you like a real-world scenario or code example based on your needs? üòä

--------------------------------------------------------------------------------------------------
1Ô∏è‚É£ @Bean Annotation

@Bean

    This tells Spring that the method returns a Spring-managed object (bean).
    In this case, it returns a SecurityFilterChain, which defines security rules.

2Ô∏è‚É£ Creating the Security Filter Chain

public SecurityFilterChain filterChain(HttpSecurity http) throws Exception 

    This method sets up security rules using HttpSecurity.
    It controls access to different parts of the application.

3Ô∏è‚É£ Disabling CSRF

http.csrf().disable()

    CSRF (Cross-Site Request Forgery) is a security feature.
    It is disabled here, meaning the app won‚Äôt check for CSRF attacks.
    This is needed for APIs (like REST APIs) but should be enabled for web apps with forms.

4Ô∏è‚É£ Defining Access Rules

.authorizeHttpRequests()

    This means, "Decide who can access which URLs."

4.1 Restricting Access to "/hotel/"**

.antMatchers("/hotel/**").hasRole("ADMIN")

    Any URL starting with /hotel/ can only be accessed by users with the "ADMIN" role.
    Example:
        ‚úÖ /hotel/rooms ‚Üí Only ADMIN can access.
        ‚úÖ /hotel/bookings ‚Üí Only ADMIN can access.
        ‚ùå /home ‚Üí This is not affected by this rule.

4.2 Restricting All Other URLs

.anyRequest().authenticated()

    All other URLs require login.
    Example:
        ‚úÖ /dashboard ‚Üí Allowed if the user is logged in.
        ‚úÖ /profile ‚Üí Allowed if the user is logged in.

5Ô∏è‚É£ Enabling Basic Authentication

.and().httpBasic();

    This enables Basic Authentication, which means:
        When a user tries to access a protected page, a popup appears asking for username and password.
        Credentials are sent in the request as Base64-encoded text.

6Ô∏è‚É£ Returning the Security Configuration

return http.build();

    This applies the security settings and makes them active in the application.

Final Summary

‚úî CSRF disabled (useful for APIs).
‚úî "/hotel/" can only be accessed by users with the "ADMIN" role**.
‚úî All other URLs require login.
‚úî Basic authentication is used (browser asks for username & password).
--------------------------------------------------------------------------------------------
Here's your Spring Security configuration in a simple and well-formatted way:

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf().disable() // Disable CSRF (useful for APIs)
        .authorizeHttpRequests() // Define access rules
        .antMatchers("/hotel/**").hasRole("ADMIN") // Only ADMIN can access /hotel/** URLs
        .anyRequest().authenticated() // All other URLs require login
        .and()
        .httpBasic(); // Enable Basic Authentication (browser popup for username/password)

    return http.build(); // Apply and return security configuration
}

This code:
‚úÖ Disables CSRF (useful for REST APIs).
‚úÖ Restricts "/hotel/" to ADMIN users only**.
‚úÖ Requires authentication for all other URLs.
‚úÖ Uses Basic Authentication (username & password popup).

Would you like a test case to check this security in action? üöÄ

explain me in a simple form 
ChatGPT said:
ChatGPT
Simple Explanation of the Code üòä

This code is a security setup for a Spring Boot application. It decides who can access which URLs.
Step-by-Step Breakdown:

1Ô∏è‚É£ Disables CSRF:

http.csrf().disable()

    CSRF protection is turned off (useful for APIs).

2Ô∏è‚É£ Defines Access Rules:

.authorizeHttpRequests()

    This means "Set rules for different URLs."

3Ô∏è‚É£ Restricts Access to "/hotel/" URLs:**

.antMatchers("/hotel/**").hasRole("ADMIN")

    Only users with the "ADMIN" role can access URLs starting with /hotel/.
        ‚úÖ /hotel/rooms ‚Üí Only ADMIN can access.
        ‚úÖ /hotel/bookings ‚Üí Only ADMIN can access.
        ‚ùå /home ‚Üí This rule does not affect it.

4Ô∏è‚É£ Requires Login for All Other URLs:

.anyRequest().authenticated()

    All other pages require login (any user can log in).
        ‚úÖ /dashboard ‚Üí Allowed if the user is logged in.
        ‚úÖ /profile ‚Üí Allowed if the user is logged in.

5Ô∏è‚É£ Enables Basic Authentication:

.and().httpBasic();

    When a user tries to access a protected page, a popup appears asking for a username & password.

6Ô∏è‚É£ Applies the Security Configuration:

return http.build();

    This makes the security settings active.

Simple Summary:

‚úî "/hotel/" ‚Üí Only ADMIN users can access.
‚úî Other URLs ‚Üí Any logged-in user can access.
‚úî Uses Basic Authentication (browser popup asks for username & password).
‚úî CSRF is disabled (useful for APIs).

------------------------------------------------------------------------------------------------
@EnableGlobalMethodSecurity(prePostEnabled = true) is an annotation in Spring Security that allows you to use method-level security with @PreAuthorize and @PostAuthorize annotations.
Simple Explanation:

    Security at the Method Level
        Instead of securing an entire application, you can secure individual methods.
        Example: Allow only admins to call a method.

    What does prePostEnabled = true do?
        It enables @PreAuthorize (check before method runs) and @PostAuthorize (check after method runs).

    Example Usage:

    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser() {
        System.out.println("User deleted");
    }

        Only users with the ADMIN role can call deleteUser().

    Why use it?
        It helps control access to methods based on roles/permissions.

Let me know if you need a simpler breakdown! üòä
-------------------------------------------------------------------------------------------

User Persistence and JWT Authentication (Simple Explanation)
1. User Persistence
üîπ What is it?
User persistence means keeping the user logged in even after they close the app or refresh the page.

üîπ How does it work?
When a user logs in, their details (like ID, username, or session token) are stored in a database or session storage.

In web apps, it can be stored in cookies, local storage, or a session.
In backend systems, it's stored in a database (like MySQL, MongoDB, etc.).
üîπ Why is it needed?
Without persistence, users would have to log in every time they visit the app.

2. JWT (JSON Web Token) Authentication
üîπ What is JWT?
JWT (JSON Web Token) is a secure way to let users log in without storing session data on the server.

üîπ How does it work?

User logs in ‚Üí Sends username & password to the backend.
Server verifies user ‚Üí If correct, creates a JWT token.
Server sends JWT token ‚Üí The client (browser/mobile app) stores it (in local storage or a cookie).
User makes requests ‚Üí Each request includes the JWT token.
Server checks token ‚Üí If valid, the request is allowed.
üîπ JWT Token Structure:
A JWT token looks like this:

It has 3 parts:

Header ‚Äì Contains token type & encryption method.
Payload ‚Äì User data (like user ID, name, etc.).
Signature ‚Äì Used to verify the token‚Äôs authenticity.
üîπ Why use JWT?

No need to store sessions on the server.
Fast and secure authentication.
Works well with microservices and APIs.
Simple Example (JWT in Action)
User logs in ‚Üí Gets a JWT token.
Every time the user requests data, the token is sent in the request.
Server verifies the token and allows access.
If the token expires, the user needs to log in again.

-------------------------------------------------------------------------------------------------------------------


Persistence of Credentials (Simple Explanation)
üîπ What does it mean?
Persistence of credentials means storing a user's login details so they don‚Äôt have to enter them every time they use the app.

üîπ Where can credentials be stored?

Database ‚Üí Stores hashed passwords for long-term login.
Session Storage ‚Üí Temporary storage; lost when the browser is closed.
Local Storage ‚Üí Stored in the browser; remains even after closing the browser.
Cookies ‚Üí Stored in the browser and sent with requests to keep the user logged in.
üîπ How does it work?

User logs in and enters credentials (email & password).
The server verifies and creates a session token or JWT token.
The token is stored (in cookies, local storage, or a database).
When the user visits again, the app automatically logs them in using the stored token.
üîπ Why is it needed?

So users don‚Äôt have to log in every time.
Improves user experience.
Helps in remember me features.
üîπ Security Considerations

Always hash passwords before storing them in a database.
Use HTTP-only cookies for storing JWT tokens securely.
Set expiration times for tokens to prevent unauthorized access.

-----------------------------------------------------------------------------------------------------------------

In Spring Boot, @Data is a Lombok annotation that automatically generates boilerplate code for Java classes. It is commonly used in entity classes, DTOs, and model classes to reduce manual coding.

What does @Data do?
When you add @Data to a class, Lombok automatically generates:
‚úÖ Getters for all fields
‚úÖ Setters for all fields
‚úÖ toString() method
‚úÖ equals() and hashCode() methods
‚úÖ A no-argument constructor (if no other constructor is present)



Let's break down RequestEntity<Employee> and RequestEntity<List<Employee>> in simple terms:

What is RequestEntity?
RequestEntity is a class in Spring used to represent HTTP requests with both the body and the headers. It‚Äôs used when you want to send a complete HTTP request (including the body, headers, and method type like GET, POST, etc.) to an API.

RequestEntity<Employee>
When you use RequestEntity<Employee>, you're creating a request where:

Employee is the type of object in the body of the request. It could be a single employee object (like Employee class) that you want to send to the server.
RequestEntity<Employee> indicates that the request body will contain a single Employee object.



Method: POST
URL: /addEmployee
Headers: {
    "Content-Type": "application/json"
}
Body: {
    "name": "John Doe",
    "age": 30,
    "position": "Developer"
}
---------------------------------------------------------------------------------------------
@EnableGlobalMethodSecurity(prePostEnabled = true) is an annotation in Spring Security that allows you to use method-level security.

Breaking it down simply:
@EnableGlobalMethodSecurity ‚Üí This enables security at the method level.
prePostEnabled = true ‚Üí This allows you to use @PreAuthorize and @PostAuthorize annotations on methods.
What does it do?
With this enabled, you can control access to methods based on user roles or conditions.

Example:
java
Copy
Edit
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser() {
    System.out.println("User deleted!");
}
This method will only execute if the user has the ADMIN role.
If a non-admin user tries to call deleteUser(), Spring Security will block access.
In short:
It activates method-level security, so you can restrict access to methods using @PreAuthorize and @PostAuthorize.








You said:
@PostAuthorize meaning
ChatGPT said:
@PostAuthorize in Simple Terms
@PostAuthorize is used after a method has executed. It checks the return value of the method and decides whether to allow or deny access.

How It Works:
The method executes first.
The return value is checked to see if the user has the required permissions.
If the condition is not met, access is denied (even though the method already ran).
Example:
java
Copy
Edit
@PostAuthorize("returnObject.owner == authentication.name")
public Order getOrder(int orderId) {
    return orderService.findById(orderId);
}
Explanation:
The method getOrder() runs and returns an Order object.
After execution, Spring Security checks if the logged-in user (authentication.name) is the owner of the order (returnObject.owner).
If the user is not the owner, access is denied.
When to Use @PostAuthorize?
When you need to check access based on the return value.
Example: A user can only see their own data, not others'.
üîπ Key difference from @PreAuthorize:

@PreAuthorize ‚Üí Checks before method execution.
@PostAuthorize ‚Üí Checks after method execution.

-----------------------------------------------------------------------------------------------------



Understanding public class User implements UserDetails in a Simple Way
Think of Spring Security as a guard that checks who is logging in and what they can access.

But how does the guard know who the users are? ü§î

That‚Äôs where UserDetails comes in! It‚Äôs like a blueprint that tells Spring Security how to get user information.

Why User implements UserDetails?
When we write:

java
Copy
Edit
public class User implements UserDetails
It means:

We are creating a custom user class (User)
This class must provide login details (like username, password, and roles)
Spring Security will use this class to authenticate users
üîπ How Does It Work?
Imagine you are building a login system for a website.
1Ô∏è‚É£ A user enters their username and password.
2Ô∏è‚É£ Spring Security checks the database to see if the user exists.
3Ô∏è‚É£ It compares passwords to verify the user.
4Ô∏è‚É£ If correct, it checks the user‚Äôs roles (e.g., ADMIN or USER).
5Ô∏è‚É£ If the user is allowed, they get access to the website.

To do all of this, Spring Security needs user details‚Äîand that‚Äôs why we implement UserDetails!

üîπ Full Example
java
Copy
Edit
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import java.util.Collection;

public class User implements UserDetails {

    private String username;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;

    // Constructor
    public User(String username, String password, Collection<? extends GrantedAuthority> authorities) {
        this.username = username;
        this.password = password;
        this.authorities = authorities;
    }

    // ‚úÖ This method returns the username (Spring Security will use this for authentication)
    @Override
    public String getUsername() {
        return username;
    }

    // ‚úÖ This method returns the password (Spring Security will check this during login)
    @Override
    public String getPassword() {
        return password;
    }

    // ‚úÖ This method returns the user's roles (like ADMIN or USER)
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    // ‚úÖ If false, the account is expired (User cannot log in)
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    // ‚úÖ If false, the account is locked (User cannot log in)
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    // ‚úÖ If false, password is expired (User cannot log in)
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // ‚úÖ If false, the user is disabled (User cannot log in)
    @Override
    public boolean isEnabled() {
        return true;
    }
}
üîπ Breaking It Down Step-by-Step
1Ô∏è‚É£ What Does UserDetails Do?
Spring Security requires a standard format for user details.
By implementing UserDetails, we tell Spring Security:
‚úîÔ∏è Where to get the username
‚úîÔ∏è Where to get the password
‚úîÔ∏è How to check roles (ADMIN, USER, etc.)
‚úîÔ∏è If the account is locked or expired

2Ô∏è‚É£ How Does Spring Security Use This?
Whenever someone logs in, Spring Security calls these methods:
üìå getUsername() ‚Üí Checks if the username exists in the database
üìå getPassword() ‚Üí Compares the entered password with the stored password
üìå getAuthorities() ‚Üí Checks if the user has the right permissions
üìå isEnabled(), isAccountNonLocked(), etc. ‚Üí Checks if the account is valid

3Ô∏è‚É£ Where Does This Fit in a Real Project?
Usually, we fetch users from a database using UserDetailsService. Example:

java
Copy
Edit
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import java.util.Collections;

public class MyUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Assume we fetch user from database (hardcoded here)
        if ("venkatesh".equals(username)) {
            return new User("venkatesh", "password123", Collections.emptyList());
        } else {
            throw new UsernameNotFoundException("User not found");
        }
    }
}
üîπ In Simple Words
üëâ User implements UserDetails means this class tells Spring Security how to authenticate users.
üëâ It provides username, password, and roles so that Spring Security can verify the user when they log in.
üëâ Without UserDetails, Spring Security won't know how to check user credentials.

üîπ Summary
‚úÖ UserDetails is a Spring Security interface that stores user login details.
‚úÖ User class implements it to provide username, password, and roles.
‚úÖ Spring Security calls these methods during authentication.
‚úÖ Without UserDetails, Spring Security cannot verify users.


--------------------------------------------------------------------------------------------

You said:
@Bean
	public UserDetailsService users()
	{
		UserDetails user1 = User.builder()
				.username("tony")
				.password(passwordEncoder().encode("password"))
				.roles("NORMAL")
				.build();
		
		UserDetails user2 = User.builder()
				.username("steve")
				.password(passwordEncoder().encode("nopassword"))
				.roles("NORMAL")
				.build();
		
		return new InMemoryUserDetailsManager(user1,user2);
	}
	
	@Bean
	public PasswordEncoder passwordEncoder()
	{
		return new BCryptPasswordEncoder();
	}


explain me in a simple form these two functions one by one 
ChatGPT said:
ChatGPT

Let me explain these two functions step by step and in simple words:
1. users() Method

    This function is responsible for creating user details and storing them in memory for authentication purposes.
    It acts as your user database, but instead of a real database (like MySQL), the users are stored in memory.

Key Points:

    UserDetails:
        UserDetails represents a user's data (username, password, and roles).
        It is used by Spring Security to authenticate the user.

    User.builder():
        It's a helper class to create a user object easily.
        username(): Sets the user's name (e.g., "tony", "steve").
        password(): Sets the user's password (the password is encoded for security).
        roles(): Sets the user's role (e.g., "NORMAL").

    InMemoryUserDetailsManager:
        This is like a fake "database" that stores the users temporarily in memory.
        It holds the user1 and user2 created above.

What Happens:

    You're creating two users:
        tony with password "password" and role "NORMAL".
        steve with password "nopassword" and role "NORMAL".
    These users are stored in memory so Spring Security can authenticate them.

2. passwordEncoder() Method

    This function provides a password encoder to encode passwords securely.
    It ensures that passwords are not stored as plain text (which would be a big security risk).

Key Points:

    BCryptPasswordEncoder:
        It is a strong and widely used encryption algorithm to encode passwords.
        It automatically adds random "salt" to passwords, making them very hard to crack.

    Why Encoding is Needed:
        When a user logs in, their raw password (e.g., "password") is encoded, and then Spring compares it to the encoded password stored for that user.
        This ensures that even if someone gets access to your stored passwords, they won't see the actual passwords.

What Happens:

    Whenever you set a password for a user (passwordEncoder().encode()), it gets encrypted using BCrypt.
    During login, Spring Security will use this encoder to check if the entered password matches the stored one.

How These Two Functions Work Together:

    users() creates users:
        Example:
            Username: tony, Password: encoded version of "password", Role: "NORMAL".
    passwordEncoder() secures passwords:
        The raw password is encoded before being saved.
        During authentication, the entered password is encoded again and matched with the saved encoded password.
    Authentication Flow:
        When someone logs in as tony with password "password", Spring Security:
            Encodes "password".
            Matches the encoded version with the one stored in memory.
            If they match, the user is authenticated.




-----------------------------------------------------------------------------------------------------------






















