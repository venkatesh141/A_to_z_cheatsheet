@Configuration
public class CorsConfig {


👉 @Configuration tells Spring Boot: This class contains bean definitions (like settings/configurations) that Spring should manage.
Here, we’re making a configuration for CORS (Cross-Origin Resource Sharing).

@Bean
public CorsFilter corsFilter() {


👉 @Bean tells Spring: This method will create an object (bean) that should be used inside the application.
We are creating a CorsFilter bean here.
CorsFilter is a Spring filter that controls which domains can call your API.

CorsConfiguration config = new CorsConfiguration();


👉 This makes a new CORS configuration object where we will set rules (who is allowed, what methods are allowed, etc.).

config.setAllowedOrigins(Arrays.asList( "https://opticwave.in/", "https://www.opticwave.in/" ));


👉 This sets which websites are allowed to call your backend.
Here, only https://opticwave.in and https://www.opticwave.in are allowed.
⚠️ Note: You should not put a trailing / (like https://opticwave.in/) — keep it as https://opticwave.in.

config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));


👉 This tells: These HTTP methods are allowed from those websites.
Example: GET for reading, POST for creating, PUT for updating, DELETE for deleting, etc.

config.setAllowedHeaders(Arrays.asList("*"));


👉 This means: Allow all headers (like Authorization, Content-Type, etc.).
If you didn’t allow them, the browser might block some requests.

config.setAllowCredentials(true);


👉 This means: Allow credentials like cookies, tokens, or authorization headers.
If this is false, the frontend won’t be able to send cookies or Authorization headers.

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();


👉 This creates a CORS source object that maps URL paths (like /api/**) to the CORS configuration.

source.registerCorsConfiguration("/**", config);


👉 This means: Apply the above CORS rules to all API paths (/** means everything).
So, no matter which endpoint is called, these CORS rules apply.

return new CorsFilter(source);


👉 Finally, return a new CorsFilter with our rules.
Spring Boot will use this filter to check every request and block/allow based on the rules.

✅ In short:
This config says:

Only https://opticwave.in and https://www.opticwave.in can call your API.

They can use methods: GET, POST, PUT, DELETE, OPTIONS, PATCH.

They can send any headers.

They can send credentials (like cookies/auth).

This rule applies to all your APIs.
---------------------------------------------------------------------------------------------

@Component
public class DataInitializer implements CommandLineRunner {
👉 @Component tells Spring: This class should be automatically discovered and used by Spring.
👉 implements CommandLineRunner means: Run this class’s run() method automatically when the application starts.

java
Copy code
@Autowired
private UserRepository userRepository;
👉 This injects (@Autowired) the UserRepository so you can save and find users in the database.

java
Copy code
private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
👉 Creates a password encoder with strength 12.
This means when you save passwords, they’ll be encrypted (hashed) securely.
(You never save raw passwords in the database).

java
Copy code
@Override
public void run(String... args) throws Exception {
👉 This method runs automatically after Spring Boot starts.
Here you write code that should run at application startup (like inserting a default admin).

java
Copy code
String adminEmail = "admin@opticwave.com";
👉 Sets the email ID of the default super admin user.

java
Copy code
if (userRepository.findByEmail(adminEmail).isEmpty()) {
👉 Checks in the database: Is there already a user with this email?

If no such user → create one.

If user exists → don’t create again.

java
Copy code
User superAdmin = new User();
👉 Creates a new User object (super admin user).

java
Copy code
superAdmin.setUsername("superadmin");
superAdmin.setEmail(adminEmail);
superAdmin.setRole(UserRole.ROLE_ADMIN);
👉 Sets the user’s:

Username = superadmin

Email = admin@opticwave.com

Role = ROLE_ADMIN (so he has admin powers).

java
Copy code
superAdmin.setPassword(passwordEncoder.encode("Opticwave@superAdmin@May@2025"));
👉 Sets the password for this user, but not in plain text!
It encrypts it using BCryptPasswordEncoder before saving.
(Default password → should be changed in production).

java
Copy code
userRepository.save(superAdmin);
👉 Saves the new admin user into the database.

java
Copy code
System.out.println("✅ Super Admin initialized with email: " + adminEmail);
👉 Prints a message in the console saying a new super admin is created.

java
Copy code
} else {
    System.out.println("ℹ️ Super Admin already exists.");
}
👉 If an admin already exists, just print a message instead of creating a new one.

✅ In short:
This code runs when the app starts and ensures there’s always one super admin in the database. If it’s missing, it creates one with default credentials.

----------------------------------------------------------------------


Perfect 👍 Let’s go line by line through your PhonePeConfig class in very simple words.

@Configuration
public class PhonePeConfig {


👉 @Configuration tells Spring Boot:
This class contains beans (objects) that are configuration-related and should be managed by Spring.

Here, we are configuring PhonePe payment client.

@Value("${phonepe.client.id}")
private String clientId;  // e.g., "PGTESTMERCHANT123"


👉 @Value picks a value from your application.properties (or application.yml) file.
This line takes phonepe.client.id value from the properties file and stores it in clientId.
Example:

phonepe.client.id=PGTESTMERCHANT123

@Value("${phonepe.client.secret}")
private String clientSecret;  // MUST be base64 encoded string


👉 Gets phonepe.client.secret from properties and stores it in clientSecret.
⚠️ This should be a base64 encoded string (not plain text).

@Value("${phonepe.client.version}")
private Integer clientVersion; // Usually 1


👉 Reads phonepe.client.version from properties and stores it in clientVersion.
Usually, PhonePe API version is 1.

@Value("${phonepe.env}")
private String env;


👉 Reads phonepe.env from properties.
It tells if you are using PRODUCTION (real payments) or SANDBOX (test mode).

Example in properties:

phonepe.env=SANDBOX

@Bean
public StandardCheckoutClient standardCheckoutClient() {


👉 @Bean means: This method returns an object (bean) that Spring Boot should manage and make available everywhere in the app.
Here, we are creating a StandardCheckoutClient bean (used to talk to PhonePe API).

Env environment = "PRODUCTION".equalsIgnoreCase(env) ? Env.PRODUCTION : Env.SANDBOX;


👉 This line checks:

If env = "PRODUCTION" → use Env.PRODUCTION (real payments).

Otherwise → use Env.SANDBOX (test environment).

So it switches automatically based on what you set in application.properties.

return StandardCheckoutClient.getInstance(clientId, clientSecret, clientVersion, environment);


👉 Creates and returns a StandardCheckoutClient using the values we loaded (clientId, clientSecret, clientVersion, environment).
This is the actual PhonePe API client you’ll use for payments.

✅ In short:
This class configures a PhonePe client for your app.

Reads values (id, secret, version, env) from application.properties.

Decides whether to use Sandbox or Production.

Creates a StandardCheckoutClient bean you can inject (@Autowired) anywhere in your app to interact with PhonePe.

Do you also want me to write the example application.properties entries you need for this config?

-------------------------------------------------------------------------------------------------------
@Configuration
@EnableWebSecurity
public class SecurityConfig {
👉 @Configuration: This class is a configuration class managed by Spring.
👉 @EnableWebSecurity: Turns on Spring Security for your project.
This is where you define how authentication and authorization work.

java
Copy code
@Autowired
private UserDetailsService userDetailsService;
👉 Spring will inject your UserDetailsService.
This is used to load user details (like username, password, roles) from DB when someone logs in.

java
Copy code
@Autowired
private JwtFilter jwtFilter;
👉 Injects your custom JwtFilter.
This filter checks every request for a JWT token and validates it.

java
Copy code
@Bean
public WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring()
        .requestMatchers("/payment/callback");
}
👉 This says: Ignore security for the /payment/callback endpoint.
That means Spring Security won’t apply filters for that URL (needed because payment gateways call back without authentication).

java
Copy code
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
👉 Defines the main security rules for your app.
Spring Boot will use this to decide who can access which endpoints.

java
Copy code
return http.csrf(customizer -> customizer.disable())
👉 Disables CSRF protection (Cross-Site Request Forgery).
Usually disabled for APIs since JWT is used instead of sessions.

java
Copy code
.authorizeHttpRequests(request -> 
    request.requestMatchers("/auth/**").permitAll()
    .anyRequest().permitAll())
👉 Authorization rules:

Any request starting with /auth/** → allowed for everyone (login, signup, etc.).

.anyRequest().permitAll() → Right now, every other request is also open to everyone.
⚠️ Usually you would use .authenticated() here for secured APIs.

java
Copy code
.httpBasic(Customizer.withDefaults())
👉 Enables basic authentication (username & password in headers).
(Not used much when JWT is enabled, but it’s there as a fallback).

java
Copy code
.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
👉 Tells Spring Security: Don’t create sessions, we’re using JWT (stateless authentication).
So, every request must carry a token.

java
Copy code
.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
👉 Adds your custom jwtFilter before the normal UsernamePasswordAuthenticationFilter.
This makes sure JWT is checked before Spring processes login.

java
Copy code
.build();
👉 Builds the SecurityFilterChain with all rules.

java
Copy code
@Bean
public AuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setPasswordEncoder(new BCryptPasswordEncoder(12));
    provider.setUserDetailsService(userDetailsService);
    return provider;
}
👉 This sets up how authentication should happen:

Uses DaoAuthenticationProvider (checks users in DB).

Uses BCryptPasswordEncoder(12) for password hashing.

Uses your userDetailsService to load users from DB.

java
Copy code
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
}
👉 Exposes an AuthenticationManager bean.
This object is used by Spring to authenticate users with username + password.

java
Copy code
@Bean
public BCryptPasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
}
👉 Creates a reusable password encoder bean so you can inject it anywhere to encode/verify passwords.

✅ In short:

Ignores /payment/callback security.

/auth/** is open to everyone.

Everything else is currently also open (since .anyRequest().permitAll()).

JWT filter checks tokens before normal login filter.

Users are loaded from DB via UserDetailsService.

Passwords are securely stored with BCrypt.

App is stateless → no sessions, JWT only.




-----------------------------------------------------------------------------------------------------

@Component
public class JwtFilter extends OncePerRequestFilter {
@Component: tells Spring to create and manage an instance of this class automatically (so it can be injected elsewhere).

public class JwtFilter extends OncePerRequestFilter: this defines a filter that runs once for every HTTP request. OncePerRequestFilter ensures the filter logic runs exactly one time per request.

java
Copy code
    @Autowired
    private JwtUtil jwtService;
@Autowired injects an instance of JwtUtil (your helper that extracts/validates data from JWTs).

jwtService will be used to read username from token and validate tokens.

java
Copy code
    @Autowired
    ApplicationContext context;
This injects the Spring ApplicationContext. You later use it to fetch the MyUserDetailsService bean dynamically (instead of directly @Autowireding the service). This is a way to get beans at runtime.

java
Copy code
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
doFilterInternal is the method that runs for each incoming HTTP request.

You receive the request, response, and filterChain so you can inspect the request and either block it or pass it along (filterChain.doFilter(...)).

java
Copy code
        String uri = request.getRequestURI();
        String method = request.getMethod();
Read and store the request path (e.g., /products/123) in uri.

Read and store the HTTP method (GET/POST/PUT/DELETE) in method.

You use these to decide whether the request needs JWT checks or can be allowed freely.

java
Copy code
        // Logging the request URI and method
        System.out.println("Request URI: " + uri + " Method: " + method);
Simple console log of the request path and method. Useful for debugging to see incoming requests. (Note: in production, prefer a logger instead of System.out.println.)

java
Copy code
        if (request.getRequestURI().startsWith("/payment/")) {
            filterChain.doFilter(request, response);  // Skip JWT processing
            return;
        }
If the request path begins with /payment/, skip all JWT checks and continue the filter chain.

This is common when payment callbacks come from external services and you must allow them through unauthenticated.

java
Copy code
        // Skip auth/cart endpoints
        if (uri.startsWith("/auth/") || uri.startsWith("/cart/") || uri.startsWith("/products/filter")) {
            filterChain.doFilter(request, response);
            return;
        }
If the path starts with /auth/, /cart/, or /products/filter, the filter does not enforce JWT and just forwards request on.

Typical: /auth/** contains login/signup endpoints that must be public.

java
Copy code
        // Publicly accessible GET endpoints
        if (method.equals("GET") && (
                uri.equals("/slides") ||
                uri.equals("/products") ||
                uri.startsWith("/products/all") ||
                ...
                uri.equals("/cart")
        )) {
            filterChain.doFilter(request, response);
            return;
        }
This big if permits certain GET requests without authentication.

It checks many GET endpoints (slides, product lists, categories, colors, coupons, search, etc.) and if the current request matches one of them, the filter allows it to continue without token checks.

Notice use of equals for exact matches and startsWith for prefix patterns (e.g., /products/123).

After filterChain.doFilter(...) the method returns — meaning no JWT validation for those endpoints.

java
Copy code
        // JWT Validation
        String authHeader = request.getHeader("Authorization");
        String username = null;
        String token = null;
Now we begin JWT processing.

Read the Authorization header into authHeader.

Prepare username and token variables (will fill them if a Bearer token is present).

java
Copy code
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
            username = jwtService.extractUsername(token);
        }
If the Authorization header exists and starts with Bearer :

Remove the "Bearer " prefix (substring(7)) to get the raw token.

Ask jwtService to extract the username (or subject) embedded in the token.

If header is missing or not Bearer-type, both token and username remain null.

java
Copy code
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
Proceed only if we extracted a username and there is no existing authentication in the security context.

This prevents re-authenticating if someone already set authentication earlier.

java
Copy code
            UserDetails userDetails = context.getBean(MyUserDetailsService.class).loadUserByUsername(username);
Use ApplicationContext to get your MyUserDetailsService bean, then call loadUserByUsername(username) to get the UserDetails object (contains password hash and authorities).

You need UserDetails so you can validate the token against the user's data (for example to check if the token was issued for this user or if user is still active).

java
Copy code
            if (jwtService.validateToken(token, userDetails)) {
Ask jwtService to validate the token (signature, expiry, and optionally checks against userDetails).

If validation passes, we will create a Spring Authentication object and set it in the context.

java
Copy code
                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
Create an Authentication object representing the authenticated user:

Principal = userDetails

Credentials = null (we don't keep raw password here)

Authorities = user's roles/permissions

java
Copy code
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
Add extra details (like remote address, session id) to the auth token. This is optional but common so downstream code can access request-specific info from the authentication object.

java
Copy code
                SecurityContextHolder.getContext().setAuthentication(authToken);
Put the newly created authentication into Spring Security’s SecurityContext.

From now on (for the rest of this request processing) SecurityContextHolder.getContext().getAuthentication() will return this authenticated user — so controllers and security checks will see the user as logged-in.

java
Copy code
            }
        }
Ends the token validation and authentication-setting block.

java
Copy code
        filterChain.doFilter(request, response);
    }
Continue the filter chain for the request (either unauthenticated or now authenticated).

This call passes control to the next filter or ultimately to the controller that will handle the request.

java
Copy code
}
End of class.

Quick summary (very short)
This filter inspects every incoming request.

It logs URI+method.

It skips JWT checks for certain public paths (/payment/*, /auth/*, some cart/product endpoints, and many public GET endpoints).

For other requests it looks for a Bearer <token> header, extracts username, loads user details, validates token, and if valid sets authentication into Spring Security so the app treats the request as authenticated. Then it continues the chain.

Small helpful notes / possible improvements
Use a logger (org.slf4j.Logger) instead of System.out.println.

Be careful with trailing slashes (e.g., "/orders/" vs "/orders"); inconsistent slashes can cause unexpected behavior. Consider normalizing uri or using more robust path matching (Ant matchers or ServletPathMatcher).

Instead of calling context.getBean(...) every time, you could @Autowired your MyUserDetailsService directly unless you have a specific reason to get it from context.

For large sets of public URLs, consider centralizing rules in security config or use patterns to avoid a very long if condition.

If you want, I can:

show a cleaned-up version of this filter with improvements, or

convert the long public-GET list to a reusable helper so the code is easier to read.

-----------------------------------------------------------------------------------------------------------------------

1. Class Declaration
@Service
public class JwtUtil {


@Service → This tells Spring that this is a service class (business logic), and Spring will manage it automatically as a bean.

public class JwtUtil → This is your class to handle JWT tokens.

2. Secret Key
private SecretKey secretKey = Jwts.SIG.HS256.key().build();


SecretKey → This is the key used to sign and verify JWT tokens.

Jwts.SIG.HS256.key().build() → This tries to build a key for HS256 signing algorithm.

⚡ Note: The above key creation method may not work properly depending on JJWT version. Usually, we use KeyGenerator (like your constructor does).

3. Constructor
public JwtUtil() {
    try {
        KeyGenerator keyGen = KeyGenerator.getInstance("HmacSHA256");
        SecretKey key = keyGen.generateKey();
    } catch(Exception e) {
        e.printStackTrace();
    }
}


This constructor tries to generate a new secret key for signing tokens.

KeyGenerator.getInstance("HmacSHA256") → creates a generator for HMAC SHA-256 algorithm.

keyGen.generateKey() → generates a secret key.

But here, the generated key is stored in key and not assigned to secretKey, so your secretKey remains unchanged (bug).

e.printStackTrace() → prints error if key generation fails.

💡 You should fix this so it actually assigns the generated key:

secretKey = keyGen.generateKey();

4. generateToken
public String generateToken(String username, Long userId, UserRole role) {


This method creates a JWT token.

Inside:
Map<String,Object> claims = new HashMap<>();
claims.put("userId", userId);
claims.put("role", role);


claims → extra information stored in the JWT.

userId → stores user ID.

role → stores user role.

return Jwts.builder()
        .claims()
        .add(claims)
        .subject(username)
        .issuedAt(new Date())
        .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
        .and()
        .signWith(secretKey)
        .compact();


.claims().add(claims) → adds extra data to the token.

.subject(username) → main subject of the token (usually username).

.issuedAt(new Date()) → token creation time.

.expiration(...) → sets expiry (here 24 hours later).

.signWith(secretKey) → signs the token with the secret key.

.compact() → builds the token into a string format.

⚠ Problem:
.claims() and .add(claims) are not correct JJWT syntax. Usually, we do:

.claims(claims)

5. extractUsername
public String extractUsername(String token) {
    return extractClaim(token, Claims::getSubject);
}


Reads the username from a token.

Uses extractClaim helper function.

6. extractClaim
private <T> T extractClaim(String token, Function<Claims, T> claimResolver) {
    final Claims claims = extractAllClaims(token);
    return claimResolver.apply(claims);
}


A generic method that can extract any claim from token.

Uses claimResolver function to specify what to extract.

Example: Claims::getSubject → extracts the username.

7. extractAllClaims
private Claims extractAllClaims(String token) {
    return Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();
}


Parses the JWT token and verifies it with your secret key.

Returns all claims (data inside token).

8. validateToken
public boolean validateToken(String token, UserDetails userDetails) {
    final String username = extractUsername(token);
    return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
}


Checks if token is valid.

Valid if:

Username in token matches the logged-in username.

Token is not expired.

9. isTokenExpired
private boolean isTokenExpired(String token) {
    return extractExpiration(token).before(new Date());
}


Returns true if token expiry date is before the current date (expired).

10. extractExpiration
private Date extractExpiration(String token) {
    return extractClaim(token, Claims::getExpiration);
}


Gets expiration date from token.

11. extractUserId
public Long extractUserId(String token) {
    Claims claims = Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();

    return Long.parseLong(claims.get("userId").toString());
}


Reads userId claim from token.

12. extractRole
public UserRole extractRole(String token) {
    Claims claims = Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();

    String roleStr = claims.get("role", String.class);

    if (roleStr == null) {
        throw new RuntimeException("Role not found in the token");
    }

    try {
        return UserRole.valueOf(roleStr);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException("Invalid role value in token: " + roleStr, ex);
    }
}


Reads role from token.

Converts string → UserRole enum.

Throws exception if role missing or invalid.

13. refreshToken
public String refreshToken(String oldToken) {
    if (!validateToken(oldToken)) {
        throw new RuntimeException("Invalid token");
    }

    Claims claims = extractAllClaims(oldToken);
    return Jwts.builder()
            .claims(claims)
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60))
            .signWith(secretKey)
            .compact();
}


Refreshes a token (extends expiry).

Checks if old token is valid.

Copies all claims and signs a new token with extended expiration.

14. validateToken (private)
private boolean validateToken(String token) {
    try {
        extractAllClaims(token);
        return !isTokenExpired(token);
    } catch (Exception e) {
        return false;
    }
}


Checks if token is valid without user details.

Returns false if parsing fails or token expired.

✅ Summary:
This class generates, reads, validates, and refreshes JWT tokens.
But there are some bugs:

Secret key generation not assigned properly.

.claims().add(claims) is not correct syntax.

validateToken duplicate methods.

If you want, I can fix this entire JwtUtil class so it’s clean and runnable with proper syntax and key handling.

--------------------------------------------------------------------------------------
1. Class Declaration
@Service
public class MyUserDetailsService implements UserDetailsService {


@Service → Marks this as a Spring service class (business logic class).
Spring will automatically manage this class as a bean.

implements UserDetailsService → This tells Spring Security that this class will load user details (like username, password, roles) during login.

2. Inject User Repository
@Autowired
private UserRepository userRepo;


@Autowired → Spring automatically gives us the instance of UserRepository.

UserRepository → This is your interface for talking to the database and fetching user details.

💡 Think of it as:

"Spring, please give me the database access object to fetch users."

3. loadUserByUsername Method
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {


@Override → Means we are implementing a method from UserDetailsService.

Method name: loadUserByUsername → This is called by Spring Security during login.

Parameter: String username → Username entered during login.

Returns: UserDetails → An object containing user information (username, password, roles) for authentication.

4. Fetch User from Database
User user = userRepo.findByUsername(username).orElseThrow();


userRepo.findByUsername(username) → Fetches user from database using the username.

.orElseThrow() → If no user found, it throws an exception.

User → Your entity class representing the user table in DB.

⚠ Issue: The .orElseThrow() here doesn’t specify an exception, so it will throw NoSuchElementException by default.
Better approach:

.orElseThrow(() -> new UsernameNotFoundException("User not found"));

5. Check if User Exists
if(user == null) {
    throw new UsernameNotFoundException("user not found");
}


This is checking again if the user is null.

But it’s redundant, because .orElseThrow() already throws if the user is missing.

So this check can be removed.

6. Return UserDetails
return new UserPrinciple(user);


Returns a UserPrinciple object.

UserPrinciple → A custom class that implements UserDetails, containing:

Username

Password

Roles/Authorities

Other info required by Spring Security.

Spring Security will then use this UserPrinciple object to:

Check password during login.

Assign roles and permissions.

Full Explanation in Simple Words

This class basically tells Spring Security:

“Here’s how to load user details from the database for authentication.”

Process:

Spring calls loadUserByUsername(username) when someone tries to log in.

The method searches the database for the user using UserRepository.

If the user is not found, it throws an exception.

If found, it wraps the user in a UserPrinciple object (so Spring knows how to read username, password, and roles).

Spring then uses that info to check the password and allow login.

💡 Clean version of this code:

@Service
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepo;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepo.findByUsername(username)
                            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return new UserPrinciple(user);
    }
}

--------------------------------------------------------------------------------------


Code Explanation
@Service


This tells Spring that this class is a service component.

Spring will automatically create an object of this class and manage it (Dependency Injection).

public class MyUserDetailsService implements UserDetailsService {


We create a class named MyUserDetailsService.

It implements UserDetailsService, which is a Spring Security interface.

This interface requires us to define a method to load user details for authentication.

@Autowired
private UserRepository userRepo;


@Autowired tells Spring to inject the dependency automatically.

Here, userRepo is an object of UserRepository (used to interact with the database to fetch user info).

@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {


@Override means we are implementing a method from UserDetailsService.

loadUserByUsername is the method Spring Security uses when someone tries to log in.

It takes a username and returns user details needed for authentication.

It can throw UsernameNotFoundException if the user doesn’t exist.

User user = userRepo.findByUsername(username).orElseThrow();


This fetches the user from the database using the username.

findByUsername(username) is a method in UserRepository.

.orElseThrow() means: if the user is not found, throw an exception automatically.

⚡ Note: This line already handles the "user not found" case, so the next if check is redundant.

if(user == null) {
    throw new UsernameNotFoundException("user not found");
}


This checks again if the user is null and throws an exception.

But because .orElseThrow() is used above, this check will never actually run — it’s unnecessary.

return new UserPrinciple(user);


Returns a UserPrinciple object (which implements Spring Security’s UserDetails).

This object contains user information like username, password, and roles that Spring Security uses to authenticate and authorize the user.

----------------------------------------------------------------------------































