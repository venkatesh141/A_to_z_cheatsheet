@Configuration
public class CorsConfig {


👉 @Configuration tells Spring Boot: This class contains bean definitions (like settings/configurations) that Spring should manage.
Here, we’re making a configuration for CORS (Cross-Origin Resource Sharing).

@Bean
public CorsFilter corsFilter() {


👉 @Bean tells Spring: This method will create an object (bean) that should be used inside the application.
We are creating a CorsFilter bean here.
CorsFilter is a Spring filter that controls which domains can call your API.

CorsConfiguration config = new CorsConfiguration();


👉 This makes a new CORS configuration object where we will set rules (who is allowed, what methods are allowed, etc.).

config.setAllowedOrigins(Arrays.asList( "https://opticwave.in/", "https://www.opticwave.in/" ));


👉 This sets which websites are allowed to call your backend.
Here, only https://opticwave.in and https://www.opticwave.in are allowed.
⚠️ Note: You should not put a trailing / (like https://opticwave.in/) — keep it as https://opticwave.in.

config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));


👉 This tells: These HTTP methods are allowed from those websites.
Example: GET for reading, POST for creating, PUT for updating, DELETE for deleting, etc.

config.setAllowedHeaders(Arrays.asList("*"));


👉 This means: Allow all headers (like Authorization, Content-Type, etc.).
If you didn’t allow them, the browser might block some requests.

config.setAllowCredentials(true);


👉 This means: Allow credentials like cookies, tokens, or authorization headers.
If this is false, the frontend won’t be able to send cookies or Authorization headers.

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();


👉 This creates a CORS source object that maps URL paths (like /api/**) to the CORS configuration.

source.registerCorsConfiguration("/**", config);


👉 This means: Apply the above CORS rules to all API paths (/** means everything).
So, no matter which endpoint is called, these CORS rules apply.

return new CorsFilter(source);


👉 Finally, return a new CorsFilter with our rules.
Spring Boot will use this filter to check every request and block/allow based on the rules.

✅ In short:
This config says:

Only https://opticwave.in and https://www.opticwave.in can call your API.

They can use methods: GET, POST, PUT, DELETE, OPTIONS, PATCH.

They can send any headers.

They can send credentials (like cookies/auth).

This rule applies to all your APIs.
---------------------------------------------------------------------------------------------

@Component
public class DataInitializer implements CommandLineRunner {
👉 @Component tells Spring: This class should be automatically discovered and used by Spring.
👉 implements CommandLineRunner means: Run this class’s run() method automatically when the application starts.

java
Copy code
@Autowired
private UserRepository userRepository;
👉 This injects (@Autowired) the UserRepository so you can save and find users in the database.

java
Copy code
private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
👉 Creates a password encoder with strength 12.
This means when you save passwords, they’ll be encrypted (hashed) securely.
(You never save raw passwords in the database).

java
Copy code
@Override
public void run(String... args) throws Exception {
👉 This method runs automatically after Spring Boot starts.
Here you write code that should run at application startup (like inserting a default admin).

java
Copy code
String adminEmail = "admin@opticwave.com";
👉 Sets the email ID of the default super admin user.

java
Copy code
if (userRepository.findByEmail(adminEmail).isEmpty()) {
👉 Checks in the database: Is there already a user with this email?

If no such user → create one.

If user exists → don’t create again.

java
Copy code
User superAdmin = new User();
👉 Creates a new User object (super admin user).

java
Copy code
superAdmin.setUsername("superadmin");
superAdmin.setEmail(adminEmail);
superAdmin.setRole(UserRole.ROLE_ADMIN);
👉 Sets the user’s:

Username = superadmin

Email = admin@opticwave.com

Role = ROLE_ADMIN (so he has admin powers).

java
Copy code
superAdmin.setPassword(passwordEncoder.encode("Opticwave@superAdmin@May@2025"));
👉 Sets the password for this user, but not in plain text!
It encrypts it using BCryptPasswordEncoder before saving.
(Default password → should be changed in production).

java
Copy code
userRepository.save(superAdmin);
👉 Saves the new admin user into the database.

java
Copy code
System.out.println("✅ Super Admin initialized with email: " + adminEmail);
👉 Prints a message in the console saying a new super admin is created.

java
Copy code
} else {
    System.out.println("ℹ️ Super Admin already exists.");
}
👉 If an admin already exists, just print a message instead of creating a new one.

✅ In short:
This code runs when the app starts and ensures there’s always one super admin in the database. If it’s missing, it creates one with default credentials.

----------------------------------------------------------------------


Perfect 👍 Let’s go line by line through your PhonePeConfig class in very simple words.

@Configuration
public class PhonePeConfig {


👉 @Configuration tells Spring Boot:
This class contains beans (objects) that are configuration-related and should be managed by Spring.

Here, we are configuring PhonePe payment client.

@Value("${phonepe.client.id}")
private String clientId;  // e.g., "PGTESTMERCHANT123"


👉 @Value picks a value from your application.properties (or application.yml) file.
This line takes phonepe.client.id value from the properties file and stores it in clientId.
Example:

phonepe.client.id=PGTESTMERCHANT123

@Value("${phonepe.client.secret}")
private String clientSecret;  // MUST be base64 encoded string


👉 Gets phonepe.client.secret from properties and stores it in clientSecret.
⚠️ This should be a base64 encoded string (not plain text).

@Value("${phonepe.client.version}")
private Integer clientVersion; // Usually 1


👉 Reads phonepe.client.version from properties and stores it in clientVersion.
Usually, PhonePe API version is 1.

@Value("${phonepe.env}")
private String env;


👉 Reads phonepe.env from properties.
It tells if you are using PRODUCTION (real payments) or SANDBOX (test mode).

Example in properties:

phonepe.env=SANDBOX

@Bean
public StandardCheckoutClient standardCheckoutClient() {


👉 @Bean means: This method returns an object (bean) that Spring Boot should manage and make available everywhere in the app.
Here, we are creating a StandardCheckoutClient bean (used to talk to PhonePe API).

Env environment = "PRODUCTION".equalsIgnoreCase(env) ? Env.PRODUCTION : Env.SANDBOX;


👉 This line checks:

If env = "PRODUCTION" → use Env.PRODUCTION (real payments).

Otherwise → use Env.SANDBOX (test environment).

So it switches automatically based on what you set in application.properties.

return StandardCheckoutClient.getInstance(clientId, clientSecret, clientVersion, environment);


👉 Creates and returns a StandardCheckoutClient using the values we loaded (clientId, clientSecret, clientVersion, environment).
This is the actual PhonePe API client you’ll use for payments.

✅ In short:
This class configures a PhonePe client for your app.

Reads values (id, secret, version, env) from application.properties.

Decides whether to use Sandbox or Production.

Creates a StandardCheckoutClient bean you can inject (@Autowired) anywhere in your app to interact with PhonePe.

Do you also want me to write the example application.properties entries you need for this config?

-------------------------------------------------------------------------------------------------------
@Configuration
@EnableWebSecurity
public class SecurityConfig {
👉 @Configuration: This class is a configuration class managed by Spring.
👉 @EnableWebSecurity: Turns on Spring Security for your project.
This is where you define how authentication and authorization work.

java
Copy code
@Autowired
private UserDetailsService userDetailsService;
👉 Spring will inject your UserDetailsService.
This is used to load user details (like username, password, roles) from DB when someone logs in.

java
Copy code
@Autowired
private JwtFilter jwtFilter;
👉 Injects your custom JwtFilter.
This filter checks every request for a JWT token and validates it.

java
Copy code
@Bean
public WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring()
        .requestMatchers("/payment/callback");
}
👉 This says: Ignore security for the /payment/callback endpoint.
That means Spring Security won’t apply filters for that URL (needed because payment gateways call back without authentication).

java
Copy code
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
👉 Defines the main security rules for your app.
Spring Boot will use this to decide who can access which endpoints.

java
Copy code
return http.csrf(customizer -> customizer.disable())
👉 Disables CSRF protection (Cross-Site Request Forgery).
Usually disabled for APIs since JWT is used instead of sessions.

java
Copy code
.authorizeHttpRequests(request -> 
    request.requestMatchers("/auth/**").permitAll()
    .anyRequest().permitAll())
👉 Authorization rules:

Any request starting with /auth/** → allowed for everyone (login, signup, etc.).

.anyRequest().permitAll() → Right now, every other request is also open to everyone.
⚠️ Usually you would use .authenticated() here for secured APIs.

java
Copy code
.httpBasic(Customizer.withDefaults())
👉 Enables basic authentication (username & password in headers).
(Not used much when JWT is enabled, but it’s there as a fallback).

java
Copy code
.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
👉 Tells Spring Security: Don’t create sessions, we’re using JWT (stateless authentication).
So, every request must carry a token.

java
Copy code
.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
👉 Adds your custom jwtFilter before the normal UsernamePasswordAuthenticationFilter.
This makes sure JWT is checked before Spring processes login.

java
Copy code
.build();
👉 Builds the SecurityFilterChain with all rules.

java
Copy code
@Bean
public AuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setPasswordEncoder(new BCryptPasswordEncoder(12));
    provider.setUserDetailsService(userDetailsService);
    return provider;
}
👉 This sets up how authentication should happen:

Uses DaoAuthenticationProvider (checks users in DB).

Uses BCryptPasswordEncoder(12) for password hashing.

Uses your userDetailsService to load users from DB.

java
Copy code
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
}
👉 Exposes an AuthenticationManager bean.
This object is used by Spring to authenticate users with username + password.

java
Copy code
@Bean
public BCryptPasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
}
👉 Creates a reusable password encoder bean so you can inject it anywhere to encode/verify passwords.

✅ In short:

Ignores /payment/callback security.

/auth/** is open to everyone.

Everything else is currently also open (since .anyRequest().permitAll()).

JWT filter checks tokens before normal login filter.

Users are loaded from DB via UserDetailsService.

Passwords are securely stored with BCrypt.

App is stateless → no sessions, JWT only.




-----------------------------------------------------------------------------------------------------























