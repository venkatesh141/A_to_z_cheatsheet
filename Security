@Configuration
public class CorsConfig {


ðŸ‘‰ @Configuration tells Spring Boot: This class contains bean definitions (like settings/configurations) that Spring should manage.
Here, weâ€™re making a configuration for CORS (Cross-Origin Resource Sharing).

@Bean
public CorsFilter corsFilter() {


ðŸ‘‰ @Bean tells Spring: This method will create an object (bean) that should be used inside the application.
We are creating a CorsFilter bean here.
CorsFilter is a Spring filter that controls which domains can call your API.

CorsConfiguration config = new CorsConfiguration();


ðŸ‘‰ This makes a new CORS configuration object where we will set rules (who is allowed, what methods are allowed, etc.).

config.setAllowedOrigins(Arrays.asList( "https://opticwave.in/", "https://www.opticwave.in/" ));


ðŸ‘‰ This sets which websites are allowed to call your backend.
Here, only https://opticwave.in and https://www.opticwave.in are allowed.
âš ï¸ Note: You should not put a trailing / (like https://opticwave.in/) â€” keep it as https://opticwave.in.

config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));


ðŸ‘‰ This tells: These HTTP methods are allowed from those websites.
Example: GET for reading, POST for creating, PUT for updating, DELETE for deleting, etc.

config.setAllowedHeaders(Arrays.asList("*"));


ðŸ‘‰ This means: Allow all headers (like Authorization, Content-Type, etc.).
If you didnâ€™t allow them, the browser might block some requests.

config.setAllowCredentials(true);


ðŸ‘‰ This means: Allow credentials like cookies, tokens, or authorization headers.
If this is false, the frontend wonâ€™t be able to send cookies or Authorization headers.

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();


ðŸ‘‰ This creates a CORS source object that maps URL paths (like /api/**) to the CORS configuration.

source.registerCorsConfiguration("/**", config);


ðŸ‘‰ This means: Apply the above CORS rules to all API paths (/** means everything).
So, no matter which endpoint is called, these CORS rules apply.

return new CorsFilter(source);


ðŸ‘‰ Finally, return a new CorsFilter with our rules.
Spring Boot will use this filter to check every request and block/allow based on the rules.

âœ… In short:
This config says:

Only https://opticwave.in and https://www.opticwave.in can call your API.

They can use methods: GET, POST, PUT, DELETE, OPTIONS, PATCH.

They can send any headers.

They can send credentials (like cookies/auth).

This rule applies to all your APIs.
---------------------------------------------------------------------------------------------

@Component
public class DataInitializer implements CommandLineRunner {
ðŸ‘‰ @Component tells Spring: This class should be automatically discovered and used by Spring.
ðŸ‘‰ implements CommandLineRunner means: Run this classâ€™s run() method automatically when the application starts.

java
Copy code
@Autowired
private UserRepository userRepository;
ðŸ‘‰ This injects (@Autowired) the UserRepository so you can save and find users in the database.

java
Copy code
private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
ðŸ‘‰ Creates a password encoder with strength 12.
This means when you save passwords, theyâ€™ll be encrypted (hashed) securely.
(You never save raw passwords in the database).

java
Copy code
@Override
public void run(String... args) throws Exception {
ðŸ‘‰ This method runs automatically after Spring Boot starts.
Here you write code that should run at application startup (like inserting a default admin).

java
Copy code
String adminEmail = "admin@opticwave.com";
ðŸ‘‰ Sets the email ID of the default super admin user.

java
Copy code
if (userRepository.findByEmail(adminEmail).isEmpty()) {
ðŸ‘‰ Checks in the database: Is there already a user with this email?

If no such user â†’ create one.

If user exists â†’ donâ€™t create again.

java
Copy code
User superAdmin = new User();
ðŸ‘‰ Creates a new User object (super admin user).

java
Copy code
superAdmin.setUsername("superadmin");
superAdmin.setEmail(adminEmail);
superAdmin.setRole(UserRole.ROLE_ADMIN);
ðŸ‘‰ Sets the userâ€™s:

Username = superadmin

Email = admin@opticwave.com

Role = ROLE_ADMIN (so he has admin powers).

java
Copy code
superAdmin.setPassword(passwordEncoder.encode("Opticwave@superAdmin@May@2025"));
ðŸ‘‰ Sets the password for this user, but not in plain text!
It encrypts it using BCryptPasswordEncoder before saving.
(Default password â†’ should be changed in production).

java
Copy code
userRepository.save(superAdmin);
ðŸ‘‰ Saves the new admin user into the database.

java
Copy code
System.out.println("âœ… Super Admin initialized with email: " + adminEmail);
ðŸ‘‰ Prints a message in the console saying a new super admin is created.

java
Copy code
} else {
    System.out.println("â„¹ï¸ Super Admin already exists.");
}
ðŸ‘‰ If an admin already exists, just print a message instead of creating a new one.

âœ… In short:
This code runs when the app starts and ensures thereâ€™s always one super admin in the database. If itâ€™s missing, it creates one with default credentials.

----------------------------------------------------------------------


Perfect ðŸ‘ Letâ€™s go line by line through your PhonePeConfig class in very simple words.

@Configuration
public class PhonePeConfig {


ðŸ‘‰ @Configuration tells Spring Boot:
This class contains beans (objects) that are configuration-related and should be managed by Spring.

Here, we are configuring PhonePe payment client.

@Value("${phonepe.client.id}")
private String clientId;  // e.g., "PGTESTMERCHANT123"


ðŸ‘‰ @Value picks a value from your application.properties (or application.yml) file.
This line takes phonepe.client.id value from the properties file and stores it in clientId.
Example:

phonepe.client.id=PGTESTMERCHANT123

@Value("${phonepe.client.secret}")
private String clientSecret;  // MUST be base64 encoded string


ðŸ‘‰ Gets phonepe.client.secret from properties and stores it in clientSecret.
âš ï¸ This should be a base64 encoded string (not plain text).

@Value("${phonepe.client.version}")
private Integer clientVersion; // Usually 1


ðŸ‘‰ Reads phonepe.client.version from properties and stores it in clientVersion.
Usually, PhonePe API version is 1.

@Value("${phonepe.env}")
private String env;


ðŸ‘‰ Reads phonepe.env from properties.
It tells if you are using PRODUCTION (real payments) or SANDBOX (test mode).

Example in properties:

phonepe.env=SANDBOX

@Bean
public StandardCheckoutClient standardCheckoutClient() {


ðŸ‘‰ @Bean means: This method returns an object (bean) that Spring Boot should manage and make available everywhere in the app.
Here, we are creating a StandardCheckoutClient bean (used to talk to PhonePe API).

Env environment = "PRODUCTION".equalsIgnoreCase(env) ? Env.PRODUCTION : Env.SANDBOX;


ðŸ‘‰ This line checks:

If env = "PRODUCTION" â†’ use Env.PRODUCTION (real payments).

Otherwise â†’ use Env.SANDBOX (test environment).

So it switches automatically based on what you set in application.properties.

return StandardCheckoutClient.getInstance(clientId, clientSecret, clientVersion, environment);


ðŸ‘‰ Creates and returns a StandardCheckoutClient using the values we loaded (clientId, clientSecret, clientVersion, environment).
This is the actual PhonePe API client youâ€™ll use for payments.

âœ… In short:
This class configures a PhonePe client for your app.

Reads values (id, secret, version, env) from application.properties.

Decides whether to use Sandbox or Production.

Creates a StandardCheckoutClient bean you can inject (@Autowired) anywhere in your app to interact with PhonePe.

Do you also want me to write the example application.properties entries you need for this config?

-------------------------------------------------------------------------------------------------------



@Configuration
@EnableWebSecurity
public class SecurityConfig {
	
	@Autowired
	private UserDetailsService userDetailsService;
	
	@Autowired
	private JwtFilter jwtFilter;
	
	@Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (web) -> web.ignoring()
            .requestMatchers("/payment/callback");
    }
	
	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		return http.csrf(customizer -> customizer.disable())
			.authorizeHttpRequests(request -> 
			request.requestMatchers("/auth/**").permitAll()
			.anyRequest().permitAll())
			.httpBasic(Customizer.withDefaults())
			.sessionManagement(session -> session
					.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
			.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
			.build();
	}
	
	@Bean
	public AuthenticationProvider authenticationProvider() {
		DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
		provider.setPasswordEncoder(new BCryptPasswordEncoder(12));
		provider.setUserDetailsService(userDetailsService);
		return provider;
	}
	
	@Bean
	public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
		return config.getAuthenticationManager();
	}

	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder(12);
	}

}

-----------------------------------------------------------------------------------------------------























