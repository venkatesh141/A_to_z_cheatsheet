@Configuration
public class CorsConfig {


👉 @Configuration tells Spring Boot: This class contains bean definitions (like settings/configurations) that Spring should manage.
Here, we’re making a configuration for CORS (Cross-Origin Resource Sharing).

@Bean
public CorsFilter corsFilter() {


👉 @Bean tells Spring: This method will create an object (bean) that should be used inside the application.
We are creating a CorsFilter bean here.
CorsFilter is a Spring filter that controls which domains can call your API.

CorsConfiguration config = new CorsConfiguration();


👉 This makes a new CORS configuration object where we will set rules (who is allowed, what methods are allowed, etc.).

config.setAllowedOrigins(Arrays.asList( "https://opticwave.in/", "https://www.opticwave.in/" ));


👉 This sets which websites are allowed to call your backend.
Here, only https://opticwave.in and https://www.opticwave.in are allowed.
⚠️ Note: You should not put a trailing / (like https://opticwave.in/) — keep it as https://opticwave.in.

config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));


👉 This tells: These HTTP methods are allowed from those websites.
Example: GET for reading, POST for creating, PUT for updating, DELETE for deleting, etc.

config.setAllowedHeaders(Arrays.asList("*"));


👉 This means: Allow all headers (like Authorization, Content-Type, etc.).
If you didn’t allow them, the browser might block some requests.

config.setAllowCredentials(true);


👉 This means: Allow credentials like cookies, tokens, or authorization headers.
If this is false, the frontend won’t be able to send cookies or Authorization headers.

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();


👉 This creates a CORS source object that maps URL paths (like /api/**) to the CORS configuration.

source.registerCorsConfiguration("/**", config);


👉 This means: Apply the above CORS rules to all API paths (/** means everything).
So, no matter which endpoint is called, these CORS rules apply.

return new CorsFilter(source);


👉 Finally, return a new CorsFilter with our rules.
Spring Boot will use this filter to check every request and block/allow based on the rules.

✅ In short:
This config says:

Only https://opticwave.in and https://www.opticwave.in can call your API.

They can use methods: GET, POST, PUT, DELETE, OPTIONS, PATCH.

They can send any headers.

They can send credentials (like cookies/auth).

This rule applies to all your APIs.
---------------------------------------------------------------------------------------------

@Component
public class DataInitializer implements CommandLineRunner {
👉 @Component tells Spring: This class should be automatically discovered and used by Spring.
👉 implements CommandLineRunner means: Run this class’s run() method automatically when the application starts.

java
Copy code
@Autowired
private UserRepository userRepository;
👉 This injects (@Autowired) the UserRepository so you can save and find users in the database.

java
Copy code
private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);
👉 Creates a password encoder with strength 12.
This means when you save passwords, they’ll be encrypted (hashed) securely.
(You never save raw passwords in the database).

java
Copy code
@Override
public void run(String... args) throws Exception {
👉 This method runs automatically after Spring Boot starts.
Here you write code that should run at application startup (like inserting a default admin).

java
Copy code
String adminEmail = "admin@opticwave.com";
👉 Sets the email ID of the default super admin user.

java
Copy code
if (userRepository.findByEmail(adminEmail).isEmpty()) {
👉 Checks in the database: Is there already a user with this email?

If no such user → create one.

If user exists → don’t create again.

java
Copy code
User superAdmin = new User();
👉 Creates a new User object (super admin user).

java
Copy code
superAdmin.setUsername("superadmin");
superAdmin.setEmail(adminEmail);
superAdmin.setRole(UserRole.ROLE_ADMIN);
👉 Sets the user’s:

Username = superadmin

Email = admin@opticwave.com

Role = ROLE_ADMIN (so he has admin powers).

java
Copy code
superAdmin.setPassword(passwordEncoder.encode("Opticwave@superAdmin@May@2025"));
👉 Sets the password for this user, but not in plain text!
It encrypts it using BCryptPasswordEncoder before saving.
(Default password → should be changed in production).

java
Copy code
userRepository.save(superAdmin);
👉 Saves the new admin user into the database.

java
Copy code
System.out.println("✅ Super Admin initialized with email: " + adminEmail);
👉 Prints a message in the console saying a new super admin is created.

java
Copy code
} else {
    System.out.println("ℹ️ Super Admin already exists.");
}
👉 If an admin already exists, just print a message instead of creating a new one.

✅ In short:
This code runs when the app starts and ensures there’s always one super admin in the database. If it’s missing, it creates one with default credentials.

----------------------------------------------------------------------


Perfect 👍 Let’s go line by line through your PhonePeConfig class in very simple words.

@Configuration
public class PhonePeConfig {


👉 @Configuration tells Spring Boot:
This class contains beans (objects) that are configuration-related and should be managed by Spring.

Here, we are configuring PhonePe payment client.

@Value("${phonepe.client.id}")
private String clientId;  // e.g., "PGTESTMERCHANT123"


👉 @Value picks a value from your application.properties (or application.yml) file.
This line takes phonepe.client.id value from the properties file and stores it in clientId.
Example:

phonepe.client.id=PGTESTMERCHANT123

@Value("${phonepe.client.secret}")
private String clientSecret;  // MUST be base64 encoded string


👉 Gets phonepe.client.secret from properties and stores it in clientSecret.
⚠️ This should be a base64 encoded string (not plain text).

@Value("${phonepe.client.version}")
private Integer clientVersion; // Usually 1


👉 Reads phonepe.client.version from properties and stores it in clientVersion.
Usually, PhonePe API version is 1.

@Value("${phonepe.env}")
private String env;


👉 Reads phonepe.env from properties.
It tells if you are using PRODUCTION (real payments) or SANDBOX (test mode).

Example in properties:

phonepe.env=SANDBOX

@Bean
public StandardCheckoutClient standardCheckoutClient() {


👉 @Bean means: This method returns an object (bean) that Spring Boot should manage and make available everywhere in the app.
Here, we are creating a StandardCheckoutClient bean (used to talk to PhonePe API).

Env environment = "PRODUCTION".equalsIgnoreCase(env) ? Env.PRODUCTION : Env.SANDBOX;


👉 This line checks:

If env = "PRODUCTION" → use Env.PRODUCTION (real payments).

Otherwise → use Env.SANDBOX (test environment).

So it switches automatically based on what you set in application.properties.

return StandardCheckoutClient.getInstance(clientId, clientSecret, clientVersion, environment);


👉 Creates and returns a StandardCheckoutClient using the values we loaded (clientId, clientSecret, clientVersion, environment).
This is the actual PhonePe API client you’ll use for payments.

✅ In short:
This class configures a PhonePe client for your app.

Reads values (id, secret, version, env) from application.properties.

Decides whether to use Sandbox or Production.

Creates a StandardCheckoutClient bean you can inject (@Autowired) anywhere in your app to interact with PhonePe.

Do you also want me to write the example application.properties entries you need for this config?

-------------------------------------------------------------------------------------------------------
@Configuration
@EnableWebSecurity
public class SecurityConfig {
👉 @Configuration: This class is a configuration class managed by Spring.
👉 @EnableWebSecurity: Turns on Spring Security for your project.
This is where you define how authentication and authorization work.

java
Copy code
@Autowired
private UserDetailsService userDetailsService;
👉 Spring will inject your UserDetailsService.
This is used to load user details (like username, password, roles) from DB when someone logs in.

java
Copy code
@Autowired
private JwtFilter jwtFilter;
👉 Injects your custom JwtFilter.
This filter checks every request for a JWT token and validates it.

java
Copy code
@Bean
public WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring()
        .requestMatchers("/payment/callback");
}
👉 This says: Ignore security for the /payment/callback endpoint.
That means Spring Security won’t apply filters for that URL (needed because payment gateways call back without authentication).

java
Copy code
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
👉 Defines the main security rules for your app.
Spring Boot will use this to decide who can access which endpoints.

java
Copy code
return http.csrf(customizer -> customizer.disable())
👉 Disables CSRF protection (Cross-Site Request Forgery).
Usually disabled for APIs since JWT is used instead of sessions.

java
Copy code
.authorizeHttpRequests(request -> 
    request.requestMatchers("/auth/**").permitAll()
    .anyRequest().permitAll())
👉 Authorization rules:

Any request starting with /auth/** → allowed for everyone (login, signup, etc.).

.anyRequest().permitAll() → Right now, every other request is also open to everyone.
⚠️ Usually you would use .authenticated() here for secured APIs.

java
Copy code
.httpBasic(Customizer.withDefaults())
👉 Enables basic authentication (username & password in headers).
(Not used much when JWT is enabled, but it’s there as a fallback).

java
Copy code
.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
👉 Tells Spring Security: Don’t create sessions, we’re using JWT (stateless authentication).
So, every request must carry a token.

java
Copy code
.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
👉 Adds your custom jwtFilter before the normal UsernamePasswordAuthenticationFilter.
This makes sure JWT is checked before Spring processes login.

java
Copy code
.build();
👉 Builds the SecurityFilterChain with all rules.

java
Copy code
@Bean
public AuthenticationProvider authenticationProvider() {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setPasswordEncoder(new BCryptPasswordEncoder(12));
    provider.setUserDetailsService(userDetailsService);
    return provider;
}
👉 This sets up how authentication should happen:

Uses DaoAuthenticationProvider (checks users in DB).

Uses BCryptPasswordEncoder(12) for password hashing.

Uses your userDetailsService to load users from DB.

java
Copy code
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
}
👉 Exposes an AuthenticationManager bean.
This object is used by Spring to authenticate users with username + password.

java
Copy code
@Bean
public BCryptPasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
}
👉 Creates a reusable password encoder bean so you can inject it anywhere to encode/verify passwords.

✅ In short:

Ignores /payment/callback security.

/auth/** is open to everyone.

Everything else is currently also open (since .anyRequest().permitAll()).

JWT filter checks tokens before normal login filter.

Users are loaded from DB via UserDetailsService.

Passwords are securely stored with BCrypt.

App is stateless → no sessions, JWT only.




-----------------------------------------------------------------------------------------------------

@Component
public class JwtFilter extends OncePerRequestFilter {
@Component: tells Spring to create and manage an instance of this class automatically (so it can be injected elsewhere).

public class JwtFilter extends OncePerRequestFilter: this defines a filter that runs once for every HTTP request. OncePerRequestFilter ensures the filter logic runs exactly one time per request.

java
Copy code
    @Autowired
    private JwtUtil jwtService;
@Autowired injects an instance of JwtUtil (your helper that extracts/validates data from JWTs).

jwtService will be used to read username from token and validate tokens.

java
Copy code
    @Autowired
    ApplicationContext context;
This injects the Spring ApplicationContext. You later use it to fetch the MyUserDetailsService bean dynamically (instead of directly @Autowireding the service). This is a way to get beans at runtime.

java
Copy code
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
doFilterInternal is the method that runs for each incoming HTTP request.

You receive the request, response, and filterChain so you can inspect the request and either block it or pass it along (filterChain.doFilter(...)).

java
Copy code
        String uri = request.getRequestURI();
        String method = request.getMethod();
Read and store the request path (e.g., /products/123) in uri.

Read and store the HTTP method (GET/POST/PUT/DELETE) in method.

You use these to decide whether the request needs JWT checks or can be allowed freely.

java
Copy code
        // Logging the request URI and method
        System.out.println("Request URI: " + uri + " Method: " + method);
Simple console log of the request path and method. Useful for debugging to see incoming requests. (Note: in production, prefer a logger instead of System.out.println.)

java
Copy code
        if (request.getRequestURI().startsWith("/payment/")) {
            filterChain.doFilter(request, response);  // Skip JWT processing
            return;
        }
If the request path begins with /payment/, skip all JWT checks and continue the filter chain.

This is common when payment callbacks come from external services and you must allow them through unauthenticated.

java
Copy code
        // Skip auth/cart endpoints
        if (uri.startsWith("/auth/") || uri.startsWith("/cart/") || uri.startsWith("/products/filter")) {
            filterChain.doFilter(request, response);
            return;
        }
If the path starts with /auth/, /cart/, or /products/filter, the filter does not enforce JWT and just forwards request on.

Typical: /auth/** contains login/signup endpoints that must be public.

java
Copy code
        // Publicly accessible GET endpoints
        if (method.equals("GET") && (
                uri.equals("/slides") ||
                uri.equals("/products") ||
                uri.startsWith("/products/all") ||
                ...
                uri.equals("/cart")
        )) {
            filterChain.doFilter(request, response);
            return;
        }
This big if permits certain GET requests without authentication.

It checks many GET endpoints (slides, product lists, categories, colors, coupons, search, etc.) and if the current request matches one of them, the filter allows it to continue without token checks.

Notice use of equals for exact matches and startsWith for prefix patterns (e.g., /products/123).

After filterChain.doFilter(...) the method returns — meaning no JWT validation for those endpoints.

java
Copy code
        // JWT Validation
        String authHeader = request.getHeader("Authorization");
        String username = null;
        String token = null;
Now we begin JWT processing.

Read the Authorization header into authHeader.

Prepare username and token variables (will fill them if a Bearer token is present).

java
Copy code
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
            username = jwtService.extractUsername(token);
        }
If the Authorization header exists and starts with Bearer :

Remove the "Bearer " prefix (substring(7)) to get the raw token.

Ask jwtService to extract the username (or subject) embedded in the token.

If header is missing or not Bearer-type, both token and username remain null.

java
Copy code
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
Proceed only if we extracted a username and there is no existing authentication in the security context.

This prevents re-authenticating if someone already set authentication earlier.

java
Copy code
            UserDetails userDetails = context.getBean(MyUserDetailsService.class).loadUserByUsername(username);
Use ApplicationContext to get your MyUserDetailsService bean, then call loadUserByUsername(username) to get the UserDetails object (contains password hash and authorities).

You need UserDetails so you can validate the token against the user's data (for example to check if the token was issued for this user or if user is still active).

java
Copy code
            if (jwtService.validateToken(token, userDetails)) {
Ask jwtService to validate the token (signature, expiry, and optionally checks against userDetails).

If validation passes, we will create a Spring Authentication object and set it in the context.

java
Copy code
                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
Create an Authentication object representing the authenticated user:

Principal = userDetails

Credentials = null (we don't keep raw password here)

Authorities = user's roles/permissions

java
Copy code
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
Add extra details (like remote address, session id) to the auth token. This is optional but common so downstream code can access request-specific info from the authentication object.

java
Copy code
                SecurityContextHolder.getContext().setAuthentication(authToken);
Put the newly created authentication into Spring Security’s SecurityContext.

From now on (for the rest of this request processing) SecurityContextHolder.getContext().getAuthentication() will return this authenticated user — so controllers and security checks will see the user as logged-in.

java
Copy code
            }
        }
Ends the token validation and authentication-setting block.

java
Copy code
        filterChain.doFilter(request, response);
    }
Continue the filter chain for the request (either unauthenticated or now authenticated).

This call passes control to the next filter or ultimately to the controller that will handle the request.

java
Copy code
}
End of class.

Quick summary (very short)
This filter inspects every incoming request.

It logs URI+method.

It skips JWT checks for certain public paths (/payment/*, /auth/*, some cart/product endpoints, and many public GET endpoints).

For other requests it looks for a Bearer <token> header, extracts username, loads user details, validates token, and if valid sets authentication into Spring Security so the app treats the request as authenticated. Then it continues the chain.

Small helpful notes / possible improvements
Use a logger (org.slf4j.Logger) instead of System.out.println.

Be careful with trailing slashes (e.g., "/orders/" vs "/orders"); inconsistent slashes can cause unexpected behavior. Consider normalizing uri or using more robust path matching (Ant matchers or ServletPathMatcher).

Instead of calling context.getBean(...) every time, you could @Autowired your MyUserDetailsService directly unless you have a specific reason to get it from context.

For large sets of public URLs, consider centralizing rules in security config or use patterns to avoid a very long if condition.

If you want, I can:

show a cleaned-up version of this filter with improvements, or

convert the long public-GET list to a reusable helper so the code is easier to read.

-----------------------------------------------------------------------------------------------
































