A_to_z_coding_cheat_sheet


patterns  -->
   
-----------------------trust the process you will win.
Input Format: N = 6  ques 1
Result:   
1          1
12        21
12       321
1234    4321
12345  54321
123456654321


solution

    
static void pattern(int n)
{
	int spaces = 2*(n-1);

	for(int i=1;i<=n;i++)
	{

		for(int j=1;j<=i;j++)
		{
			System.out.print(j);
		}
        for(int j=1;j<=spaces;j++)
        {
        	System.out.print(" ");
        } 

        for(int j=i;j>=1;j--)
        {
        	System.out.print(j);
        }
        System.out.println();
        spaces-=2;

	}
}
end
-----------------------trust the process you will definitely win.

  int n=6   ques 2

     A     
    ABA    
   ABCBA   
  ABCDCBA  
 ABCDEDCBA 
ABCDEFEDCBA
    
solution

public static void pattern(int n)
{
	for(int i=0;i<n;i++)
		{
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}

			char ch='A';
			int breakpoint = (2*i+1)/2;
			for(int j=1;j<=2*i+1;j++)
			{
				System.out.print(ch);
				if(j<=breakpoint)
					ch++;
				else
					ch--;
			}
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}
			System.out.println();

		}
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6   ques 3
Result:   
************
*****  *****
****    ****
***      ***
**        **
*          *
*          *
**        **
***      ***
****    ****
*****  *****
************


public static void pat(int n)
{
    int spaces=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        spaces+=2;
        System.out.println();
    }
    spaces = 2*n-2;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        spaces-=2;
        System.out.println();
    }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 3 ques 4
Result: 
*    *
**  **
******
**  **
*    *

public static void pattern(int n)
{
int spaces = 2*n-2;
      
      // Outer loop for printing row.
      for(int i = 1;i<=2*n-1;i++){
          
          // stars for first half
          int stars = i;
          
          // stars for the second half.
          if(i>n) stars = 2*n - i;
          
          //for printing the stars
          for(int j=1;j<=stars;j++){
              System.out.print("*");
          }
          
          //for printing the spaces
          for(int j = 1;j<=spaces;j++){
              System.out.print(" ");
          }
          
          //for printing the stars
          for(int j = 1;j<=stars;j++){
              System.out.print("*");
          }
          
          // As soon as the stars for each iteration are printed, we move to the
          // next row and give a line break otherwise all stars
          // would get printed in 1 line.
          System.out.println();
          if(i<n) spaces -=2;
          else spaces +=2;
      }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6 ques 5
Result:   
******
*    *
*    *
*    *
*    *
******

public static void fun(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 || j==0 || i==n-1 || j==n-1)
            {
                System.out.print("*");
            }
            else
            {
                System.out.print(" ");
            }
            
        }
        System.out..println();
    }
}
end
----------------------trust the process you will definitely win

Input Format: N = 3 ques 6
Result: 
3 3 3 3 3 
3 2 2 2 3 
3 2 1 2 3 
3 2 2 2 3 
3 3 3 3 3

static void pattern22(int n)
{
      
      for(int i=0;i<2*n-1;i++){
         for(int j=0;j<2*n-1;j++){
             
             
             int top = i;
             int bottom = j;
             int right = (2*n - 2) - j;
             int left = (2*n - 2) - i;
             System.out.print(n- Math.min(Math.min(top,bottom), Math.min(left,right)) + " ");
         }
           System.out.println();
     }
}
end
----------------------trust the process you will definitely win
 square root of a number optimized approach ques 7

public static int floor(int n)
{
    int res=1,i=1;
    while(res<=n)
    {
        i++;
        res=i*i;
    }
    return i-1;
}
end
----------------------trust the process you will definitely win
ques 8

 find missing number
 int ans=0;
      int n=nums.length;
        int sum=(n*(n+1))/2;
        for(int i=0;i<n;i++)
        {
            ans+=nums[i];
        }
        return sum-ans;
    end
----------------------trust the process you will definitely win
question 9

  sort colors
  
  st=0,mid=0,end=n-1;
  if(n==1)->return;
  while(mid<=end)
  {
     if(arr[mid]==2)
     {
           swap(arr[mid],arr[end])
           end--;
     }
     else if(arr[mid]==0)
     {
          swap(arr[mid],arr[st])
          st++;
          mid++;
     }
     else
     {
         mid++;
     }  
  }
  end

----------------------trust the process you will definitely win
question 10
check if two arrays are equal are not
public static boolean check(int[] arr1, int[] arr2) {
        // Your code here
        int n1=arr1.length;
        int n2=arr2.length;
        if(n1!=n2)
          return false;
         for(int i=0;i<n1;i++)
         {
             for(int j=0;j<n2;j++)
             {
                 if(arr2[j]==Integer.MIN_VALUE)
                 continue;
                 
                 if(arr1[i]==arr2[j])
                 {
                     arr2[j]=Integer.MIN_VALUE;
                     break;
                 }
             }
         }
         for(int i=0;i<n2;i++)
         {
             if(arr2[i]!=Integer.MIN_VALUE)
               return false;
         }
         return true;
         
    }
end
----------------------trust the process you will definitely win
question 11 merge sort 

   public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Base case: array is already sorted if it has one or zero elements
        }
        
        int mid = array.length / 2;
        int[] left = new int[mid];
        int[] right = new int[array.length - mid];
        System.arraycopy(array, 0, left, 0, mid);
        System.arraycopy(array, mid, right, 0, array.length - mid);
        mergeSort(left);
        mergeSort(right);
        merge(array, left, right);
    }
    
   
    private static void merge(int[] array, int[] left, int[] right) {
        int leftIndex = 0, rightIndex = 0, arrayIndex = 0;
        
   
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] <= right[rightIndex]) {
                array[arrayIndex++] = left[leftIndex++];
            } else {
                array[arrayIndex++] = right[rightIndex++];
            }
        }
        
   
        while (leftIndex < left.length) {
            array[arrayIndex++] = left[leftIndex++];
        }
        
   
        while (rightIndex < right.length) {
            array[arrayIndex++] = right[rightIndex++];
        }
    }
end
----------------------trust the process you will definitely win
question 12 bubble sort

    private static void bubbleSortRecursive(int[] array, int n) {
        
        if (n == 1) {
            return;
        }
        
        
        for (int i = 0; i < n - 1; i++) {
            if (array[i] > array[i + 1]) {
                // Swap the elements if they are in the wrong order
                int temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        
        
        bubbleSortRecursive(array, n - 1);
    }
end
----------------------trust the process you will definitely win
qusstion 13 insertion sort 

 public static void recursiveInsertionSort(int[] arr, int n) {
        // Base case: If the array has only one element, it's already sorted
        if (n <= 1) {
            return;
        }

        // Sort the first n-1 elements
        recursiveInsertionSort(arr, n - 1);

        // Insert the nth element into its correct position
        int last = arr[n - 1];
        int j = n - 2;

        // Move elements that are greater than the last element one position ahead
        while (j >= 0 && arr[j] > last) {
            arr[j + 1] = arr[j];
            j--;
        }

        // Insert the last element at its correct position
        arr[j + 1] = last;
    }
----------------------trust the process you will definitely win
Implementation of linked list question 14

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

        public void append(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            return;
        }

        Node last = head;
        while (last.next != null) {
            last = last.next;
        }

        last.next = newNode;
    }

    // Method to display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        linkedList.append(1);
        linkedList.append(2);
        linkedList.append(3);

        System.out.print("Linked List: ");
        linkedList.display();
    }
}
----------------------trust the process you will definitely win
stack implementation question 15

public class Stack {
     int maxSize; 
     int[] stackArray;
     int top; 

    
    public Stack(int maxSize) {
        this.maxSize = maxSize;
        this.stackArray = new int[maxSize];
        this.top = -1; // Stack is initially empty
    }

    
    public void push(int element) {
        if (isFull()) {
            System.out.println("Stack overflow! Cannot push element " + element);
            return;
        }
        top++;
        stackArray[top] = element;
    }

    
    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack underflow! Cannot pop element");
            return -1; 
        }
        int poppedElement = stackArray[top];
        top--;
        return poppedElement;
    }

    
    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty! Cannot peek");
            return -1; 
        }
        return stackArray[top];
    }

    
    public boolean isEmpty() {
        return top == -1;
    }

    
    public boolean isFull() {
        return top == maxSize - 1;
    }

    
    public static void main(String[] args) {
        Stack stack = new Stack(5); 
        stack.push(10);   
        System.out.println("Popped element: " + stack.pop());
        System.out.println("Top element of the stack: " + stack.peek());
        while (!stack.isEmpty()) {
            System.out.println("Popped element: " + stack.pop());
        }
    }
}

----------------------trust the process you will definitely win
