A_to_z_coding_cheat_sheet


patterns  -->
   
-----------------------trust the process you will win. brute force pannale optimize pannirlam
Input Format: N = 6  ques 1
Result:   
1          1
12        21
123      321
1234    4321
12345  54321
123456654321


solution

    
static void pattern(int n)
{
	int spaces = 2*(n-1);

	for(int i=1;i<=n;i++)
	{

		for(int j=1;j<=i;j++)
		{
			System.out.print(j);
		}
        for(int j=1;j<=spaces;j++)
        {
        	System.out.print(" ");
        } 

        for(int j=i;j>=1;j--)
        {
        	System.out.print(j);
        }
        System.out.println();
        spaces-=2;

	}
}
end
-----------------------trust the process you will win. brute force pannale optimize pannirlam

  int n=6   ques 2

     A     
    ABA    
   ABCBA   
  ABCDCBA  
 ABCDEDCBA 
ABCDEFEDCBA
    
solution

public static void pattern(int n)
{
	for(int i=0;i<n;i++)
		{
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}

			char ch='A';
			int breakpoint = (2*i+1)/2;
			for(int j=1;j<=2*i+1;j++)
			{
				System.out.print(ch);
				if(j<=breakpoint)
					ch++;
				else
					ch--;
			}
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}
			System.out.println();

		}
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
Input Format: N = 6   ques 3
Result:   
************
*****  *****
****    ****
***      ***
**        **
*          *
*          *
**        **
***      ***
****    ****
*****  *****
************


public static void pat(int n)
{
    int spaces=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        spaces+=2;
        System.out.println();
    }
    spaces = 2*n-2;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        spaces-=2;
        System.out.println();
    }
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
Input Format: N = 3 ques 4
Result: 
*    *
**  **
******
**  **
*    *

public static void pattern(int n)
{
int spaces = 2*n-2;
      
      // Outer loop for printing row.
      for(int i = 1;i<=2*n-1;i++){
          
          // stars for first half
          int stars = i;
          
          // stars for the second half.
          if(i>n) stars = 2*n - i;
          
          //for printing the stars
          for(int j=1;j<=stars;j++){
              System.out.print("*");
          }
          
          //for printing the spaces
          for(int j = 1;j<=spaces;j++){
              System.out.print(" ");
          }
          
          //for printing the stars
          for(int j = 1;j<=stars;j++){
              System.out.print("*");
          }
          
          // As soon as the stars for each iteration are printed, we move to the
          // next row and give a line break otherwise all stars
          // would get printed in 1 line.
          System.out.println();
          if(i<n) spaces -=2;
          else spaces +=2;
      }
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
Input Format: N = 6 ques 5
Result:   
******
*    *
*    *
*    *
*    *
******

public static void fun(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 || j==0 || i==n-1 || j==n-1)
            {
                System.out.print("*");
            }
            else
            {
                System.out.print(" ");
            }
            
        }
        System.out..println();
    }
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam

Input Format: N = 3 ques 6
Result: 
3 3 3 3 3 
3 2 2 2 3 
3 2 1 2 3 
3 2 2 2 3 
3 3 3 3 3

static void pattern22(int n)
{
      
      for(int i=0;i<2*n-1;i++){
         for(int j=0;j<2*n-1;j++){
             
             
             int top = i;
             int bottom = j;
             int right = (2*n - 2) - j;
             int left = (2*n - 2) - i;
             System.out.print(n- Math.min(Math.min(top,bottom), Math.min(left,right)) + " ");
         }
           System.out.println();
     }
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
 square root of a number optimized approach ques 7

public static int floor(int n)
{
    int res=1,i=1;
    while(res<=n)
    {
        i++;
        res=i*i;
    }
    return i-1;
}
end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
ques 8

 find missing number
 int ans=0;
      int n=nums.length;
        int sum=(n*(n+1))/2;
        for(int i=0;i<n;i++)
        {
            ans+=nums[i];
        }
        return sum-ans;
    end

-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 9

  sort colors
  
  st=0,mid=0,end=n-1;
  if(n==1)->return;
  while(mid<=end)
  {
     if(arr[mid]==2)
     {
           swap(arr[mid],arr[end])
           end--;
     }
     else if(arr[mid]==0)
     {
          swap(arr[mid],arr[st])
          st++;
          mid++;
     }
     else
     {
         mid++;
     }  
  }
  end


-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 10
check if two arrays are equal are not
public static boolean check(int[] arr1, int[] arr2) {
        // Your code here
        int n1=arr1.length;
        int n2=arr2.length;
        if(n1!=n2)
          return false;
         for(int i=0;i<n1;i++)
         {
             for(int j=0;j<n2;j++)
             {
                 if(arr2[j]==Integer.MIN_VALUE)
                 continue;
                 
                 if(arr1[i]==arr2[j])
                 {
                     arr2[j]=Integer.MIN_VALUE;
                     break;
                 }
             }
         }
         for(int i=0;i<n2;i++)
         {
             if(arr2[i]!=Integer.MIN_VALUE)
               return false;
         }
         return true;
         
    }
end
----------------------trust the process you will definitely win
question 11 merge sort 

   public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Base case: array is already sorted if it has one or zero elements
        }
        
        int mid = array.length / 2;
        int[] left = new int[mid];
        int[] right = new int[array.length - mid];
        System.arraycopy(array, 0, left, 0, mid);
        System.arraycopy(array, mid, right, 0, array.length - mid);
        mergeSort(left);
        mergeSort(right);
        merge(array, left, right);
    }
    
   
    private static void merge(int[] array, int[] left, int[] right) {
        int leftIndex = 0, rightIndex = 0, arrayIndex = 0;
        
   
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] <= right[rightIndex]) {
                array[arrayIndex++] = left[leftIndex++];
            } else {
                array[arrayIndex++] = right[rightIndex++];
            }
        }
        
   
        while (leftIndex < left.length) {
            array[arrayIndex++] = left[leftIndex++];
        }
        
   
        while (rightIndex < right.length) {
            array[arrayIndex++] = right[rightIndex++];
        }
    }
end
----------------------trust the process you will definitely win
question 12 bubble sort

    private static void bubbleSortRecursive(int[] array, int n) {
        
        if (n == 1) {
            return;
        }
        
        
        for (int i = 0; i < n - 1; i++) {
            if (array[i] > array[i + 1]) {
                // Swap the elements if they are in the wrong order
                int temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        
        
        bubbleSortRecursive(array, n - 1);
    }
end
----------------------trust the process you will definitely win
qusstion 13 insertion sort 

 public static void insertionSort(int[] arr, int n) {
        if (n <= 1) {
            return;
        }

        // Insert the nth element into its correct position first (out of order)
        int last = arr[n - 1];
        int j = n - 2;

        while (j >= 0 && arr[j] > last) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = last;

        // Recursively sort the first n-1 elements (after insertion, which is incorrect)
        insertionSort(arr, n - 1);
    }
----------------------trust the process you will definitely win
Implementation of linked list question 14

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

        public void append(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            return;
        }

        Node last = head;
        while (last.next != null) {
            last = last.next;
        }

        last.next = newNode;
    }

    public void delete(int ele)
    {
        if(head!=null && head.data==ele)
         {
             head=head.next;
             return;
         }
         Node current=head;
         Node previous=null;
         while(current!=null && current.data!=ele)
         {
           previous=current;
           current=current.next;
          }
          if(current==null)
          {
             System.out.pritnln("element is not found");
             return;
          }
          previous.next=current.next;
         
    }

    // Method to display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        linkedList.append(1);
        linkedList.append(2);
        linkedList.append(3);

        System.out.print("Linked List: ");
        linkedList.display();
    }
}
----------------------trust the process you will definitely win
stack implementation question 15

public class Stack {
     int maxSize; 
     int[] stackArray;
     int top; 

    
    public Stack(int maxSize) {
        this.maxSize = maxSize;
        this.stackArray = new int[maxSize];
        this.top = -1; // Stack is initially empty
    }

    
    public void push(int element) {
        if (isFull()) {
            System.out.println("Stack overflow! Cannot push element " + element);
            return;
        }
        top++;
        stackArray[top] = element;
    }

    
    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack underflow! Cannot pop element");
            return -1; 
        }
        int poppedElement = stackArray[top];
        top--;
        return poppedElement;
    }

    
    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty! Cannot peek");
            return -1; 
        }
        return stackArray[top];
    }

    
    public boolean isEmpty() {
        return top == -1;
    }

    
    public boolean isFull() {
        return top == maxSize - 1;
    }

    
    public static void main(String[] args) {
        Stack stack = new Stack(5); 
        stack.push(10);   
        System.out.println("Popped element: " + stack.pop());
        System.out.println("Top element of the stack: " + stack.peek());
        while (!stack.isEmpty()) {
            System.out.println("Popped element: " + stack.pop());
        }
    }
}

----------------------trust the process you will definitely win
queue implementation question 16

public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // Constructor
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }

    // Enqueue: Add an element to the end of the queue
    public void enqueue(int data) {
        if (isFull()) {
            throw new RuntimeException("Queue is full");
        }
        rear = (rear + 1) % capacity;
        queue[rear] = data;
        size++;
    }

    // Dequeue: Remove and return the element from the front of the queue
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        int data = queue[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }

    // Peek: Return the front element without removing it
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        return queue[front];
    }

    // Check if the queue is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Check if the queue is full
    public boolean isFull() {
        return size == capacity;
    }

    // Get the size of the queue
    public int size() {
        return size;
    }

    // Display the queue
    public void display() {
        System.out.print("Queue: ");
        for (int i = 0; i < size; i++) {
            System.out.print(queue[(front + i) % capacity] + " ");
        }
        System.out.println();
    }
}


to traverse queue

    while (!queue.isEmpty()) {
            System.out.println("Dequeued element: " + queue.dequeue());
        }
----------------------trust the process you will definitely win
binary tree implementation question 17
class Node {
    int data;
    Node left, right;

    // Constructor to create a new node
    public Node(int item) {
        data = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    // Constructor
    BinaryTree() {
        root = null;
    }

    // Function to add nodes in a level-order manner
    public void add(int data) {
        root = addRecursively(root, data);
    }

    // Recursive function to add nodes
    private Node addRecursively(Node current, int data) {
        // If tree is empty, create a root node
        if (current == null) {
            return new Node(data);
        }

        // Insert nodes based on availability of left or right child
        if (current.left == null) {
            current.left = addRecursively(current.left, data);
        } else {
            current.right = addRecursively(current.right, data);
        }

        return current;
    }

    // In-order traversal (left, root, right)
    public void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.data + " ");
            inOrderTraversal(node.right);
        }
    }

    // Pre-order traversal (root, left, right)
    public void preOrderTraversal(Node node) {
        if (node != null) {
            System.out.print(node.data + " ");
            preOrderTraversal(node.left);
            preOrderTraversal(node.right);
        }
    }

    // Post-order traversal (left, right, root)
    public void postOrderTraversal(Node node) {
        if (node != null) {
            postOrderTraversal(node.left);
            postOrderTraversal(node.right);
            System.out.print(node.data + " ");
        }
    }
}
public class Main {
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        // Adding nodes in a binary tree fashion (not binary search tree)
        tree.add(1);  // Root
        tree.add(2);  // Left child of root
        tree.add(3);  // Right child of root
        tree.add(4);  // Left child of node 2
        tree.add(5);  // Right child of node 2

        System.out.println("In-order traversal:");
        tree.inOrderTraversal(tree.root);  // Output: 4 2 5 1 3 

        System.out.println("\nPre-order traversal:");
        tree.preOrderTraversal(tree.root);  // Output: 1 2 4 5 3 

        System.out.println("\nPost-order traversal:");
        tree.postOrderTraversal(tree.root);  // Output: 4 5 2 3 1
    }
}


----------------------trust the process you will definitely win
question 18 

selection sort
    static void selectionSort(int[] arr, int n, int index) {
        // Base case: If index is at the last element
        if (index == n)
            return;

        // Find the minimum element in the unsorted part of the array
        int minIndex = index;
        for (int i = index + 1; i < n; i++) {
            if (arr[i] < arr[minIndex]) {
                minIndex = i;
            }
        }

        // Swap the found minimum element with the current element at index
        int temp = arr[minIndex];
        arr[minIndex] = arr[index];
        arr[index] = temp;

        // Recursively call selectionSort for the next index
        selectionSort(arr, n, index + 1);
    }

----------------------trust the process you will definitely win
question 19 sum of first n natural nos

    static int func(int n){
        
            // Base Condition.
            if(n == 0){
                
                return 0;
            }
            
            // Problem broken down into 2 parts and then combined.
            return n + func(n-1);
            
----------------------trust the process you will definitely win
question 20 factorial of a number 

int factorial(n)
{
   if(n == 0)
   {
     return 1;
   }

return n * factorial(n-1);
}
----------------------trust the process you will definitely win
question 21 print fib series of a number
 static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    // Function to print the Fibonacci series up to the nth term
    static void printFibonacciSeries(int n) {
        for (int i = 0; i < n; i++) {
            System.out.print(fibonacci(i) + " ");
        }
    }
----------------------trust the process you will definitely win
question 22
Frequencies of Limited Range Array Elements
Input: n = 5, arr[] = [2, 3, 2, 3, 5], p = 5
Output: [0, 2, 2, 0, 1] 

    public static void frequencyCount(int arr[], int n, int p) {
        // do modify in the given array
        int[] temp=new int[n+1];
        
        for(int i=0;i<n;i++)
        {
            if(arr[i]>p)
            temp[i]=0;
            if(arr[i]<=p && arr[i]<=n)
            {
                temp[arr[i]]++;
            }
        }
        for(int i=0;i<n;i++)
        {
            arr[i]=temp[i+1];//hashed array that is y we are using i+1 
        }
        
    }
----------------------trust the process you will definitely win
question 23    /hard
public int maxFrequency(int[] nums, int k) {
    // Variable to store the maximum frequency of an element
    int max = 0;

    // To track the total sum of the elements within the current window (between left and right)
    long total = 0;

    // Sorting the array so that we can try to make elements the same by adding 'k'
    Arrays.sort(nums);

    // Initializing two pointers for the sliding window: right and left
    int right = 0, left = 0;

    // Iterate through the array with the right pointer
    for (right = 0; right < nums.length; right++) {
        // Add the current element to the total sum
        total += nums[right];

        // Check if the current window [left, right] can be made equal to nums[right]
        // We check if the total value of all elements in the window after adding 'k' operations
        // is greater than or equal to making every element in the window equal to nums[right]
        // If not, shrink the window from the left
        while ((long) nums[right] * (right - left + 1) > total + k) {
            // Remove the leftmost element from the total sum
            total -= nums[left];
            // Move the left pointer to shrink the window
            left++;
        }

        // Update the maximum frequency found so far
        max = Math.max(max, right - left + 1);
    }

    // Return the maximum frequency
    return max;
}

----------------------trust the process you will definitely win
question 24 quick sort

    Choose a Pivot: Typically, the rightmost element of the array (arr[high]) is selected as the pivot.

    Partitioning:
        The partition() function is used to arrange elements such that:
            Elements smaller than or equal to the pivot are on the left.
            Elements greater than the pivot are on the right.
        The pivot element is placed in its correct sorted position, with smaller elements to its left and larger elements to its right.
        It returns the index of the pivot element.

    Recursive Sorting:
        After partitioning, the array is divided into two sub-arrays:
            Left sub-array (elements before the pivot)
            Right sub-array (elements after the pivot)
        The quickSort() function is then recursively called on both sub-arrays until each sub-array has fewer than two elements.


public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Find the pivot element such that
            // elements smaller than pivot are on the left
            // elements greater than pivot are on the right
            int pivotIndex = partition(arr, low, high);

            // Recursively sort the left and right subarrays
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // Partition method to place the pivot element at its correct position
    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // Choose the rightmost element as pivot
        int i = (low - 1); // Index of smaller element

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;

                // Swap arr[i] and arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // Swap arr[i+1] with arr[high] (pivot)
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }
----------------------trust the process you will definitely win
question 25
second largest element
public static void second_largest(int[] arr)
{
	int n=arr.length;
	int first=Integer.MIN_VALUE,second=Integer.MIN_VALUE:

	for(int i=0;i<n;i++)
	{
		if(arr[i]>first)
		{
			second=first;
			first=arr[i];
		}
		else if(arr[i]>second && arr[i]<first)
		{
			second=arr[i];
		}
	}
	System.out.println(second);
}
----------------------trust the process you will definitely win
question 26
check if array is sorted or not
static boolean isSorted(int arr[], int n) {
    for (int i = 1; i < n; i++) {
      if (arr[i] < arr[i - 1])
        return false;
    }

    return true;
  }
----------------------trust the process you will definitely win
question 27
linear search 
int search(int arr[],int n,int num)
{
    int i;
    for(i=0;i<n;i++)
    {
        if(arr[i]==num)
        return i;
    }
    return -1;
}
----------------------trust the process you will definitely win
question 28 
Remove Duplicates from sorted array

    static int removeDuplicates(int[] arr) {
        int i = 0;
        for (int j = 1; j < arr.length; j++) {
            if (arr[i] != arr[j]) {
                i++;
                arr[i] = arr[j];
            }
        }
        return i + 1;//return just index that up to this index have only non duplicate

    }

----------------------trust the process you will definitely win
question 29
set matrix zeros leetcode 73
row length ku oru array , col length ku oru array create paniko
matrix ah traverse panni
  if mat[i][j]==0
  row[i]=1,col[j]=1
  set pannu
  
 again matrix ah traverse panni
     if(row[i]==1 or col[j]==1)
     mat[i][j]=0
     set pannu
     
     end
----------------------trust the process you will definitely win
question 30
kadane's algo max subarray
  leetcode 53
  sum=0,max=Integer.minvalue set panniko
  array ah traverse pannu
     {
     sum+=arr[i];
     if(sum>max)->max=sum
     if(sum<0)->sum=0
     }
return max
    end
----------------------trust the process you will definitely win
question 31
leetcode 121
 best time to buy and sell stock

 profit =0,besttime=arr[0];
 traverse array from index 1 to n
 {
   if(besttime>arr[i])
     besttime=arr[i];
    if(profit<(arr[i]-besttime))
    profit=arr[i]-besttime
}
return profit
----------------------trust the process you will definitely win
question 32
rotate 90 deg
leetcode 48
class Solution {
    public void rotate(int[][] mat) {

     int n=mat.length;
     for(int i=0;i<n;i++)
     {
         for(int j=i;j<n;j++)
         {
             int t=mat[i][j];
             mat[i][j]=mat[j][i];
             mat[j][i]=t;
         }
     }   
     for(int i=0;i<n;i++)
     {
         for(int j=0;j<n/2;j++)
         {
             int t=mat[i][n-j-1];
             mat[i][n-j-1]=mat[i][j];
             mat[i][j]=t;
         }
     }
    }
}
----------------------trust the process you will definitely win
question 33
leetcode 189
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
class Solution {
    public void rotate(int[] nums, int k) {
        
        k = k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public void reverse(int[] arr,int s,int e)
    {
        while(s<=e)
        {
            int t=arr[s];
            arr[s]=arr[e];
            arr[e]=t;
            s++;
            e--;
        }
    }
}
----------------------trust the process you will definitely win
question 34 
Move zeros to end leetcode 283
class Solution {
    public void moveZeroes(int[] arr) {
        int n=arr.length;
        int j=-1,i;
        for(i=0;i<n;i++)
        {
            if(arr[i]==0)
            {
                j=i;
                break;
            }
        }
        if(j==-1)
        return;
        for(i=j+1;i<n;i++)
        {
            if(arr[i]!=0)
            {
                int t=arr[i];
                arr[i]=arr[j];
                arr[j]=t;
                j++;
            }
        }

    }

}
 
----------------------trust the process you will definitely win
question 35
Union of two arrays
static ArrayList<Integer> FindUnion(int arr1[], int arr2[], int n, int m) {
   int i = 0, j = 0; // pointers
  ArrayList<Integer > Union=new ArrayList<>(); // Uninon vector
  while (i < n && j < m) {
    if (arr1[i] <= arr2[j]) // Case 1 and 2
    {
      if (Union.size() == 0 || Union.get(Union.size()-1) != arr1[i])
        Union.add(arr1[i]);
      i++;
    } else // case 3
    {
      if (Union.size() == 0 || Union.get(Union.size()-1) != arr2[j])
        Union.add(arr2[j]);
      j++;
    }
  }
  while (i < n) // IF any element left in arr1
  {
    if (Union.get(Union.size()-1) != arr1[i])
      Union.add(arr1[i]);
    i++;
  }
  while (j < m) // If any elements left in arr2
  {
    if (Union.get(Union.size()-1) != arr2[j])
      Union.add(arr2[j]);
    j++;
  }
  return Union;
}
----------------------trust the process you will definitely win
question 36
leetcode 485. Max Consecutive Ones
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        
        int count=0,max=0;
        int n=nums.length;
        for(int i=0;i<n;i++)
        {
            if(nums[i]==1)
              count++;
            else
               count=0;
        max=Math.max(count,max);
        }
        return max;
    }
    
}
----------------------trust the process you will definitely win
question 37
leetcode 136. Single Number
class Solution {
    public int singleNumber(int[] nums) {
        int xor_value=0;
        int n=nums.length;
        for(int i=0;i<n;i++)
        {
            xor_value ^=nums[i];
        }
        return xor_value;
    }
}
----------------------trust the process you will definitely win
question 38    
get length of longest subarray with given sum // for positives values only
 public static int getLongestSubarray(int []a, long k) {
        int n = a.length; // size of the array.

        int left = 0, right = 0; // 2 pointers
        long sum = a[0];
        int maxLen = 0;
        while (right < n) {
            // if sum > k, reduce the subarray from left
            // until sum becomes less or equal to k:
            while (left <= right && sum > k) {
                sum -= a[left];
                left++;
            }

            // if sum = k, update the maxLen i.e. answer:
            if (sum == k) {
                maxLen = Math.max(maxLen, right - left + 1);
            }

            // Move forward thw right pointer:
            right++;
            if (right < n) sum += a[right];
        }

        return maxLen;
    }
----------------------trust the process you will definitely win
question 39
2 sum leetcode 1
   public static String twoSum(int n, int []arr, int target) {
        HashMap<Integer, Integer> mpp = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int num = arr[i];
            int moreNeeded = target - num;
            if (mpp.containsKey(moreNeeded)) {
                return "YES";
            }

            mpp.put(arr[i], i);
        }
        return "NO";
    }
----------------------trust the process you will definitely win
question 40
leetcode 169
Mooreâ€™s Voting Algorithm
class Solution {
    public int majorityElement(int[] nums) {
        //more than n/2 times
        int count=0;
        int candidate=0;
       for(int element : nums)
       {
         if(count==0)
          candidate=element;
         if(candidate==element)
          count++;
         else
           count--;
       }
     return candidate;
    }
}
----------------------trust the process you will definitely win
question 41
get length of longest subarray with given sum // for positives and negative values only
public static int getLongestSubarray(int []a, int k) {
        int n = a.length; // size of the array.

        int len = 0;
        for (int i = 0; i < n; i++) { // starting index
            int s = 0;
            for (int j = i; j < n; j++) { // ending index
                // add the current element to
                // the subarray a[i...j-1]:
                s += a[j];

                if (s == k)
                    len = Math.max(len, j - i + 1);
            }
        }
        return len;
    }
----------------------trust the process you will definitely win
question 42
leetcode 287 (question 6)
find duplicate O(n)
frequency array onu create panniko
freq[]
traverse the org arry
    if(freq[arr[i]]==0)
      freq[arr[i]]++;
     else
     return arr[i];
     end of loop
     return -1
     end
----------------------trust the process you will definitely win
question 43 pos no first neg no second ...  relative order should not change
leetcode 2149. Rearrange Array Elements by Sign
public int[] rearrangeArray(int[] nums) {
        
        int n = nums.length;
        int res[]=new int[n];
        int pos=0,neg=1;
        for(int i=0;i<n;i++)
        {
            if(nums[i]>=0)
            {
                res[pos]=nums[i];
                pos+=2;
            }
            else
            {
                res[neg]=nums[i];
                neg+=2;
            }
            
        }
     	return res;
}
----------------------trust the process you will definitely win
question 44
leetcode 31 
next permutation
 declare ind1=-1,ind2=-1;
   for(int i=n-2;i>=0;i--)
   {
       if(arr[i]<arr[i+1])
      {
        ind1=i;break;  
      }
   }
   if(ind1==-1)
   reverse(arr,0)-->0 is starting index
   else
   {
    for(int i=n-1;i>ind1;i--)
    {
      if(arr[i]>arr[ind1])
      {
        ind2=i;break;
      }
    }
    swap(arr,ind1,ind2);---passing index swaps based on position
    reverse(arr,ind1+1);
   }
   end
----------------------trust the process you will definitely win
question 45
leetcode 118   pascal triangle
int n=5;
 int dp[][]=new int[n][n];
for(int i=0;i<n;i++)
{
   for(int j=0;j<=i;j++)
   {
       if(j==0 || j==i)
        dp[i][j]=1;
       else
         dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
   }
}

 end
with out using arrays

public class PascalTriangle {
    public static void main(String[] args) {
        int n = 5; // Number of rows for Pascal's Triangle
        
        // Iterate through each row
        for (int i = 0; i < n; i++) {
            int value = 1; // The first value in each row is always 1
            System.out.print(value + " "); // Print the first value
            
            // Compute and print the rest of the values in the row
            for (int j = 1; j <= i; j++) {
                value = value * (i - j + 1) / j; // Binomial coefficient calculation
                System.out.print(value + " "); // Print values in the same row
            }
            
            System.out.println(); // Newline after each row
        }
    }
}

----------------------trust the process you will definitely win
question 46
leaders in an array 
public static ArrayList<Integer> 
                     printLeadersBruteForce(int[] arr, int n){
    
  ArrayList<Integer> ans= new ArrayList<>();
   int max = arr[n - 1];
    ans.add(arr[n-1]);
     for (int i = n - 2; i >= 0; i--)
      if (arr[i] > max) {
        ans.add(arr[i]);
        max = arr[i];
      }

  return ans;
}
----------------------trust the process you will definitely win
question 47
 find repeating and missing number

int n = a.length; 
        int[] hash = new int[n + 1]; 

        
        for (int i = 0; i < n; i++) {
            hash[a[i]]++;
        }

        
        int repeating = -1, missing = -1;
        for (int i = 1; i <= n; i++) {
            if (hash[i] == 2) repeating = i;
            else if (hash[i] == 0) missing = i;

            if (repeating != -1 && missing != -1)
                break;
        }
        int[] ans = {repeating, missing};
        return ans;
----------------------trust the process you will definitely win
question 48
leetcode 128. Longest Consecutive Sequence
class Solution {
    public int longestConsecutive(int[] nums) {
        
        if(nums.length==0)
        return 0;
        Arrays.sort(nums);
        int max=-1;
        int count=0;
        for(int i=1;i<nums.length;i++)
        {
            if(nums[i-1]==nums[i])
            continue;
            else if(nums[i]-nums[i-1]==1)
            count++;
            else
            {
                if(count>max)
                {
                    max=count;
                }
                count=0;
            }
        }
        if(count>max)
        max=count;

        return max+1;

    }
}
----------------------trust the process you will definitely win
question 49
 leetcode 88 
merge two sorted array 
      class Solution {
    public void merge(int[] nums1, int n1, int[] nums2, int n2) {
        
        int p1=n1-1;//nums1 size is n+m
        int p2=n2-1;
        int curr=n1+n2-1;
        
        while(p2>=0)
        {
            if(p1>=0 && nums1[p1]>nums2[p2])
            {
                nums1[curr--] = nums1[p1--];

            }
            else
            {
                nums1[curr--] = nums2[p2--];
            }
        }
    }
}
----------------------trust the process you will definitely win
question 50
binary search tree implementation
// Node class to represent a node in the tree
class Node {
    int data;
    Node left, right;

    public Node(int data) {
        this.data = data;
        left = right = null;
    }
}

// Binary Search Tree class
class BinarySearchTree {
    Node root;

    // Constructor
    BinarySearchTree() {
        root = null;
    }

    // This method calls the recursive insert method
    void insert(int data) {
        root = insertRec(root, data);
    }

    // A recursive function to insert a new key in the BST
    Node insertRec(Node root, int data) {
        // If the tree is empty, return a new node
        if (root == null) {
            root = new Node(data);
            return root;
        }

        // Otherwise, recur down the tree
        if (data < root.data)
            root.left = insertRec(root.left, data);
        else 
            root.right = insertRec(root.right, data);

        // Return the (unchanged) node pointer
        return root;
    }

    // This method calls the recursive search method
    boolean search(int data) {
        return searchRec(root, data);
    }

    // A recursive function to search a key in the BST
    boolean searchRec(Node root, int data) {
        // Base Cases: root is null or key is present at root
        if (root == null)
            return false;
        if (root.data == data)
            return true;

        // Key is greater than root's key
        if (root.data < data)
            return searchRec(root.right, data);

        // Key is smaller than root's key
        return searchRec(root.left, data);
    }

    public static void main(String[] args) {
        BinarySearchTree tree = new BinarySearchTree();

        // Insert nodes into the tree
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // Search for a key in the BST
        int data = 40;
        if (tree.search(data))
            System.out.println("Key " + key + " found in the tree.");
        else
            System.out.println("Key " + key + " not found in the tree.");
    }
}
----------------------trust the process you will definitely win
question 51
binary search
public static int search(int a[],int target,int l,int r)
    {
       if(l<=r)
       {
          int mid=(l+r)/2;
          if(a[mid]==target)
          {
            return mid;
          }
          else if(a[mid]<target)
          {
            l=mid+1;
            search(a,target,l,r);
          }
          else
          {
            r=mid-1;
            search(a,target,l,r);
          }
        }
        return -1;
    }
----------------------trust the process you will definitely win
question 52
leetcode 62
        unique path 

         int[][] dp=new int[m][n];
         
         for(int i=0;i<m;i++)
         {
             dp[i][0]=1;
         }
         for(int j=0;j<n;j++)
         {
             dp[0][j]=1;
         }
         for(int i=1;i<m;i++)
         {
             for(int j=1;j<n;j++)
             {
                 dp[i][j]=dp[i-1][j]+dp[i][j-1];
             }
         }
         return dp[m-1][n-1];       
         end
----------------------trust the process you will definitely win
question 53
leetcode 54
   public List<Integer> spiralOrder(int[][] mat) {
        List<Integer> ans = new ArrayList<>();
        int n = mat.length; 
        int m = mat[0].length; 
        int top = 0, left = 0, bottom = n - 1, right = m - 1;   
        while (top <= bottom && left <= right) {
                       
            for (int i = left; i <= right; i++)
                ans.add(mat[top][i]);

            top++;
  
            for (int i = top; i <= bottom; i++)
                ans.add(mat[i][right]);

            right--;

            // For moving right to left.
            if (top <= bottom) {
                for (int i = right; i >= left; i--)
                    ans.add(mat[bottom][i]);

                bottom--;
            }

            // For moving bottom to top.
            if (left <= right) {
                for (int i = bottom; i >= top; i--)
                    ans.add(mat[i][left]);

                left++;
            }
        }
        return ans;

        
    }
----------------------trust the process you will definitely win
question 54
leetcode 229 Majority Element-II 

public List<Integer> majorityElement(int[] v) {
        
        int n = v.length; //size of the array

        int cnt1 = 0, cnt2 = 0; // counts
        int el1 = Integer.MIN_VALUE; // element 1
        int el2 = Integer.MIN_VALUE; // element 2

      
        for (int i = 0; i < n; i++) {
            if (cnt1 == 0 && el2 != v[i]) {
                cnt1 = 1;
                el1 = v[i];
            } else if (cnt2 == 0 && el1 != v[i]) {
                cnt2 = 1;
                el2 = v[i];
            } else if (v[i] == el1) cnt1++;
            else if (v[i] == el2) cnt2++;
            else {
                cnt1--; cnt2--;
            }
        }

        List<Integer> ls = new ArrayList<>(); 
        cnt1 = 0; cnt2 = 0;
        for (int i = 0; i < n; i++) {
            if (v[i] == el1) cnt1++;
            if (v[i] == el2) cnt2++;
        }

        int mini = (int)(n / 3) + 1;
        if (cnt1 >= mini) ls.add(el1);
        if (cnt2 >= mini) ls.add(el2);

        
        return ls;

    }
----------------------trust the process you will definitely win
question 55
leetcode 15
    public List<List<Integer>> threeSum(int[] arr) {
         
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(arr);
        int n=arr.length;

        for (int i = 0; i < n; i++) {
            //remove duplicates:
            if (i != 0 && arr[i] == arr[i - 1]) continue;

            //moving 2 pointers:
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                int sum = arr[i] + arr[j] + arr[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    List<Integer> temp = Arrays.asList(arr[i], arr[j], arr[k]);
                    ans.add(temp);
                    j++;
                    k--;
                    //skip the duplicates:
                    while (j < k && arr[j] == arr[j - 1]) j++;
                    while (j < k && arr[k] == arr[k + 1]) k--;
                }
            }
        }

        return ans;
    }
----------------------trust the process you will definitely win
question 56
leetcode 18
    public List<List<Integer>> fourSum(int[] arr, int target) {

        List<List<Integer>> ans = new ArrayList<>();
        int n = arr.length;
        Arrays.sort(arr);
        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && arr[i - 1] == arr[i]) continue;

            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && arr[j - 1] == arr[j]) continue;

                int k = j + 1;
                int l = n - 1;

                while (k < l) {
                    long sum = arr[i] + arr[j];
                    sum += arr[k] + arr[l];

                    if (sum == target) {
                        ans.add(Arrays.asList(arr[i], arr[j], arr[k], arr[l]));
                        k++;
                        l--;
                        while (k < l && arr[k - 1] == arr[k]) k++;
                        while (k < l && arr[l + 1] == arr[l]) l--;
                    } else if (sum < target) {
                        k++;
                    } else {
                        l--;
                    }
                }
            }
        }

        return ans;
        
    }
----------------------trust the process you will definitely win
question 57
Subarray with given XOR(Interview Bit)
 public static int subarraysWithXorK(int []a, int k) {
        int n = a.length; //size of the given array.
        int cnt = 0;

        // Step 1: Generating subarrays:
        for (int i = 0; i < n; i++) {
            int xorr = 0;
            for (int j = i; j < n; j++) {

                //step 2:calculate XOR of all
                // elements:
                xorr = xorr ^ a[j];

                // step 3:check XOR and count:
                if (xorr == k) cnt++;
            }
        }
        return cnt;
    }

----------------------trust the process you will definitely win
question 58
leetcode 56 merge intervals 

public int[][] merge(int[][] intervals) {

        List<int[]> res = new ArrayList<>();
         if(intervals.length==0)
         {
           return res.toArray(new int[0][]);
         }

         Arrays.sort(intervals,(a,b)->a[0]-b[0]);
          
          int start = intervals[0][0];
          int end = intervals[0][1];
          
          for(int[] i : intervals)
          {
            if(i[0]<=end)
            {
              end=Math.max(end,i[1]);
            }
            else
            {
              res.add(new int[]{start,end});
              start = i[0];
              end = i[1];
            }
          }
          res.add(new int[]{start,end});
          return res.toArray(new int[0][]);
    }
----------------------trust the process you will definitely win
question 59

public static int numberOfInversions(int[] a, int n) {
        // Count the number of pairs:
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (a[i] > a[j]) cnt++;
            }
        }
        return cnt;
    }
----------------------trust the process you will definitely win
question 60
leetcode 152
public int maxProduct(int[] arr) {
        int prod1 = arr[0],prod2 = arr[0],result = arr[0];
    
    for(int i=1;i<arr.length;i++) {
        int temp = Math.max(arr[i],Math.max(prod1*arr[i],prod2*arr[i]));
        prod2 = Math.min(arr[i],Math.min(prod1*arr[i],prod2*arr[i]));
        prod1 = temp;
        
        result = Math.max(result,prod1);
    }
    
    return result;
    }
----------------------trust the process you will definitely win
question 61
reverse pairs
 public static int countPairs(int[] a, int n) {

        // Count the number of pairs:
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (a[i] > 2 * a[j])
                    cnt++;
            }
        }
        return cnt;
    }
----------------------trust the process you will definitely win

question 62 (needs to be completed by some other problem)
public class CircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // Constructor to initialize the queue
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = -1;
        rear = -1;
        size = 0;
    }

    // Check if the queue is full
    public boolean isFull() {
        return size == capacity;
    }

    // Check if the queue is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Add an element to the queue
    public boolean enqueue(int value) {
        if (isFull()) {
            System.out.println("Queue is full");
            return false;
        }
        
        if (isEmpty()) {
            front = 0;
        }
        
        rear = (rear + 1) % capacity;
        queue[rear] = value;
        size++;
        return true;
    }

    // Remove an element from the queue
    public int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        
        int result = queue[front];
        front = (front + 1) % capacity;
        size--;
        
        // Reset the queue when it becomes empty
        if (isEmpty()) {
            front = -1;
            rear = -1;
        }
        
        return result;
    }

    // Peek at the front element of the queue without removing it
    public int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        return queue[front];
    }

    // Display the queue elements
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }

        System.out.print("Queue: ");
        for (int i = 0; i < size; i++) {
            System.out.print(queue[(front + i) % capacity] + " ");
        }
        System.out.println();
    }

}

----------------------trust the process you will definitely win
question 63 coding ninjas
binary search based problem so array should be sorted
You are given an array 'arr' sorted in non-decreasing order and a number 'x'. You must return the index of the lower bound of 'x'.
Input Format:
 N = 5, arr[] = {3,5,8,15,19}, x = 9
Result:
 3
Explanation:
 Index 3 is the smallest index such that arr[3] >= x.

public static int lowerBound(int []arr, int n, int x) {
        // Write your code here
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
----------------------trust the process you will definitely win
question 64 leetcode 35 
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
binary search based problem so array should be sorted
public int searchInsert(int[] arr, int x) {

      int n = arr.length; // size of the array
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;   
    }
----------------------trust the process you will definitely win
question 65 
find floor and ceil

The floor of x is the largest element in the array which is smaller than or equal to x.
The ceiling of x is the smallest element in the array greater than or equal to x.

Input Format: n = 6, arr[] ={3, 4, 4, 7, 8, 10}, x= 5
Result: 4 7
Explanation: The floor of 5 in the array is 4, and the ceiling of 5 in the array is 7.
binary search based problem so array should be sorted

 static int findFloor(int[] arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] <= x) {
                ans = arr[mid];
                //look for smaller index on the left
                low = mid + 1;
            } else {
                high = mid - 1; // look on the right
            }
        }
        return ans;
    }

    static int findCeil(int[] arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = arr[mid];
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
----------------------trust the process you will definitely win
question 66
leetcode 34. Find First and Last Position of Element in Sorted Array
binary search based problem so array should be sorted
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int res[]={-1,-1};
        int left=helper(nums,target,true);
        int right=helper(nums,target,false);
        res[0]=left;
        res[1]=right;
        return res;
    }
    public int helper(int[] arr,int target,boolean isSearchingLeft)
    {
        int left=0,right=arr.length-1,ind=-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(arr[mid]>target)
            {
                right=mid-1;
            }
            else if(arr[mid]<target)
            {
                left=mid+1;
            }
            else
            {
                idx=mid;
                if(isSearchingLeft)
                {
                    right=mid-1;

                }
                else
                {
                    left=mid+1;
                }
            }
        }
        return ind;


    }
}
----------------------trust the process you will definitely win
question 67(gfg)
binary search based problem so array should be sorted
Number of occurrence(using bs)
class Solution {
    int count(int[] arr, int n, int x) {
        // code here
       int[] res=new int[2];
       res[0]=res[1]=-1;
       int left=bs(arr,x,true);
       int right=bs(arr,x,false);
       if(left==-1)
       return 0;
       return (right-left+1);
    }
    int bs(int[] arr,int x,boolean isSearchingLeft)
    {
        int left=0,right=arr.length-1,ind=-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(arr[mid]<x)
            {
                left=mid+1;
            }
            else if(arr[mid]>x)
            {
                right=mid-1;
            }
            else
            {
                ind=mid;
                if(isSearchingLeft)
                {
                   right=mid-1;
                }
                else
                {
                    left=mid+1;
                }
            }
            
        }
        return ind;
    }
}
----------------------trust the process you will definitely win
question 68
leetcode 33
search in a rotated sorted array
class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = (start+end) / 2;

            // Check if the target is found
            if (nums[mid] == target) {
                return mid;
            }

            // Determine if the left side is sorted
            if (nums[start] <= nums[mid]) {
                // Target is in the sorted left half
                if (target >= nums[start] && target < nums[mid]) {
                    end = mid - 1; // search in the left half
                } else {
                    start = mid + 1; // search in the right half
                }
            } else {
                // Right side is sorted
                if (target > nums[mid] && target <= nums[end]) {
                    start = mid + 1; // search in the right half
                } else {
                    end = mid - 1; // search in the left half
                }
            }
        }

        return -1; // Target not found
    }
}
----------------------trust the process you will definitely win
question 69 
leetcode 81
81. Search in Rotated Sorted Array II(handling duplicates)
class Solution {
    public boolean search(int[] arr, int target) {
        int start=0,end=arr.length-1;
        boolean ans=false;

        while(start<=end){
            int mid = (start+end)/2;
            if(arr[mid]==target){
                ans=true;
                break;
            }

            else if(arr[mid]==arr[start] && arr[mid]==arr[end]){ //to handle duplicate element case
                start++;
                end--;
            }

            else if(arr[start]<=arr[mid]){ //left sorted
                if(target>=arr[start] && target<arr[mid]){
                    end=mid-1;//left
                }else{
                    start=mid+1;//right
                }

            }else{ //right sorted
                if(target>arr[mid] && target<=arr[end]){
                    start=mid+1;//right
                }else{
                    end=mid-1;//left
                }
            }
        }

        return ans;
    }
}
----------------------trust the process you will definitely win
question 70
leetcode 153 (find min rotated sorted array)
class Solution {
    public static int findMin(int[] arr) {
        int start = 0, end = arr.length - 1;
        int ans = Integer.MAX_VALUE;
        while (start <= end) {
            int mid = (start + end) / 2;

            // Search space is already sorted,
            // then arr[low] will always be
            // the minimum in that search space:
            if (arr[start] <= arr[end]) {
                ans = Math.min(ans, arr[start]);
                break;
            }

            // If left part is sorted:
            if (arr[start] <= arr[mid]) {
                // Keep the minimum:
                ans = Math.min(ans, arr[start]);

                // Eliminate left half:
                start = mid + 1;//right 

            } else { // If right part is sorted:

                // Keep the minimum:
                ans = Math.min(ans, arr[mid]);

                // Eliminate right half:
                end = mid - 1;//left
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 71

public static int findKRotation(int[] arr) {
        int start = 0, end = arr.length - 1;
        int ans = Integer.MAX_VALUE;
        int index = -1;
        while (start <= end) {
            int mid = (start + end) / 2;
            //search space is already sorted
            //then arr[low] will always be
            //the minimum in that search space:
            if (arr[start] <= arr[end]) {
                if (arr[start] < ans) {
                    index = start;
                    ans = arr[start];
                }
                break;
            }

            //if left part is sorted:
            if (arr[start] <= arr[mid]) {
                // keep the minimum:
                if (arr[start] < ans) {
                    index = start;
                    ans = arr[start];
                }

                // Eliminate left half:
                start = mid + 1;//right
            } else { //if right part is sorted:

                // keep the minimum:
                if (arr[mid] < ans) {
                    index = mid;
                    ans = arr[mid];
                }

                // Eliminate right half:
                end = mid - 1;//left
            }
        }
        return index;
    }
----------------------trust the process you will definitely win
question 72
leetcode 540 single element in a sorted array

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0;
        int r = nums.length - 1;
        
        while (l<r) {
            int m = (l+r) / 2;
            
            // Ensure m is even so we can compare nums[m] with nums[m + 1]
            if (m % 2 == 1) {
                m--;
            }

            // If nums[m] equals nums[m + 1], the single element is in the right half
            if (nums[m] == nums[m + 1]) {
                l = m + 2;//right
            } 
            // Otherwise, it's in the left half
            else {
                r = m;//left
            }
        }

        // l will point to the single element
        return nums[l];
    }
}
----------------------trust the process you will definitely win
question 73
leetcode 162
class Solution {
    public int findPeakElement(int[] arr) {
        
        int left=0;
        int right=arr.length-1;

        while(left<right)
        {
            int mid=(left+right)/2;
            if(arr[mid]>arr[mid+1])
            {
                right=mid;//left
            }
            else
            {
                left=mid+1;//right
            }
        }
        return left;
    }
}
----------------------trust the process you will definitely win
question 74
find square root of a no (bs)
public static int floorSqrt(int n) {
        int low = 1, high = n;
        //Binary search on the answers:
        while (low <= high) {
            long mid = (low + high) / 2;
            long val = mid * mid;
            if (val <= (long)(n)) {
                //eliminate the left half:
                low = (int)(mid + 1);//right
            } else {
                //eliminate the right half:
                high = (int)(mid - 1);//left
            }
        }
        return high;
    }

----------------------trust the process you will definitely win
question 75
875. Koko Eating Bananas bruteforce
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        //binary search
        
        //one hour ku minimum ah ethana bananas sapdum a monkey min is 1 max is max(arr0
        //taking the largest value possible as end
        int end=-1;
        for(int i=0;i<piles.length;i++)
        {
           if(max<piles[i])
           {
            max=piles[i];
           }
        }
        for(int i=1;i<=max;i++)
        {
            if(isPossible(piles,i,h))
            {
                return i;
            }
        } 
         
        return max;
    }
    public boolean isPossible(int[] piles, int value, int h){
        int hours = 0;
        for(int pile : piles){
            int div = pile / value;
            hours += div;
            if(pile % value != 0) hours++;
        }
        return hours <= h;
    }
}

----------------------trust the process you will definitely win
question 76
leetcode 1283 
 We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 

class Solution {
    public int smallestDivisor(int[] nums, int t) {
        int low = 1, high = 1, ans =-1;

        for(int i : nums) {
            if(i > high) high = i;
        }

        while(low <= high) {
            int mid = (low + high) / 2;

            int val = getThreshold(nums, mid);
            if(val <= t) {
                high = mid - 1;//left
                ans = mid;
            } else {
                low = mid +1;//right
            }
        }
        return ans;
    }
    
    public int getThreshold(int[] map, int val){
        
        int ans = 0;
        for(int i : map) {
            ans += (i + val - 1) / val;
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 77
leetcode 1482. Minimum Number of Days to Make m Bouquets
see coders campt youtube video to understand this question...
class Solution {

//oru boque ku k flowers theva padum
//min days to make m boques
//take adajacent flowers to make one boque
 class Solution {
    public int minDays(int[] bloomDay, int m, int k) {

        if((long) m * k > bloomDay.length) 
        return -1;

        int minDays = -1;
        int l = -1, r = Integer.MIN_VALUE, n = bloomDay.length;
        
        for(int i=0; i<n; i++)
        {
           r = Math.max(r, bloomDay[i]);
           l = Math.min(l,bloomDay[i]);
        } 
        

        while(l <= r) 
        {
            int mid = (l + r) / 2;
            if(isValid(mid, bloomDay, m, k))
            {
                minDays = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return minDays;
    }
    static boolean isValid(int mid, int[] bloomDay, int m, int k)
    {
        int cons = 0, numberOfB = 0;
        for(int i=0; i<bloomDay.length; i++)
        {
            if(bloomDay[i] <= mid)
            { 
            ++cons;
            }
            else
            { 
            cons = 0;
            }

            if(cons == k) {
                numberOfB++;
                cons = 0;
            }
        }
        return numberOfB >= m;
    }
}
----------------------trust the process you will definitely win
question 78

Input Format:
 N = 3, M = 27
Result:
 3
Explanation:
 The cube root of 27 is equal to 3.

 public static int func(int mid, int n, int m) {
        long ans = 1;
        for (int i = 1; i <= n; i++) {
            ans = ans * mid;
            if (ans > m) return 2;
        }
        if (ans == m) return 1;
        return 0;
    }

    public static int NthRoot(int n, int m) {
        // Use binary search on the answer space:
        int low = 1, high = m;
        while (low <= high) {
            int mid = (low + high) / 2;
            int midN = func(mid, n, m);
            if (midN == 1) {
                return mid;
            } else if (midN == 0) {
                low = mid + 1;//right
            } else {
                high = mid - 1;//left
            }
        }
        return -1;
    }
----------------------trust the process you will definitely win
question 79
leetcode 1011. least Capacity To Ship Packages Within D Days (ship runs only once per day)

class Solution {

    public int loadOnShip(int mid, int [] weights) {
    ///  This method calculates how many days it would take to load all the packages if the ship's capacity is mid.
        int sum = 0, dayCnt = 0;
        for(int i=0; i<weights.length; i++) {
            sum += weights[i];
            if(sum<=mid){
                continue;
            } else {
                dayCnt++;
                sum = weights[i];
            }
        }
        return dayCnt + 1;
    }

    public int shipWithinDays(int[] weights, int days) {
        int low = 0, high = 0;
        for(int w : weights){
            low = Math.max(low, w);
            high += w;
        }

        while(low<=high){
            int mid = (low+high)/2;
            int daysToLoad = loadOnShip(mid, weights);
            if(daysToLoad <= days) {
                high = mid - 1;//left
            } else {
                low = mid + 1;//right
            }
        }
        return low;
    }
}
----------------------trust the process you will definitely win
question 80
leetcode 1539. Kth Missing Positive Number
//take max value in array up to that value find kth missing value 
it starts from 1 only

public class tUf {
    public static int missingK(int[] vec, int n, int k) {
        for (int i = 0; i < n; i++) {
            if (vec[i] <= k) k++; //shifting k
            else break;
        }
        return k;
    }
    public static void main(String[] args) {
        int[] vec = {4, 7, 9, 10};
        int n = 4, k = 4;
        int ans = missingK(vec, n, k);
        System.out.println("The missing number is: " + ans);
    }
}



----------------------trust the process you will definitely win
question 81
leetcode 74. Search a 2D Matrix
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n=matrix.length;
        int m=matrix[0].length;

        int low=0,high=n*m-1;
        while(low<=high)
        {
            int mid=(low + high )/2;
            int row=mid/m,col=mid%m;
            if(matrix[row][col]==target)
            return true;
            else if(matrix[row][col]<target)
            low=mid+1;//right
            else
            high=mid-1;//left
        }
        return false;
    }
}
----------------------trust the process you will definitely win
question 82
aggressive cows only on take you forward

first stalls ah sort pannu cows =4

  stalls  0   3   4   7   10   9
  cows    c1  c2 c3   c4
  now find disance between two consective cows
  
  comb1  c1-c2 is 3 c2 -c3 is  1 c3 -c4 is 3   its is min is 1
       you can place 4 cows anywhere and their min 
       
       after take max among them           

 public static boolean canWePlace(int[] stalls, int dist, int cows) {
        int n = stalls.length; //size of array
        int cntCows = 1; //no. of cows placed
        int last = stalls[0]; //position of last placed cow.
        for (int i = 1; i < n; i++) {
            if (stalls[i] - last >= dist) {
                cntCows++; //place next cow.
                last = stalls[i]; //update the last location.
            }
            if (cntCows >= cows) return true;
        }
        return false;
    }
    public static int aggressiveCows(int[] stalls, int k) {
        int n = stalls.length; //size of array
        //sort the stalls[]:
        Arrays.sort(stalls);

        int low = 1, high = stalls[n - 1] - stalls[0];
        //apply binary search:
        while (low <= high) {
            int mid = (low + high) / 2;
            if (canWePlace(stalls, mid, k) == true) {
                low = mid + 1;//right
            } else high = mid - 1;//left
        }
        return high;
    }
----------------------trust the process you will definitely win
question 83
Allocate Minimum No of Pages


arr[]={25,46,28,49,24}; pages of books
students=4

s1      s2     s3      s4   
25      46     28     49,24   max is s4 73 pages

25      46    28,49    24      max is s3 77 pages
.
.
.
.
.
         take min of all

public static int countStudents(int[] arr,int pages)
{
    int n=arr.length;
    int students=1;
    int pagesStudent=0;
    for(int i=0;i<n;i++)
    {
        if(pagesStudent+arr[i]<=pages)
        {
            pagesStudent+=arr[i];
        }
        else
        {
            students++;
            pagesStudent=arr[i];
        }
    }
    return students;
}

public static int findPages(int[] arr,int n,int m)
{
    if(m>n)
        return -1;

    int low=-1,high=0;
    for(int i=0;i<arr.length;i++)
    {
        if(low<arr[i])
        {
            low=arr[i];
        }
        high+=arr[i];
    }
    while(low<=high)
    {
        int mid=(low+high)/2;
        int students=countStudents(arr,mid);
        if(students>m)
        {
            low=mid+1;//rigth
        }
        else
        {
            high=mid-1;//left
        }

    }
    return low;
}
----------------------trust the process you will definitely win
question 84
leetcode 410. Split Array Largest Sum

split subarray 

arr[]=[10,20,30,40] k=2 split into k subarrays

[10] [20,30,40] max sum subarrys is 90

[10,20] [30,40] max sum subarrays is 70
.
.
.
find min among that
class Solution {
    private boolean isPossible(int[] nums, int maxSum, int k) {
        int subarrays = 1, sum = 0;

        for (int num : nums) {
            if(sum+num<=maxSum)
            {
                sum+=num;
            }
            else
            {
                sum = num;
                subarrays++;

                if (subarrays > k)
                    return false;
            }
        }

        return true;
    }

    public int splitArray(int[] nums, int k) {
        int low = nums[0], high = 0;
        for (int num : nums) {
            low = Math.max(low, num);
            high += num;
        }

        int result = -1;
        while (low <= high) {
            int mid = (low+high) / 2;

            if (isPossible(nums, mid, k)) {
                result = mid;
                high = mid - 1;//left
            } else {
                low = mid + 1;//right
            }
        }

        return result;
    }
}
----------------------trust the process you will definitely win
question 85
arr[] = [10,20,30,40] walls[units]
painters k=2

should be consecutive
  10      20 30 40    max time taken is 90
  p1         p2
  
 10 20      30 40     max time taken is 70
  p1         p2
  
10 20 30     40       max time taken is 60
   p1         p2
   
take min among all is 60
   

public static int countPainters(int[] boards,int time)
{
   int n=boards.length;
   int painters=1;
   int boardsPainter=0;
   for(int i=0;i<n;i++)
   {
       if(boardsPainter + boards[i]<=time)
       {
         boardsPainter+=boards[i];
       }
       else
       {
          painters++;
          boardsPainter = boards[i];
       }

   }
   retun painters;
}



public static int findLargestMinDistance(int[] boards,int k)
{
    int low=-1,high=0;
    for(int i=0;i<boards.length;i++)
    {
        if(low<boards[i])
        {
            low=boards[i];
        }
        high+=boards[i];
    }

    while(low<=high)
    {
        int mid = (low+high)/2;
        int painters = countPainters(boards,mid);
        if(painters > k)
        {
            low = mid+1;//right
        }
        else
        {
            high = mid-1;//left
        }
    }

    return low;
}
----------------------trust the process you will definitely win
question 86

leetcode 27
class Solution {
    public int removeElement(int[] nums, int val) {

        int c=0;
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]!=val)
            {
                nums[c++]=nums[i];
            }
        }
        
        return c;
    }
}
----------------------trust the process you will definitely win
question 87

public class FibonacciMemoization {
    public static int fib(int n, int[] memo) {
        // Base cases
        if (n <= 1) {
            return n;
        }

        // If already calculated, return the stored result
        if (memo[n] != -1) {
            return memo[n];
        }

        // Recursively calculate Fibonacci and store in the memo array
        memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
        return memo[n];
    }

    public static void main(String[] args) {
        int n = 10; // Example

        // Array to store results, initialized to -1
        int[] memo = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            memo[i] = -1;
        }

        System.out.println("Fibonacci of " + n + " is: " + fib(n, memo));
    }
}
----------------------trust the process you will definitely win
question 88 
leetcode 1021
class Solution {
    public String removeOuterParentheses(String s) {
        String ans="";
        int count=0;
        int n=s.length();
        for(int i=0;i<n;i++)
        {
            char curr=s.charAt(i);
            if(curr=='(' && count==0)
            {
                count++;
            }
            else if(curr=='(' &&count>=1)
            {
                ans+=curr;
                count++;
            }
            else if(curr==')' && count>1)
            {
                ans+=curr;
                count--;
            }
            else if(curr==')' && count==1)
            {
                count--;
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 89
leetcode 151
Reverse a sentences
public static  String result(String s)
{
	int left = 0;
	int right = s.length() - 1;

	String temp = "";
	String ans = "";

	//Iterate the string and keep on adding to form a word
	//If empty space is encountered then add the current word to the result
	while (left <= right)
	{
		char ch = s.charAt(left);
		if (ch != ' ')
		{
			temp += ch;
		}
		else if (ch == ' ')
		{
			if (!ans.equals(""))
			{
				ans = temp + " " + ans;
			}
			else
			{
				ans = temp;
			}
			temp = "";
		}
		left++;
	}

	//If not empty string then add to the result(Last word is added)
	if (!temp.equals(""))
	{
		if (!ans.equals(""))
		{
			ans = temp + " " + ans;
		}
		else
		{
			ans = temp;
		}
	}

	return ans;
}
----------------------trust the process you will definitely win
question 90
1903. Largest Odd Number in String
class Solution {
    public String largestOddNumber(String num) {

        for (int i = num.length()-1;i >= 0;i--){

            if ((num.charAt(i)-'0')%2 !=0 ) 
            return num.substring(0,i+1);
        }
        return "";
    }
}
----------------------trust the process you will definitely win
question 91
796. Rotate String
class Solution {
    public boolean rotateString(String s, String g) {
        if(s.length()!=g.length()) return false;
        s=s+""+s;
        if(s.indexOf(g)==-1)
        return false;
        return true;
    }
}
----------------------trust the process you will definitely win
question 92
leetcode 242
class Solution {
    public boolean isAnagram(String s, String t) {
        
           int a=s.length();
        int b=t.length();
        
        if(a!=b){
            return false;
        }
        
        int[] arr=new int[26];
        
        for(int i=0;i<a;i++){
            char ch=s.charAt(i);
            int index=ch-'a';
            arr[index]++;
        }
        for(int i=0;i<b;i++){
            char ch=t.charAt(i);
            int index=ch-'a';
            arr[index]--;
        }
        for(int i:arr){
            if(i!=0){
                return false;
            }
        }
        return true;
    }
}
----------------------trust the process you will definitely win
question 93
leetcode 14. Longest Common Prefix
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String prefix = strs[0];
        for(int i=1;i<strs.length;i++){
            while(strs[i].indexOf(prefix) != 0){
                prefix=prefix.substring(0,prefix.length()-1);
            }
        }
        return prefix;
    }
}
----------------------trust the process you will definitely win
question 94
leetcode 205
class Solution {
    public boolean isIsomorphic(String s, String t) {
        // Create arrays to store the index of characters in both strings
        int[] indexS = new int[200]; // Stores index of characters in string s
        int[] indexT = new int[200]; // Stores index of characters in string t
        
        // Get the length of both strings
        int len = s.length();
        
        // If the lengths of the two strings are different, they can't be isomorphic
        if(len != t.length()) {
            return false;
        }
        
        // Iterate through each character of the strings
        for(int i = 0; i < len; i++) {
            if(indexS[s.charAt(i)] != indexT[t.charAt(i)]) {
                return false; 
            }
            
            
            indexS[s.charAt(i)] = i + 1; 
            indexT[t.charAt(i)] = i + 1; 
        }
        
        // If the loop completes without returning false, strings are isomorphic
        return true;
    }
}
----------------------trust the process you will definitely win
question 95
leetcode 1614. Maximum Nesting Depth of the Parentheses
class Solution {
   public int maxDepth(String s) {
    int left = 0; // To track current depth
    int maxInt = 0; // To track maximum depth
    int i = 0; // Iterator for the string

    while (i <= s.length() - 1) {
        if (s.charAt(i) == '(') {
            left++; // Increment current depth
            maxInt = Math.max(left, maxInt); // Update maximum depth if needed
            i++; // Move to next character
        } else if (s.charAt(i) == ')') {
            left--; // Decrement current depth
            i++; // Move to next character
        } else {
            i++; // Move to next character for any non-parenthesis character
        }
    }
    return maxInt; // Return the maximum depth found
}
}
----------------------trust the process you will definitely win
question 97
leetcode 13. Roman to Integer
class Solution {
     public int romanToInt(String s) {
         int ans = 0, num = 0;
        for (int i = s.length()-1; i >= 0; i--) {
            switch(s.charAt(i)) {
                case 'I': num = 1; break;
                case 'V': num = 5; break;
                case 'X': num = 10; break;
                case 'L': num = 50; break;
                case 'C': num = 100; break;
                case 'D': num = 500; break;
                case 'M': num = 1000; break;
            }
            if (4 * num < ans) ans -= num;
            else ans += num;
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 98
leetcode 5
Longest palindromic substring
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int window = n;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<=n-window; j++)
            {
                String temp = s.substring(j, j+window);
                temp = checkPalindrome(temp);
                if(!temp.isEmpty())
                {
                    return temp;
                }
                
            }
            window--;
        }
        return "";
    }

    public String checkPalindrome(String str)
    {
        for(int i=0, j=str.length()-1; i<str.length() && j>=0; i++, j--)
        {
            if(str.charAt(i)!=str.charAt(j))
            {
                return "";
            }
        }
        return str;
    }
}

----------------------trust the process you will definitely win

ArrayList 10 hashmap 16 hashset 16 linked no predefined size

vector 10 stack 10 priority queue 11 hashtable 11 linkdhashmap 16

treemap nopredefinedsize treeset nopredefinedsize concurrent hashmap 16

linkedhashset 16 
----------------------trust the process you will definitely win
Collections.sort(people, (p1, p2) -> p1.name.compareTo(p2.name));
Collections.sort(people, (p1, p2) -> Integer.compare(p1.age, p2.age));
----------------------trust the process you will definitely win
question 99
Integer to roman
public class IntegerToRoman {
    public static String intToRoman(int num) {
        String result = "";  // Use a simple string for concatenation

        // Define arrays for roman numerals and corresponding integer values
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] numerals = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        for (int i = 0; i < values.length; i++) {
            while (num >= values[i]) {
                result = result + numerals[i];  // Concatenate the result manually
                num -= values[i];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int number = 1994;  // Example input
        System.out.println("Integer: " + number + " = " + intToRoman(number));
    }
}
----------------------trust the process you will definitely win
question 100
leetcode 451
class Solution {
    public String frequencySort(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        for(char ch : s.toCharArray()) {
            map.put(ch, map.getOrDefault(ch,0)+1);
        }
        List<Character> [] bucket = new List[s.length()+1];
        for(Character key : map.keySet()) {
            int freq = map.get(key);
            if(bucket[freq] == null) {
                bucket[freq]=new ArrayList<>();
            }
            bucket[freq].add(key);
        }

        String result = "";
       for (int i = bucket.length - 1; i >= 0; i--) {
          if  (bucket[i] != null) {
          for (char ch : bucket[i]) {
            for (int j = 0; j < i; j++) {
                result += ch;  // Concatenate character to the result string
            }
          }
        }
     }
return result;

    }
}

----------------------trust the process you will definitely win
question 101
leetcode 8
class Solution {
    public int myAtoi(String s) {
        boolean neg = false;
        int ans=0, i=0;
        int len = s.length();
        while(i<len && s.charAt(i) == ' '){
            i++;
        }
        if(i<len){
            char c = s.charAt(i);
            if(c == '-'){
                neg = true;
                i++;
            }
            else if(c == '+'){
                i++;
            }
        }
        while(i<len && s.charAt(i)>='0' && s.charAt(i)<='9')
        {
            int digit = s.charAt(i) - '0';

            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                return neg ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }

            ans = ans * 10 + digit;
            i++;
        }

        return neg ? -ans : ans;
    }
}
----------------------trust the process you will definitely win
question 102
geeksforgeeks
Given a string of lowercase alphabets, count all possible substrings (not necessarily distinct) that have exactly k distinct characters. 

Input: aba, k = 2
Output: 3
Possible substrings are {â€œabâ€, â€œbaâ€, â€œabaâ€}
class Solution { 
    long countSubstring(String S, int K) {
        int n = S.length();
        int[] freq = new int[26];
        int uc = 0;
        long count = 0;
        int left = 0;

        for (int right = 0; right < n; right++) {
            if (freq[S.charAt(right) - 'a'] == 0) {
                uc++;
            }
            freq[S.charAt(right) - 'a']++;
            
            while (uc > K) {
                freq[S.charAt(left) - 'a']--;
                if (freq[S.charAt(left) - 'a'] == 0) {
                    uc--;
                }
                left++;
            }
            count += right - left + 1;
        }
        
        return count;
    }
    
    
    long substrCount(String S, int K) {
        if (S == null || K <= 0) {
            return 0;
        }
        
        return countSubstring(S, K) - countSubstring(S, K - 1);
    }
}
----------------------trust the process you will definitely win
 question 103
leetcode 1781. Sum of Beauty of All Substrings
class Solution {
    public int beautySum(String s) {

        int ans = 0;
        char arr[] = s.toCharArray();

        for(int i=0;i<arr.length;i++){
            int freq[] = new int[26];
            for(int j=i;j<arr.length;j++){
                freq[arr[j]-'a']++;
                int minFreq = arr.length;
                int maxFreq = 0;
                
                for(int k:freq){
                    if(k!=0){
                        minFreq = Math.min(minFreq,k);
                        maxFreq = Math.max(maxFreq,k);
                    }
                }       
                ans += (maxFreq - minFreq);
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 104
leetcode 237
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
----------------------trust the process you will definitely win
question 105
public class SubsequencePrinter {
    public static void main(String[] args) {
        String str = "abc";
        printSubsequences(str, 0, "");
    }

    // Recursive method to generate all subsequences
    public static void printSubsequences(String str, int index, String current) {
        // Base case: if we've reached the end of the string, print the current subsequence
        if (index == str.length()) {
            System.out.println(current);
            return;
        }

        // Recursive case: exclude the current character and move to the next
        printSubsequences(str, index + 1, current);

        // Recursive case: include the current character and move to the next
        printSubsequences(str, index + 1, current + str.charAt(index));
    }
}


----------------------trust the process you will definitely win
question 106
leetcode 240. Search a 2D Matrix II
public class Solution {
 public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target > matrix[row][col]) {
                row++;
            }
            else
            {
                col--;
            }
        }
        return false;
    }
}
----------------------trust the process you will definitely win
question 107
Doubly linked list implementation
// Node class for creating a node
    class Node {
        int data;
        Node next;
        Node prev;

        Node(int d) 
        { 
            data = d; 
            next = null;
            prev = null;
         }
    }

class DoublyLinkedList {
    Node head; // head of the list


    public DoublyLinkedList()
    {
     this.head=null;
    }
    
    // Insert a new node at the end of the list
    public void insert(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
            newNode.prev = current;
        }
        System.out.println(data + " inserted.");
    }

    // Delete a node with a specific value
    public void delete(int key) {
        Node temp = head;

        // If head node itself holds the key
        if (temp != null && temp.data == key) {
            head = temp.next;
            if (head != null) head.prev = null;
            System.out.println(key + " deleted.");
            return;
        }

        // Search for the key to be deleted
        while (temp != null && temp.data != key) {
            temp = temp.next;
        }

        // If the key was not present
        if (temp == null) {
            System.out.println(key + " not found.");
            return;
        }

        // Unlink the node from the list
        if (temp.next != null) temp.next.prev = temp.prev;
        if (temp.prev != null) temp.prev.next = temp.next;
        System.out.println(key + " deleted.");
    }

    // Reverse the doubly linked list
    public void reverse() {
        Node current = head;
        Node temp = null;

        // Swap next and prev pointers for each node
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        // Adjust head pointer to point to the last node
        if (temp != null) head = temp.prev;
        System.out.println("List reversed.");
    }

    // Display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    // Main function to test the linked list
    public static void main(String[] args) {
        DoublyLinkedList list = new DoublyLinkedList();
        
        list.insert(10);
        list.insert(20);
        list.insert(30);
        list.display();
        list.delete(20);
        list.display();
        list.reverse();
        list.display();
    }
----------------------trust the process you will definitely win
question 108
leetcode 876
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow=head,fast=head;
        while( fast!=null && fast.next!=null )
        {
            slow=slow.next;
            fast=fast.next.next;
        }
        return slow;
    }
}
----------------------trust the process you will definitely win
question 109
leetcode 206
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode node=null;
        while(head!=null)
        {
            ListNode next=head.next;
            head.next=node;
            node=head;
            head=next;
        }
        return node;
    }
}

-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 110
Row with maximum ones
 public static int row_with_maxOnes(int[][] arr)
 {
    for(int j =0;j<arr[0].length;j++){
            for(int i = 0;i<arr.length;i++){
                if(arr[i][j]==1){
                   return i;
                }
            }
        }
        return -1;
 }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 111
public int medianofarray(int[][] matrix,int R,int C)
{
  int arr[]=new int[R*C];
        int start=0;
        for(int i=0;i<R;i++){
            for(int j=0;j<C;j++){
                arr[start]=matrix[i][j];
                start++;
            }
        }
        Arrays.sort(arr);
        return (arr[(0+arr.length)/2]);
        
 }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 112 brute
find peak element leetcode 1901
class Solution {
    public int[] findPeakGrid(int[][] mat) {
        int row = mat.length;
        int col = mat[0].length;
        int maxrowele = -1;
        int[] ans = new int[]{-1,-1};
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(mat[i][j] > maxrowele){
                    maxrowele = mat[i][j];
                    ans[0] = i;
                    ans[1] = j;
                }
            }
            if(maxcolele(maxrowele,mat,ans[1])){
                return ans;
            }
        }
        return ans;
    }
    public boolean maxcolele(int ele, int[][] mat,int colc){
         int row = mat.length;
        int col = mat[0].length;
        int maxcolel = -1;
        for(int i=0;i<row;i++){
            if(mat[i][colc] > maxcolel){
                maxcolel = mat[i][colc];
            }
        }
        return ele==maxcolel;
    }
}

-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 113
reverse a linked list (recursive)
public Node reverse(Node curr)
{
    if(curr==null || curr.next==null)
    {
        return curr;
    }
    Node newnode=rev(curr.next);
    curr.next.next=curr;
    curr.next=null;
    
    return newnode;
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 114
linked list cycle 
leetcode 141
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head;

        while(fast!=null && fast.next!=null){
            slow=slow.next;
            fast= fast.next.next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 115
linked list cycle II
Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
leetcode 142
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        if (fast == null || fast.next == null) return null;
        while (head != slow) {
            head = head.next;
            slow = slow.next;
        }
        return head;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 116
leetcode 234
check ll is palindrome
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode temp1 = head;
        ListNode temp2 = head;

        while(temp2 != null && temp2.next != null){
            temp1 = temp1.next;
            temp2 = temp2.next.next;
        }

        if(temp2 != null){
            temp1 = temp1.next;
        }
        temp1 = reverseLinkedList(temp1);//reversing second half

        while(temp1 != null){//comparing second half with first half
            if(temp1.val != head.val){
                return false;
            }
            temp1 = temp1.next;
            head = head.next;
        }

        return true;
    }

    public ListNode reverseLinkedList(ListNode head){
        ListNode prev = null;

        while(head != null){
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }

        return prev;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 117
leetcode 328
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) return head;  // Handle edge cases

        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;  // To reconnect odd and even lists at the end

        while (even != null && even.next != null) {
            odd.next = even.next;  // Link current odd node to next odd node
            odd = odd.next;        // Move odd pointer
            even.next = odd.next;  // Link current even node to next even node
            even = even.next;      // Move even pointer
        }

        odd.next = evenHead;  // Append even list after odd list
        return head;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 118
leetcode 19
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode slow=head;
        ListNode fast=head;
        ListNode prev=null;
  
       for(int i=1;i<=n;i++){
        fast=fast.next;
       }
        if(fast==null) return head.next;
        while(fast!=null){
            prev=slow;
            fast=fast.next;
            slow=slow.next;
        }
        prev.next=slow.next;
        return head;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 119
leetcode 2095
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        if(head == null || head.next == null) return null;

        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;

        while(fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        prev.next = slow.next;
        return head;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 120
leetcode 148
public class Solution {
  
  public ListNode sortList(ListNode head) {
    if (head == null || head.next == null)
      return head;
        
    // step 1. cut the list to two halves
    ListNode prev = null, slow = head, fast = head;
    
    while (fast != null && fast.next != null) {
      prev = slow;
      slow = slow.next;
      fast = fast.next.next;
    }
    
    prev.next = null;
    
    // step 2. sort each half
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(slow);
    
    // step 3. merge l1 and l2
    return merge(l1, l2);
  }
  
  public ListNode merge(ListNode l1, ListNode l2) {
    ListNode l = new ListNode(0), p = l;
    
    while (l1 != null && l2 != null) {
      if (l1.val < l2.val) {
        p.next = l1;
        l1 = l1.next;
      } else {
        p.next = l2;
        l2 = l2.next;
      }
      p = p.next;
    }
    
    if (l1 != null)
      p.next = l1;
    
    if (l2 != null)
      p.next = l2;
    
    return l.next;
  }

}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 121
public Node sort012(Node head)
{
        Node zero = new Node(-1);
        Node one = new Node(-1);
        Node two = new Node(-1);
        
        Node zeroHead = zero;
        Node oneHead = one;
        Node twoHead = two;
        
        Node temp = head;
        while(temp!=null){
            if(temp.data == 0){
                zero.next = temp;
                zero = temp;
            }else if(temp.data == 1){
                one.next = temp;
                one = temp;
            }else{
                two.next = temp;
                two = temp;
            }
            temp = temp.next;
        }
        
        zero.next = oneHead.next != null ? oneHead.next : twoHead.next;
        one.next = twoHead.next ;
        two.next = null;
        
        return zeroHead.next;
 }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 122
leetcode 160
class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        while(a!=b){
            if(a==null && b==null){
                return null;
            }else if(a==null){
                a = headB;
            }else if(b==null){
                b = headA;
            }else{
                a = a.next;
                b = b.next;
            }
        }
        return a;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 123
add 1 to linked list
// Reverse the linked list
    private static Node reverse(Node head) {
        Node prev = null;
        Node current = head;
        while (current != null) {
            Node next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }

    // Add one to the reversed linked list
    private static Node addOne(Node head) {
        Node result = head;
        Node temp = null;
        int carry = 1;
        
        while (head != null) {
            int sum = head.data + carry;
            carry = sum / 10;
            head.data = sum % 10;
            temp = head;
            head = head.next;
        }
        
        // If carry is left after the last node
        if (carry > 0) {
            temp.next = new Node(carry);
        }
        
        return result;
    }

    public static Node addOneToLinkedList(Node head) {
        // Step 1: Reverse the linked list
        head = reverse(head);
        
        // Step 2: Add one to the reversed list
        head = addOne(head);
        
        // Step 3: Reverse the list again to restore the original order
        head = reverse(head);
        
        return head;
    }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 124
leetcode 2
public ListNode addTwoNumbers(ListNode number1, ListNode number2) {
         // THERE HAVE TWO APPROTCH TO SOLVE THIS PROBLEM 
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry=0;
        while(number1!=null||number2!=null){
            int sum=carry;
            if(number1!=null){ 
                sum=sum+number1.val;
                number1=number1.next;
            }
            if(number2!=null){
                sum=sum+number2.val;
                number2=number2.next;
            }
            carry = (sum/10);
            current.next=new ListNode(sum%10);
            current=current.next;
        }
        if(carry==1)
        current.next=new ListNode(1);

        return dummy.next;
    }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 125
dll
class Solution {
    static Node deleteAllOccurOfX(Node head, int x) {
        // Write your code here
        Node dummy=new Node();
        dummy.next=head;
        Node curr=head;
        Node prev=dummy;
        
        while(curr!=null)
        {
            if(curr.data==x)
            {
                prev.next=curr.next;
                if(curr.next!=null)
                {
                    curr.next.prev=prev;
                }
                curr=prev.next;
            }
            else
            {
                prev=curr;
                curr=curr.next;
            }
        }
        return dummy.next;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 126
dll
class Solution{
    Node removeDuplicates(Node head){
        // Code Here.
        if(head==null || head.next==null) return head;
        Node p=head,n=head.next;
        while(n!=null){
            if(p.data!=n.data){
                p.next=n;
                n.prev=p;
                p=p.next;
            }
            n=n.next;
        }
        if(p.next!=null) p.next=null;
        return head;
        
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 127
dll
class Solution {
    public static ArrayList<ArrayList<Integer>> findPairsWithGivenSum(int target, Node head) {
        // code here
        ArrayList<ArrayList<Integer>> ans=new ArrayList<>();
        Node left=head,right=findTail(head);
        while(left!=null && right!=null && left.data<right.data)
        {
            if(left.data+right.data==target)
            {
               ArrayList<Integer> temp=new ArrayList<>();
               temp.add(left.data);
               temp.add(right.data);
               ans.add(temp);
               left=left.next;
               right=right.prev;
            }
            else if(left.data+right.data<target)
            {
                left=left.next;
            }
            else
            {
                right=right.prev;
            }
        }
        return ans;
    }
    public static Node findTail(Node head)
    {
        while(head!=null && head.next!=null)
        {
            head=head.next;
        }
        return head;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 128
leetcode 61 
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null||head.next==null||k==0)
        return head;
        ListNode x=head;
        int len=1;
        while(x.next!=null){
            len++;
            x=x.next;
        }
        x.next=head;
        x=x.next;
        k=k%len;
        for(int i=0;i<len-k-1;i++){
            x=x.next;
        }
        ListNode newHead=x.next;
        x.next=null;
        return newHead;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 129 /hard
leetcode 25
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next=head;
        ListNode temp=head;
        ListNode start=dummy;
        int i=0;
        while(temp!=null) {
            i++;
            if(i%k==0) {
                start=reverse(start,temp.next);
                temp=start.next;
            } else {
                temp=temp.next;
            }
            
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode start,ListNode end) {
        ListNode prev=null;
        ListNode head=start.next;
        ListNode first = head;
        while(head!=end) {
            ListNode next=head.next;
            head.next=prev;
            prev=head;
            head=next;
        }
        start.next=prev;
        first.next=head;
        return first;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 130
leetcode 50
class Solution {
    public double myPow(double x, int n) {
        if(x == 0)
            return 0;
        if(n == 0)
            return 1;
        
        double p = myPow(x,n/2);
        
        if(n%2 == 0)
            return  p * p;
        else if(n%2 == 1)
            return  p * p * x;
        else
            return 1/myPow(x,-n);
            
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 131  /hard
class Solution {
    // Function to flatten a linked list
    Node flatten(Node root) {
        // code here
        if(root==null || root.next==null )
        return root;
        
        Node r1=flatten(root.next);
        root=merge(r1,root);
        return root;
    }
    public Node merge(Node r1,Node r2)
    {
        Node res =  new Node(-1) ;
        Node dummy = res;
        
        while(r1 != null && r2 != null){
            
            if( r1.data > r2.data){
                dummy.bottom = r2;
                r2 = r2.bottom;
            } else{
                dummy.bottom = r1;
                r1 = r1.bottom;
                
            }
          dummy = dummy.bottom;
                
        }
        
        if(r1!= null) dummy.bottom = r1;
        if(r2!= null) dummy.bottom = r2;
        return res.bottom;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 132
leetcode 8
class Solution {
    public int myAtoi(String s) {
        s = s.trim(); // Remove leading and trailing whitespace
        if (s.isEmpty()) return 0; // Return 0 if the string is empty after trimming
        return atoiRecursive(s, 0, 1, 0); // Call the recursive helper function
    }

    public int atoiRecursive(String s, int idx, int sign, long res) {
        if (idx == s.length()) return (int) (sign * res);
        
        char c = s.charAt(idx); 
        
        if (Character.isDigit(c)) {
            // If the character is a digit, update the result
            res = (res * 10) + (c - '0');
            // Check for overflow/underflow
            if (res * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;
            if (res * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;
            return atoiRecursive(s, idx + 1, sign, res);
        } else if (idx == 0 && (c == '+' || c == '-')) {
            // If the character is '+' or '-' and it's the first character, update the sign
            if (c == '-') sign = -1;
            return atoiRecursive(s, idx + 1, sign, res);
        }
        // If the character is not a digit and it's not the first character,
        // or if it's an invalid character, return the current result
        return (int) (sign * res);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 133
Reverse stack using recursion
    static void reverse(Stack<Integer> s) {
        // Base case: if the stack is empty, return
        if (s.isEmpty()) {
            return;
        }

        // Step 1: Pop the top element and store it
        int top = s.pop();

        // Step 2: Recursively reverse the remaining stack
        reverse(s);

        // Step 3: Insert the popped element at the bottom of the reversed stack
        insertAtBottom(s, top);
    }

    // Helper method to insert an element at the bottom of a stack
    static void insertAtBottom(Stack<Integer> s, int item) {
        // Base case: if the stack is empty, push the item
        if (s.isEmpty()) {
            s.push(item);
            return;
        }

        // Recursive case: pop the top element and hold it
        int top = s.pop();
        insertAtBottom(s, item);

        // Push the held item back onto the stack
        s.push(top);
    }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 134
sort a stack using recursion
public Stack<Integer> sort(Stack<Integer> s) {
        // Base case: if the stack is empty, return it
        if (s.isEmpty()) {
            return s;
        }

        // Step 1: Pop the top element
        int top = s.pop();

        // Step 2: Recursively sort the remaining stack
        sort(s);

        // Step 3: Insert the popped element back in sorted order
        sortedInsert(s, top);

        return s;
    }

    // Helper function to insert an element in a sorted stack
    private void sortedInsert(Stack<Integer> s, int item) {
        // Base case: if the stack is empty or the top element is less than or equal to item, push it
        if (s.isEmpty() || item>=s.peek()) {
            s.push(item);
            return;
        }

        // Recursive case: pop the top element and hold it
        int top = s.pop();
        sortedInsert(s, item);

        // Push the held element back onto the stack
        s.push(top);
    }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 135
leetcode 1922
Input: n = 4
Output: 400
400 combinations
class Solution {
    public final int mod = 1000000007;

    public int countGoodNumbers(long n) {
        // Calculate the number of even and odd positions
        long o = n / 2; // Odd positions
        long e = n / 2 + n % 2;// Even positions (one more if n is odd)

        // Calculate the result by raising 5 to the power of e and 4 to the power of o
        long ans = (pow(5, e) * pow(4, o)) % mod;// 5 possible for even pos 4 possible for odd pos

        return (int) ans;
    }

    public long pow(long x, long n) {
        // Exponentiation by squaring to compute (x^n) % mod efficiently
        if (n == 0) return 1;          // Base case: x^0 is 1
        long tP = pow(x, n / 2);       // Recursively calculate x^(n/2)
        tP = (tP * tP) % mod;          // Square it to get x^n
        if (n % 2 != 0) tP = (tP * x) % mod; // If n is odd, multiply by x
        return tP;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 136
generate all binary strings using recursion
public static void generateBinaryStrings(int n) {
        generateBinaryStringsHelper(n, "");
    }

    // Recursive helper method to generate binary strings
    private static void generateBinaryStringsHelper(int n, String current) {
        // Base case: If the length of the current string is n, add it to the result
        if (current.length() == n) {
            System.out.println(current)
            return;
        }
        
        // Recursively add '0' and '1' to the current string
        generateBinaryStringsHelper(n, current + "0");
        generateBinaryStringsHelper(n, current + "1");
    }
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 137
leetcode 22
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>(); // initialize the result list
        generate(result, "", n, n); 
        return result;     }
    
    public void generate(List<String> result, String s, int left, int right){
        if(left == 0 && right == 0){ 
            result.add(s); 
            return; 
        }
        if(left > 0){ 
            generate(result, s + "(", left - 1, right); 
        }
        if(right > left){ 
            generate(result, s + ")", left, right - 1); 
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 138
public class SubsetGenerator {
    
    public static void generateSubsets(int[] arr, int index, int[] subset, int subsetIndex) {
        // Base case: If we've considered all elements
        if (index == arr.length) {
            // Print the current subset
            System.out.print("{ ");
            for (int i = 0; i < subsetIndex; i++) {
                System.out.print(subset[i] + " ");
            }
            System.out.println("}");
            return;
        }

        // Include the current element in the subset
        subset[subsetIndex] = arr[index];
        generateSubsets(arr, index + 1, subset, subsetIndex + 1);

        // Exclude the current element from the subset
        generateSubsets(arr, index + 1, subset, subsetIndex);
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        int[] subset = new int[arr.length];  // Array to store current subset
        System.out.println("All subsets of the array are:");
        generateSubsets(arr, 0, subset, 0);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 139
leetcode 78
class Solution {
    
    public void solve(List<List<Integer>> ans , List<Integer> temp , int ind , int[] nums ) {
        int n = nums.length;
        if( ind >= n ){
            ans.add(new ArrayList<>(temp));
            return;
        }
        
//         do not add current element
        solve(ans, temp , ind + 1 , nums );
        temp.add(nums[ind]);
        solve(ans, temp , ind + 1 , nums );
        temp.remove(temp.size()-1);
        return ;
    }
    
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        solve(ans, new ArrayList<>() , 0 , nums );
        return ans;
        
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 140
public class SubsetSumCountRecursive {
    static int MOD = 1000000007;

    // Helper function to count subsets with given sum using recursion
    public static int countSubsets(int[] arr, int n, int sum) {
        // Base cases
        
	if(n==0 && sum!=0)
	    return 0;
	       
	if(n==0 && sum==0)
	     return 1;
	       
        // Exclude the current element and move to the next
        int exclude = countSubsets(arr, n - 1, sum) % MOD;

        // Include the current element only if it's <= sum
        int include = 0;
        if (arr[n - 1] <= sum) {
            include = countSubsets(arr, n - 1, sum - arr[n - 1]) % MOD;
        }

        // Total count is sum of including and excluding the current element
        return (exclude + include) % MOD;
    }

    public static void main(String[] args) {
        int[] arr = {5, 2, 3, 10, 6, 8};
        int sum = 10;
        int n = arr.length;

        System.out.println("Count of subsets with sum " + sum + ": " + countSubsets(arr, n-1, sum));
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 141
public class Solution {
//Check if there exists a subsequence with sum K
    public static boolean isSubsetPresent(int n, int k,int []a) {
        // Write your code here
        return helper(a,n-1,k);
    }
    public static boolean helper(int[] A,int index,int targetSum)
    {
        if (targetSum == 0) {
            return true;
        }
        // Base case: If we've gone through all elements or target is negative
        if (index < 0 || targetSum < 0) {
            return false;
        }

        // Exclude the current element and check
        boolean exclude = helper(A, index - 1, targetSum);

        // Include the current element and check
        boolean include = helper(A, index - 1, targetSum - A[index]);

        // Return true if either including or excluding leads to a solution
        return include || exclude;
    }

}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 142
leetcode 39
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {

        List<List<Integer>> ans = new ArrayList<>();
        findcombination(0, candidates, target, ans, new ArrayList<Integer>());
        return ans;
    }

    public void findcombination(int ind, int[] arr, int target, List<List<Integer>> ans,
            ArrayList<Integer> ds) {
        if (ind == arr.length) {
            if (target == 0) {
                ans.add(new ArrayList<>(ds));
            }
            return;
        }
        if (arr[ind] <= target) {
            ds.add(arr[ind]);
            findcombination(ind, arr, target - arr[ind], ans, ds);
            ds.remove(ds.size() - 1);
        }
        findcombination(ind + 1, arr, target, ans, ds);

    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 143
leetcode 40
no duplicates in each list comb 
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans=new ArrayList<>();
        Arrays.sort(candidates);
        find(0,candidates,target,ans,new ArrayList<>());
        return ans;
    }
    public void find(int ind,int[] arr,int target,List<List<Integer>> ans,ArrayList<Integer> temp)
    {
        if(target==0)
        {
            ans.add(new ArrayList<>(temp));
            return;
        }
        for(int i=ind;i<arr.length;i++)
        {
            if(i!=ind && arr[i]==arr[i-1])
            continue;
            
            if(arr[i]>target)
            break;
            temp.add(arr[i]);
            find(i+1,arr,target-arr[i],ans,temp);
            temp.remove(temp.size()-1);
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 144
class Solution{
    ArrayList<Integer> subsetSums(ArrayList<Integer> arr, int N){
        // code here
        ArrayList<Integer> ans= new ArrayList<Integer>();
        Solution s=new Solution();
        s.subset(0,0,N,arr,ans);
        Collections.sort(ans);
        return ans;
    }
    public  void subset(int i,int sum,int n,ArrayList<Integer> arr,ArrayList<Integer> ans)
    {
        if(i==n)
        {
            ans.add(sum);
            return;
        }
        subset(i+1,sum+arr.get(i),n,arr,ans);
        subset(i+1,sum,n,arr,ans);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 145
leetcode 90
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        
        Arrays.sort(nums);
        List<List<Integer>> ans =new ArrayList<>();
        bt(nums,0,new ArrayList<>(),ans);
        return ans;
    }
    private void bt(int[] nums,int st,List<Integer> path,List<List<Integer>> ans)
    {
        
        ans.add(new ArrayList<>(path));
        for(int i=st;i<nums.length;i++)
        {
            if(i!=st && nums[i]==nums[i-1])
            {
                continue;
            }
            path.add(nums[i]);
            bt(nums,i+1,path,ans);
            path.remove(path.size()-1);
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 146
leetcode 216
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.

class Solution {
    List<List<Integer>> ans=new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        int [] number={1,2,3,4,5,6,7,8,9};
        solve(0,number,k,n,new ArrayList<>());
        return ans;
    }
    public void solve(int index,int [] numbers,int k,int target,List<Integer> al){
        if(target==0 && al.size()==k){
            ans.add(new ArrayList<>(al));
            return;
        }
        if(al.size()>k){
            return;
        }
        for(int i=index;i<numbers.length;i++){
            al.add(numbers[i]);
            solve(i+1,numbers,k,target-numbers[i],al);
            al.remove(al.size()-1);
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 147
leetcode 17
class Solution 
{
	List<String> list = new ArrayList<>();
	List<String> k = new ArrayList<>(Arrays.asList("","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"));

	public void fun(String dig,int start,String str)
	{
		if(start==dig.length())
		{
			list.add(str);
			return;
		}
		String x = k.get(dig.charAt(start)-'0');
		for(int i=0;i<x.length();i++)
			fun(s,start+1,str+x.charAt(i));
	}

	public List<String> letterCombinations(String digits) 
	{
		if(digits.length()==0)
			return list;
		fun(digits,0,"");
		return list;
	}
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 148
leetcode 79(printing path also added)
import java.util.ArrayList;
import java.util.List;
class Solution {
    boolean visited[][];
    List<int[]> path = new ArrayList<>(); // To store the path of indexes

    public boolean exist(char[][] board, String word) {   
        int r = board.length;
        int c = board[0].length; 
        visited = new boolean[r][c];
        
        for(int i = 0; i < r; i++) {
            for(int j = 0; j < c; j++) {
                if(word.charAt(0) == board[i][j] && search(i, j, 0, word, board)) {
                    for (int[] p : path) {
                        System.out.println("Index: (" + p[0] + ", " + p[1] + ")");
                    }
                    return true;            
                }
            }
        }
        return false;
    }

    public boolean search(int i, int j, int idx, String word, char[][] board) {
        if (idx == word.length()) {
            return true;
        }
        
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || 
            word.charAt(idx) != board[i][j] || visited[i][j]) {
            return false;
        }
        
        visited[i][j] = true;
        path.add(new int[] {i, j}); // Add the current cell to the path
        
        // Explore in all four directions
        if (search(i + 1, j, idx + 1, word, board) ||
            search(i - 1, j, idx + 1, word, board) ||
            search(i, j + 1, idx + 1, word, board) ||
            search(i, j - 1, idx + 1, word, board)) {
            return true;
        }
        
        // Backtrack
        visited[i][j] = false;
        path.remove(path.size() - 1); // Remove the last cell from the path if backtracking
        
        return false;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 149
leetcode 131
class Solution {
    // Checking the given substring is palindrome 
    private boolean isPalindrome(String s, int start, int end){
        while(start <= end){
            if(s.charAt(start++) != s.charAt(end--)){
                return false;
            }
        }
        return true;
    }

    private void solveRecBacktracking(String s, int idx, List<List<String>> res,List<String>l){
      
        if(s.length() == idx){
            res.add(new ArrayList<>(l));
            return;
        }

      
        for(int i=idx; i<s.length(); i++){
            if(isPalindrome(s, idx, i)){
                l.add(s.substring(idx, i+1));
                solveRecBacktracking(s, i+1, res, l);
                l.remove(l.size()-1);
            }
        }
    }

    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        solveRecBacktracking(s, 0, res, new ArrayList<>());
        return res;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 150
Min no of deletions to make string palindrome

public static int utility_fun_for_del(String str, 
                                      int i, int j)
{
    if (i >= j)
        return 0;
 
    // Condition to compare characters
    if (str.charAt(i) == str.charAt(j)) 
    {
        
        // Recursive function call
        return utility_fun_for_del(str, 
                                   i + 1, j - 1);
    }
 
    // Return value, incrementing by 1
    return 1 + Math.min(utility_fun_for_del(str, i + 1, j),
                        utility_fun_for_del(str, i, j - 1));
} 
public static int min_ele_del(String str)
{
    
    // Utility function call
    return utility_fun_for_del(str, 0, 
                               str.length() - 1);
}

// Driver Code
public static void main(String[] args) 
{
    String str = "abefbac";
    
    System.out.println("Minimum element of deletions = " +
                       min_ele_del(str));
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 151
leetcode 51
class Solution {
    public List<List<String>> solveNQueens(int n) {
        // Initialize an n x n chess board with all empty cells ('.')
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                board[i][j] = '.';
        
        // List to store all possible solutions
        List<List<String>> res = new ArrayList<List<String>>();
        
        // Start the recursive DFS to place queens starting from the 0th column
        dfs(0, board, res);
        
        return res;
    }

    // This function checks if it's safe to place a queen at board[row][col]
    static boolean validate(char[][] board, int row, int col) {
        int duprow = row;
        int dupcol = col;

        // Check the upper diagonal to the left
        while (row >= 0 && col >= 0) {
            if (board[row][col] == 'Q') return false; // Another queen is already in this path
            row--;
            col--;
        }

        // Reset row and col to original values to check the left side
        row = duprow;
        col = dupcol;

        // Check all cells to the left in the current row
        while (col >= 0) {
            if (board[row][col] == 'Q') return false; // Another queen is in the same row
            col--;
        }

        // Reset row and col to original values to check the lower diagonal to the left
        row = duprow;
        col = dupcol;

        // Check the lower diagonal to the left
        while (col >= 0 && row < board.length) {
            if (board[row][col] == 'Q') return false; // Another queen is already in this path
            col--;
            row++;
        }
        
        return true; // Safe to place the queen
    }

    // This function places queens column by column
    static void dfs(int col, char[][] board, List<List<String>> res) {
        // If we've successfully placed queens in all columns, add this board to the results
        if (col == board.length) {
            res.add(construct(board)); // Convert the current board configuration to the required format
            return;
        }

        // Try placing a queen in each row of the current column
        for (int row = 0; row < board.length; row++) {
            // Check if it's safe to place a queen at board[row][col]
            if (validate(board, row, col)) {
                board[row][col] = 'Q'; // Place the queen
                dfs(col + 1, board, res); // Recur for the next column
                board[row][col] = '.'; // Backtrack and remove the queen
            }
        }
    }

    // Converts the board from a 2D array to a list of strings for easy output
    static List<String> construct(char[][] board) {
        List<String> res = new LinkedList<String>(); you can also use arraylist here 
        for (int i = 0; i < board.length; i++) {
            String s = new String(board[i]); // Convert each row to a string
            res.add(s); // Add the string to the result
        }
        return res;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 152
Rat in a maze
class Solution {
    public ArrayList<String> findPath(int[][] mat) {
        // Your code here
        ArrayList<String> ans=new ArrayList<>();
        int n=mat.length;
        boolean[][] vis=new boolean[n][n];
        helper(ans,0,0,mat,n,"",vis);
        return ans;
    }
    public void helper(ArrayList<String> ans,int r,int c,int[][] mat,int n,String p,boolean[][] vis)
    {
        if(r==n-1 && c==n-1 && mat[r][c]!=0)
        {
            ans.add(p);
            return;
        }
        if(r>=0 && r<n && c>=0 && c<n)
        {
           
           if(vis[r][c] || mat[r][c]==0)
             return;
        vis[r][c]=true;
        helper(ans,r+1,c,mat,n,p+'D',vis);
        helper(ans,r-1,c,mat,n,p+'U',vis);
        helper(ans,r,c+1,mat,n,p+'R',vis);
        helper(ans,r,c-1,mat,n,p+'L',vis);
        
        vis[r][c]=false;
        
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 153
leetcode 37
class Solution {
    // This function initiates the recursive backtracking process to solve the Sudoku
    public void solveSudoku(char[][] board) {
        solve(board);   
    }

    // Recursive function to try to solve the board
    public static boolean solve(char[][] board) {
        int n1 = board.length; // number of rows
        int n2 = board[0].length; // number of columns

        // Iterate over each cell in the board
        for (int i = 0; i < n1; i++) {
            for (int j = 0; j < n2; j++) {
                // If we find an empty cell ('.'), we need to try placing numbers in it
                if (board[i][j] == '.') {
                    // Try placing numbers 1 to 9 in the cell
                    for (char c = '1'; c <= '9'; c++) {
                        // Check if placing 'c' at board[i][j] is valid
                        if (isvalid(board, i, j, c)) {
                            board[i][j] = c; // Place the number temporarily

                            // Recursively try to solve the rest of the board
                            if (solve(board))
                                return true; // If successful, return true

                            // If not successful, backtrack and reset the cell
                            board[i][j] = '.';
                        }
                    }
                    // If no numbers 1-9 can be placed in this cell, return false to backtrack
                    return false;
                }
            }
        }
        // If all cells are filled and valid, return true
        return true;
    }

    // Function to check if placing character 'c' at board[row][col] is valid
    public static boolean isvalid(char[][] board, int row, int col, char c) {
        for (int i = 0; i < 9; i++) {
            // Check the column for duplicates
            if (board[i][col] == c) {
                return false;
            }
            // Check the row for duplicates
            if (board[row][i] == c) {
                return false;
            }
            // Check the 3x3 subgrid for duplicates
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) {
                return false;
            }
        }
        return true; // Safe to place the number
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 154
leetcode 36 valid sudoku
class Solution {
    // Main function to check if the entire board is valid
    public boolean isValidSudoku(char[][] board) {
        // Loop through each cell in the 9x9 board
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // If the cell is not empty ('.'), we need to validate it
                if (board[i][j] != '.') {
                    char c = board[i][j];  // Save the current cell's value
                    board[i][j] = '.';     // Temporarily empty the cell for validation

                    // Check if placing 'c' at (i, j) is valid according to Sudoku rules
                    if (!validCell(i, j, c, board))
                        return false; // If invalid, return false immediately

                    // Restore the cell's original value after validation
                    board[i][j] = c;
                }
            }
        }
        // If all cells are valid, return true
        return true;
    }

    // Helper function to validate a specific cell in the board
    public boolean validCell(int row, int col, char cell, char[][] board) {
        // Loop through the 9 positions in the row, column, and 3x3 subgrid
        for (int i = 0; i < 9; i++) {
            // Check if 'cell' exists in the current row, ignoring (row, col)
            if (board[row][i] == cell) {
                return false; // Invalid if found
            }
            // Check if 'cell' exists in the current column, ignoring (row, col)
            if (board[i][col] == cell) {
                return false; // Invalid if found
            }
            // Check if 'cell' exists in the 3x3 subgrid
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == cell) {
                return false; // Invalid if found
            }
        }
        // If no conflicts are found, the cell placement is valid
        return true;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 155
Dp question
leetcode 70
class Solution {
    public int climbStairs(int n) {
        int dp[] = new int[n+1];
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 156
leetcode 1360
class Solution {
    public int daysBetweenDates(String date1, String date2) {
        int numberOfDays1=numberOfDays(date1);
        int numberOfDays2=numberOfDays(date2);
        return Math.abs(numberOfDays2-numberOfDays1);
    }
    public int numberOfDays(String date){
        int year=Integer.parseInt(date.substring(0,4));
        int month=Integer.parseInt(date.substring(5,7));
        int day=Integer.parseInt(date.substring(8,10));

        int totaldays=0;
        for(int i=1971;i<year;i++){
            if(i%400==0 || (i%4==0 && i%100!=0)){
                totaldays+=366;
            }
            else{
                totaldays+=365;
            }
        }

        int[] months={31,28,31,30,31,30,31,31,30,31,30,31};
        for(int i=0;i<month-1;i++){
            totaldays+=months[i];
            if(i==1 && (year%400==0 || (year%4==0 && year%100!=0))){
                totaldays++;
            }
        }
        return totaldays+day;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 157   /hard
leetcode 3 Length of longest sub string without repeating letters.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        
        int res = 0; // Holds the maximum length of substring without repeating characters
        int i = 0; // Left boundary of the current substring (starting point)
        int[] vocab = new int[128]; // Array to store the last seen position of each character (ASCII based)
        
        // Loop through the string with `j` as the right boundary of the current substring
        for (int j = 0; j < s.length(); j++) {
            char ch = s.charAt(j); // Get the current character
            
            // Move `i` to the right if the current character `ch` was seen in the current window
            // `vocab[ch]` tells us the last position of `ch` + 1 (or 0 if `ch` has not been seen)
            i = Math.max(vocab[ch], i);
            
            // Calculate the length of the current substring (from `i` to `j`) and update `res` if it's the longest
            res = Math.max(res, j - i + 1);
            
            // Update the last seen position of `ch` (store `j + 1` to handle 0-based index correctly)
            vocab[ch] = j + 1;
        }
        
        return res; // Return the length of the longest substring without repeating characters
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 158
leetcode 282   /hard
class Solution 
{
    public List<String> addOperators(String s, int k) 
    {
        // Initialize the list to store valid expressions
        List<String> ans = new ArrayList<>();
        
        // Start the recursive backtracking function with initial values
        // sum, prev, and current expression (x) are initially set to 0 or empty
        find(ans, s, k, 0, 0, 0, "");
        
        return ans;
    }
    
    // Recursive function to explore possible expressions
    void find(List<String> ans, String s, int k, int i, long sum, long prev, String x)
    {
        // Base case: if we've reached the end of the string
        if (i == s.length())
        {
            // Check if the current sum equals the target k
            if (sum == k)
                ans.add(x); // If so, add this expression to the answer list
            return;
        }
        
        // Try forming numbers starting at position i
        for (int j = i; j < s.length(); j++)
        {
            // Avoid numbers with leading zeros
            if (j > i && s.charAt(i) == '0')
                break;
            
            // Convert the substring to a long integer for calculation
            long t = Long.parseLong(s.substring(i, j + 1));
            
            // If we're at the beginning of the expression
            if (i == 0)
            {
                // Start a new expression without any operator
                find(ans, s, k, j + 1, t, t, x + t);
            }
            else
            {
                // Add '+' operator and explore
                find(ans, s, k, j + 1, sum + t, t, x + "+" + t);
                
                // Add '-' operator and explore
                find(ans, s, k, j + 1, sum - t, -t, x + "-" + t);
                
                // Add '*' operator and explore
                // Update sum to account for the previous number's multiplication
                find(ans, s, k, j + 1, sum - prev + prev * t, prev * t, x + "*" + t);
            }
        }
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 159
class Solution {   
    // Main function to check if the string can be segmented based on the word dictionary
    public boolean wordBreak(String s, List<String> wordDict) {
        // Start recursion from the beginning of the string (index 0)
        return wordBreak(s, wordDict, 0);
    }

    // Recursive helper function that tries to segment the string from index si
    public boolean wordBreak(String s, List<String> wordDict, int si) {
        // Base case: if si has reached or surpassed the end of the string, return true
        if (si >= s.length()) {
            return true;
        }

        // Loop to explore every possible substring starting from index si
        for (int i = si; i < s.length(); i++) {
            // Check if the substring from si to i+1 exists in the word dictionary
            if (wordDict.contains(s.substring(si, i + 1))) {
                // If the current substring is in wordDict, recursively check the remaining string
                if (wordBreak(s, wordDict, i + 1)) {
                    return true; // If it can be segmented from here, return true
                }
            }
        }
        
        // If no valid segmentation is found, return false
        return false;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 160
Stack class implementing stack using a single queue
import java.util.LinkedList;
import java.util.Queue;
public class Tuf {
    public static void main(String[] args) {
        Stack s = new Stack();
        s.push(3);
        s.push(2);
        s.push(4);
        s.push(1);
        
        System.out.println("Top of the stack: " + s.top());
        System.out.println("Size of the stack before removing element: " + s.size());
        System.out.println("The deleted element is: " + s.pop());
        System.out.println("Top of the stack after removing element: " + s.top());
        System.out.println("Size of the stack after removing element: " + s.size());
    }
}

// Stack class implementing stack using a single queue
class Stack {
    // Queue to hold stack elements
    Queue<Integer> q = new LinkedList<>();
    
    // Push an element to the stack
    void push(int x) {
        // Add the new element to the queue
        q.add(x);
        
        // Rotate the queue to move the newly added element to the front
        // This ensures the LIFO behavior as the last added element becomes the "top"
        for (int i = 0; i < q.size() - 1; i++) {
            // Remove and re-add each element except the last one added
            q.add(q.remove());
        }
    }
    
    // Pop the top element from the stack
    int pop() {
        // Remove and return the front element of the queue, which is the "top" of the stack
        return q.remove();
    }
    
    // Get the top element of the stack without removing it
    int top() {
        // Peek at the front of the queue, representing the stack's top element
        return q.peek();
    }
    
    // Get the number of elements in the stack
    int size() {
        return q.size();
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 161
leetcode 20
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.pop();
                if ((c == ')' && top != '(') || 
                    (c == '}' && top != '{') || 
                    (c == ']' && top != '[')) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 162
leetcode 155 minstack
class MinStack {
    int min = Integer.MAX_VALUE;
    Stack<Integer> stack = new Stack<Integer>();
    public void push(int x) {
        // only push the old minimum value when the current 
        // minimum value changes after pushing the new value x
        if(x <= min){          
            stack.push(min);
            min=x;
        }
        stack.push(x);
    }

    public void pop() {
        // if pop operation could result in the changing of the current minimum value, 
        // pop twice and change the current minimum value to the last minimum value.
        if(stack.pop() == min) min=stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return min;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 163
infix to postfix
class GfG {
    
    // Function to return precedence of operators
    int prec(char c) {
        if (c == '^')
            return 3;
        else if (c == '/' || c == '*')
            return 2;
        else if (c == '+' || c == '-')
            return 1;
        else
            return -1;
    }

    // Function to perform infix to postfix conversion
    void infixToPostfix(String s) {
        Stack<Character> st = new Stack<>();
        String result = "";

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            // If the scanned character is an operand, add it to the output string.
            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
                result += c;

            // If the scanned character is â€˜(â€˜, push it to the stack.
            else if (c == '(')
                st.push('(');

            // If the scanned character is an â€˜)â€™, pop and add to the output string from the stack until an â€˜(â€˜ is encountered.
            else if (c == ')') {
                while (st.peek() != '(') {
                    result += st.pop();
                }
                st.pop();
            }

            // If an operator is scanned
            else {
                while (!st.isEmpty() && (prec(c) < prec(st.peek()) || prec(c) == prec(st.peek()))) {
                    result += st.pop();
                }
                st.push(c);
            }
        }

        // Pop all the remaining elements from the stack
        while (!st.isEmpty()) {
            result += st.pop();
        }

        System.out.println(result);
    }

    public static void main(String[] args) {
        GfG gfg = new GfG();
        String exp = "a+b*(c^d-e)^(f+g*h)-i";
        gfg.infixToPostfix(exp);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 164
prefix to infix

class GFG{

// Function to check if character
// is operator or not     
static    boolean isOperator(char x) 
{
    switch(x)
    {
        case '+':
        case '-':
        case '*':
        case '/':
        case '^':
        case '%':
            return true;
    }
    return false;
}

// Convert prefix to Infix expression 
public static String convert(String str)
{
    Stack<String> stack = new Stack<>();
    
    // Length of expression 
    int l = str.length();
    
    // Reading from right to left 
    for(int i = l - 1; i >= 0; i--)
    {
        char c = str.charAt(i);
        if (isOperator(c))
        {
            String op1 = stack.pop();
            String op2 = stack.pop();
            
            // Concat the operands and operator 
            String temp = "(" + op1 + c + op2 + ")";
            stack.push(temp);
        } 
        else
        {
            
            // To make character to string
            stack.push(c + ""); 
        }
    }
    return stack.pop();
}

// Driver code
public static void main(String[] args)
{
    String exp = "*-A/BC-/AKL";
    System.out.println("Infix : " + convert(exp));
}
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 165
prefix to postfix
class GFG {
 
    static boolean isOperator(char x)
    {
        switch (x) {
        case '+':
        case '-':
        case '/':
        case '*':
            return true;
        }
        return false;
    }
 
    // Convert prefix to Postfix expression
    static String preToPost(String pre_exp)
    {
 
        Stack<String> s = new Stack<String>();
 
        // length of expression
        int length = pre_exp.length();
 
        // reading from right to left
        for (int i = length - 1; i >= 0; i--) 
        {
            // check if symbol is operator
            if (isOperator(pre_exp.charAt(i))) 
            {
                // pop two operands from stack
                String op1 = s.peek();
                s.pop();
                String op2 = s.peek();
                s.pop();
 
                // concat the operands and operator
                String temp = op1 + op2 + pre_exp.charAt(i);
 
                // Push String temp back to stack
                s.push(temp);
            }
 
            // if symbol is an operand
            else {
                // push the operand to the stack
                s.push(pre_exp.charAt(i) + "");
            }
        }
 
        // stack contains only the Postfix expression
        return s.peek();
    }
 
    // Driver Code
    public static void main(String args[])
    {
        String pre_exp = "*-A/BC-/AKL";
        System.out.println("Postfix : "
                           + preToPost(pre_exp));
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
 question 166
postfix to prefix
class GFG {
 
    // function to check if character
    // is operator or not
    static boolean isOperator(char x)
    {
 
        switch (x) {
        case '+':
        case '-':
        case '/':
        case '*':
            return true;
        }
        return false;
    }
 
    // Convert postfix to Prefix expression
    static String postToPre(String post_exp)
    {
        Stack<String> s = new Stack<String>();
 
        // length of expression
        int length = post_exp.length();
 
        
        for (int i = 0; i < length; i++) {
 
            // check if symbol is operator
            if (isOperator(post_exp.charAt(i))) {
 
                // pop two operands from stack
                String op1 = s.peek();
                s.pop();
                String op2 = s.peek();
                s.pop();
 
                // concat the operands and operator
                String temp
                    = post_exp.charAt(i) + op2 + op1;
 
                // Push String temp back to stack
                s.push(temp);
            }
 
            // if symbol is an operand
            else {
 
                // push the operand to the stack
                s.push(post_exp.charAt(i) + "");
            }
        }
 
        // concatenate all strings in stack and return the
        // answer
        String ans = "";
        for (String i : s)
            ans += i;
        return ans;
    }
 
    // Driver Code
    public static void main(String args[])
    {
        String post_exp = "ABC/-AK/L-*";
 
        // Function call
        System.out.println("Prefix : "
                           + postToPre(post_exp));
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 167
postfix to infix
class GFG
{
     
static boolean isOperand(char x)
{
    return (x >= 'a' && x <= 'z') ||
            (x >= 'A' && x <= 'Z');
}
 
// Get Infix for a given postfix
// expression
static String getInfix(String exp)
{
    Stack<String> s = new Stack<String>();
 
    for (int i = 0; i < exp.length(); i++)
    {
        // Push operands
        if (isOperand(exp.charAt(i)))
        {
        s.push(exp.charAt(i) + "");
        }
 
        // We assume that input is
        // a valid postfix and expect
        // an operator.
        else
        {
            String op1 = s.peek();
            s.pop();
            String op2 = s.peek();
            s.pop();
            s.push("(" + op2 + exp.charAt(i) +
                    op1 + ")");
        }
    }
 
    // There must be a single element
    // in stack now which is the required
    // infix.
    return s.peek();
}
 
// Driver code
public static void main(String args[])
{
    String exp = "ab*c+";
    System.out.println( getInfix(exp));
}
}
 -----------------------trust the process you will win. brute force pannale optimize pannirlam
question 168
leetcode 496
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap<Integer,Integer> hs = new HashMap();
        Stack<Integer> stack = new Stack();// inga namaku theva greater elements dhaan so  current element stack oda top vida perusa irundha 
       // remove panni hasmap la current element kuda map pannu 
        for(Integer num : nums2){
            while(!stack.isEmpty() && stack.peek() < num){ //decreasing order..
                hs.put(stack.pop(), num);
            }
            stack.push(num);
        }
        
        for(int i=0;i<nums1.length;i++){
            nums1[i] = hs.getOrDefault(nums1[i],-1);
        }
        return nums1;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 169
leetcode 503
class Solution {//it is circular
    public int[] nextGreaterElements(int[] nums) {
        //inga namaku greater elements dhaan theva stack la full ah upload pantu curr element ah vida kammiya irundha pop pannu until it finds max one.
        Stack<Integer> stack=new Stack<>();
        for(int i=nums.length-1;i>=0;i--){
            stack.push(nums[i]);
        }
        
        for(int i=nums.length-1;i>=0;i--){
            int number=nums[i];
                while(!stack.isEmpty() && stack.peek()<=nums[i]){  // decreasing order
                    stack.pop();
                }
           
            nums[i]=stack.empty()?-1:stack.peek();
            stack.push(number);
        }
        
        return nums;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 170
Infix to prefix
public class InfixToPrefix {
    // Method to reverse a string and swap parentheses
    static String reverseExpression(String expression) {
        StringBuilder result = new StringBuilder();
        for (int i = expression.length() - 1; i >= 0; i--) {
            char ch = expression.charAt(i);
            if (ch == '(') {
                result.append(')');
            } else if (ch == ')') {
                result.append('(');
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    // Convert infix expression to postfix
   
    // Main method to convert infix to prefix
    public static String infixToPrefix(String expression) {
        // Step 1: Reverse the infix expression and replace parentheses
        String reversedExpression = reverseExpression(expression);
        
        // Step 2: Get postfix of the reversed expression
        String postfix = infixToPostfix(reversedExpression);

        // Step 3: Reverse the postfix expression to get the prefix expression
        return new StringBuilder(postfix).reverse().toString();
    }

    public static void main(String[] args) {
        String infixExpression = "(A-B/C)*(A/K-L)";
        String prefixExpression = infixToPrefix(infixExpression);
        System.out.println("Infix Expression: " + infixExpression);
        System.out.println("Prefix Expression: " + prefixExpression);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 171
Previous smaller element
NInput 1:
    A = [4, 5, 2, 10, 8]
Output 1:
    G = [-1, 4, -1, 2, 2]   /// idhula namaku small elements dhaan so curr element ah vida top of stack persa irundha remove pannu util small pakkura varaikum

public class Solution {

    public int[] prevSmaller(int[] A) {

        Stack<Integer> st = new Stack<>();

        int [] arr = new int[A.length];

        for(int i=0;i<A.length;i++){
            while(!st.isEmpty() && st.peek()>=A[i]){   //stack is in increasing order..
                st.pop();
            }
            if(!st.isEmpty()){
                arr[i] = st.peek();
            }else{
                arr[i]= -1;
            }
            st.push(A[i]);
        }    
return arr;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 172
leetcode 42  Rainwater Trapping
class Solution {
    public int trap(int[] height) {
        int water = 0;  // This variable stores the total trapped water.
        int lmax = 0, rmax = 0;  // lmax and rmax are the tallest bars we've seen so far from the left and right.
        int left = 0, right = height.length - 1;  // Left and right pointers start at the ends of the array.
        
        // Loop until the left pointer meets the right pointer
        while (left < right) {
            // If the left bar is shorter than the right bar
            if (height[left] < height[right]) {
                // Check if the current left bar can trap water
                if (lmax > height[left]) {
                    // Water can be trapped, add the difference between lmax and the current left bar
                    water += lmax - height[left];
                } else {
                    // Update lmax to the current left bar if it's the highest we've seen from the left
                    lmax = height[left];
                }
                // Move the left pointer to the right
                left++;
            } else {
                // If the right bar is shorter or equal, we check the right side
                if (rmax > height[right]) {
                    // Water can be trapped, add the difference between rmax and the current right bar
                    water += rmax - height[right];
                } else {
                    // Update rmax to the current right bar if it's the highest we've seen from the right
                    rmax = height[right];
                }
                // Move the right pointer to the left
                right--;
            }
        }
        
        return water;  // Return the total trapped water
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 173
leetcode 907
class Solution  extends HelperMethod{ // inherit the class 
    public int sumSubarrayMins(int[] arr) {
        
        HelperMethod help = new HelperMethod(); // object of helper fun to access the method.
        
        int[] nextSE = help.nextSmaller(arr);
        int[] prevSE = help.previousSmaller(arr);
        long total = 0;
        int mod = (int)(1e9+7);

        for (int i = 0; i < arr.length; i++) {
            int left = i - prevSE[i];
            int right = nextSE[i] - i;

            total = (total + (long)left * right * arr[i]) % mod;
        }
        return (int) total;
    }

}

//purpose of creating another class just coz of organized the code..

class HelperMethod{
    // Find the next smaller element
    public int[] nextSmaller(int[] arr) {
        int n = arr.length;
        int[] nse = new int[n];
        Stack<Integer> stk = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stk.isEmpty() && arr[stk.peek()] > arr[i]) {
                stk.pop();
            }
            nse[i] = (stk.isEmpty()) ? n : stk.peek();
            stk.push(i);
        }
        return nse;
    }

    // Find the previous smaller element
    public int[] previousSmaller(int[] arr) {
        int n = arr.length;
        int[] pse = new int[n];
        Stack<Integer> stk = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!stk.isEmpty() && arr[stk.peek()] >= arr[i]) {
                stk.pop();
            }
            pse[i] = (stk.isEmpty()) ? -1 : stk.peek();
            stk.push(i);
        }
        return pse;
    }
}
    
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 174
leetcode 63 unique paths 2

class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length;  // Get the number of rows
        int m = obstacleGrid[0].length;  // Get the number of columns

        int[][] dp = new int[n][m];  // Create a dp array to store the number of ways to reach each cell
        dp[0][0] = 1;  // Start by assuming 1 way to reach the starting point (top-left corner)

        // Loop through each cell in the grid
        for (int i = 0; i < n; i++) {  // Row loop
            for (int j = 0; j < m; j++) {  // Column loop
                if (obstacleGrid[i][j] == 1) {  // If there's an obstacle at (i, j), set dp[i][j] to 0
                    dp[i][j] = 0;  // No path to this cell because it's blocked
                } else {
                    // If the current cell isn't blocked, check the cell above it (if i > 0)
                    if (i > 0) {
                        dp[i][j] += dp[i - 1][j];  // Add the number of ways from the cell above
                    }
                    // Check the cell to the left of it (if j > 0)
                    if (j > 0) {
                        dp[i][j] += dp[i][j - 1];  // Add the number of ways from the cell to the left
                    }
                }
            }
        }

        // Return the value at the bottom-right corner, which holds the total number of unique paths
        return dp[n - 1][m - 1];
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 175
leetcode 402
class Solution {
    public String removeKdigits(String num, int k) {
        if(num.length() == k) return "0";
        
        Stack<Integer> stack = new Stack<>();
        for(char c : num.toCharArray()){
            int digit = c - '0';

            while(!stack.isEmpty() && stack.peek() > digit && k > 0){
                k--;
                stack.pop();
            }

            if(stack.isEmpty() && digit == 0){
                continue;
            }
            
            stack.push(digit);
        }

        StringBuilder sb = new StringBuilder();

        while(!stack.isEmpty()){
            if(k > 0){
                stack.pop();
                k--;
                continue;
            }
            sb.append(stack.pop());
        }

        return sb.length() == 0 ? "0" : sb.reverse().toString();          
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 176
leetcode 735
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        int n = asteroids.length;
        Stack<Integer> s = new Stack<>();
        for (int i = 0; i < n; i++) {
            if (asteroids[i] > 0 || s.isEmpty()) {
                s.push(asteroids[i]);
            } else {
                while (!s.isEmpty() && s.peek() > 0 && s.peek() < Math.abs(asteroids[i])) {
                    s.pop();
                }
                if (!s.isEmpty() && s.peek() == Math.abs(asteroids[i])) {
                    s.pop();
                } else {
                    if (s.isEmpty() || s.peek() < 0) {
                        s.push(asteroids[i]);
                    }
                }
            }
        }
        int[] res = new int[s.size()];
        for (int i = s.size() - 1; i >= 0; i--) {
            res[i] = s.pop();
        }
        return res;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 177
leetcode 146
public class Pair {
    int key;
    int val;
    Pair(int k, int v) {
        this.key = k;
        this.val = v;
    }
}

class LRUCache {
    
    Queue<Pair> q = new LinkedList<>();
    Map<Integer, Pair> m = new HashMap<>();
    int cap;
    public LRUCache(int capacity) {
        this.cap = capacity;
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            Pair p = m.get(key);
            q.remove(p);
            q.add(p);
            return m.get(key).val;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if(!m.containsKey(key)) {
            if(q.size() == cap) {
                Pair p = q.poll();
                m.remove(p.key);
            }
        } else {
            q.remove(m.get(key));
        }
        Pair p = new Pair(key, value);
        q.add(p);
        m.put(key, p);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 178
leetcode 2104
class Solution {
    public long subArrayRanges(int[] nums) {
        long sum = 0; // Final result (difference between max and min sums)
        int length = nums.length;
        
        // Arrays to store indices for Previous Smaller Element (PSE) and Next Smaller Element (NSE)
        int[] pse = new int[length];
        int[] nse = new int[length];

        Stack<Integer> stack = new Stack<>();

        // Step 1: Compute NSE (Next Smaller Element)
        for (int i = length - 1; i >= 0; i--) {
            // Remove larger or equal elements from the stack
            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i])
                stack.pop();
            // If stack is empty, NSE is length; otherwise, top of the stack
            nse[i] = stack.isEmpty() ? length : stack.peek();
            stack.push(i); // Push current index to the stack
        }

        stack = new Stack<>();

        // Step 2: Compute PSE (Previous Smaller Element)
        for (int i = 0; i < length; i++) {
            // Remove larger elements from the stack
            while (!stack.isEmpty() && nums[stack.peek()] > nums[i])
                stack.pop();
            // If stack is empty, PSE is -1; otherwise, top of the stack
            pse[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i); // Push current index to the stack
        }

        long sumOfSubarrayMinimums = 0;

        // Calculate contribution of each element as a minimum in subarrays
        for (int i = 0; i < length; i++) {
            long cntLeft = i - pse[i]; // Count of subarrays ending at i
            long cntRight = nse[i] - i; // Count of subarrays starting at i
            sumOfSubarrayMinimums += cntLeft * cntRight * nums[i]; // Contribution to the sum
        }

        // Arrays to store indices for Previous Greater Element (PGE) and Next Greater Element (NGE)
        int[] pge = new int[length];
        int[] nge = new int[length];

        stack = new Stack<>();

        // Step 3: Compute NGE (Next Greater Element)
        for (int i = length - 1; i >= 0; i--) {
            // Remove smaller or equal elements from the stack
            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i])
                stack.pop();
            // If stack is empty, NGE is length; otherwise, top of the stack
            nge[i] = stack.isEmpty() ? length : stack.peek();
            stack.push(i); // Push current index to the stack
        }

        stack = new Stack<>();

        // Step 4: Compute PGE (Previous Greater Element)
        for (int i = 0; i < length; i++) {
            // Remove smaller elements from the stack
            while (!stack.isEmpty() && nums[stack.peek()] < nums[i])
                stack.pop();
            // If stack is empty, PGE is -1; otherwise, top of the stack
            pge[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i); // Push current index to the stack
        }

        long sumOfSubarrayMaximums = 0;

        // Calculate contribution of each element as a maximum in subarrays
        for (int i = 0; i < length; i++) {
            long cntLeft = i - pge[i]; // Count of subarrays ending at i
            long cntRight = nge[i] - i; // Count of subarrays starting at i
            sumOfSubarrayMaximums += cntLeft * cntRight * nums[i]; // Contribution to the sum
        }

        // Return the difference between maximum and minimum sums
        return sumOfSubarrayMaximums - sumOfSubarrayMinimums;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 179
leetcode 84
class Solution {
    public int largestRectangleArea(int[] arr) {
        int max =0;
        int nsr [] = new int[arr.length];
        int nsl [] = new int[arr.length];

        //next smaller element to right
        Stack<Integer> stack = new Stack<>();
        for(int i=arr.length-1;i>=0;i--){
            while(!stack.isEmpty() && arr[stack.peek()] >= arr[i] ){
                stack.pop();
            }
            if(stack.isEmpty()){
                nsr[i]= arr.length;
            }else{
                nsr[i] = stack.peek();
            }
            stack.push(i);
        }
        //next smaller element to left
        stack = new Stack<>();
        for(int i=0;i<arr.length;i++){
            while(!stack.isEmpty() && arr[stack.peek()] >= arr[i] ){
                stack.pop();
            }
            if(stack.isEmpty()){
                
                nsl[i]= -1;
            }else{
                nsl[i] = stack.peek();
            }
            stack.push(i);
        }
        // current area
        for(int i=0;i<arr.length;i++){
            int area = arr[i] * (nsr[i] - nsl[i] - 1);
            max = Math.max(area,max);
        }
        return max;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 180
leetcode 85
class Solution {
    private int hist(int[] heights) {
        int n = heights.length;
        int maxArea = 0;
        int element,nse,pse;
        Stack<Integer> s = new Stack<>();
        for(int i=0;i<n;i++){
            while(!s.isEmpty() && heights[s.peek()] > heights[i]){
                element = s.pop();
                nse = i;
                pse = s.isEmpty() ? -1 : s.peek();

                maxArea = Math.max(maxArea, (nse-pse-1)*heights[element]);
            }
            s.push(i);
        }
        while(!s.isEmpty()){
            nse = n;
            element = s.pop();
            pse = s.isEmpty() ? -1 : s.peek();

            maxArea = Math.max(maxArea, (nse-pse-1)*heights[element]);
        }
        return maxArea;
    }
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int maxArea = 0;
        int arr[] = new int[m];
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(matrix[i][j]=='0') arr[j] = 0;
                else arr[j] = arr[j]+1;
            }
            maxArea = Math.max(maxArea,hist(arr));
        }
        return maxArea;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 181
leetcode 239
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // Edge case: If input array is null or window size is invalid, return an empty array.
        if (nums == null || k <= 0) return new int[0];
        
        int n = nums.length; // Total number of elements in the input array.
        int[] result = new int[n - k + 1]; // Array to store the maximums of each sliding window.
        Deque<Integer> deque = new LinkedList<>(); // Double-ended queue to store indices of elements.

        // Iterate through each element in the array.
        for (int i = 0; i < n; i++) {
            // Remove indices from the front of the deque that are outside the current window.
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst(); // Remove the element that's out of range.
            }
            
            // Remove indices from the back of the deque if the corresponding element is smaller 
            // than the current element because they cannot be the maximum for this or future windows.
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast(); // Remove smaller elements.
            }
            
            // Add the current index to the deque.
            deque.offerLast(i);
            
            // Once the first window is fully formed (i >= k - 1), add the maximum of the window 
            // (element at the front of the deque) to the result array.
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()]; // Maximum of the current window.
            }
        }
        
        return result; // Return the array of maximums for each sliding window.
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 182
leetcode 901
class StockSpanner {

    Stack<int[]> st; // Stack to store pairs of (price, span).

    // Constructor to initialize the stack.
    public StockSpanner() {
        st = new Stack<>();
    }

    // Method to calculate the span of the current stock price.
    public int next(int price) {
        
        int span = 1; // Start with a span of 1 for the current day (at least the price itself).

        // While the stack is not empty and the current price is greater than or equal to 
        // the price at the top of the stack:
        while(st.size() > 0 && price >= st.peek()[0]) {
            // Add the span of the price at the top of the stack to the current span.
            // This effectively merges the spans of all smaller or equal prices.
            span += st.pop()[1];
        }
        
        // Push the current price and its calculated span onto the stack.
        st.push(new int[]{price, span});
        
        // Return the span of the current price.
        return span;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 183
Bfs and dfs in tree

    public void dfs(TreeNode node) {
        if (node == null) return;

        // Process the current node
        System.out.println("Visited: " + node.value);

        // Recur for the left and right children
        dfs(node.left);
        dfs(node.right);
    }

class TreeNode {
    int value;
    TreeNode left, right;

    public TreeNode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

public class TreeTraversal {

    // Method to calculate the height of the tree
    public int getHeight(TreeNode root) {
        if (root == null) return 0;
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }

    // Print all nodes at a given level
    public void printLevel(TreeNode root, int level) {
        if (root == null) return;
        if (level == 1) {
            System.out.println("Visited: " + root.value);
        } else if (level > 1) {
            printLevel(root.left, level - 1);
            printLevel(root.right, level - 1);
        }
    }

    // BFS Traversal using recursion
    public void bfs(TreeNode root) {
        int height = getHeight(root);
        for (int level = 1; level <= height; level++) {
            printLevel(root, level);
        }
    }

-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 184
leetcode 102
//bfs
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> nodes = new LinkedList<>();
        List<List<Integer>> result = new ArrayList<>();
        if(root==null) return result;
        nodes.offer(root);//offer return true or false but add return exception if its gets error
        while(!nodes.isEmpty()){
            List<Integer> levelNodes = new ArrayList<>();
            int size = nodes.size();
            for(int i=0;i<size;i++){
                TreeNode node = nodes.poll();
                levelNodes.add(node.val);
                if(node.left !=null) nodes.offer(node.left);
                if(node.right!=null) nodes.offer(node.right);
            }
            result.add(levelNodes);
        }
        return result;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 185
leetcode104   //height or max depth of binary tree
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left,right)+1;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 186
leetcode 110
class Solution {
    private boolean flag;
    
    public boolean isBalanced(TreeNode root) {
        flag = true;
        height(root);
        return flag;
    }
    
    private int height(TreeNode n){
        if(n == null) return 0;
        
        int num1 = height(n.left);
        int num2 = height(n.right);
        int res = num1 - num2;
        
        if(res > 1 || res < -1){
            flag = false;
        }
        
        return Math.max(num1,num2) + 1;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 187
leetcode 543
class Solution {
    private int maxDiameter =0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxDiameter;
    }
    private int depth(TreeNode root){
        if(root==null)
            return -1;
        int left = depth(root.left);
        int right = depth(root.right);
        maxDiameter = Math.max(maxDiameter,left+right+2);

        return Math.max(left,right)+1;
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 188
leetcode 124
class Solution {
    private int maxSum;
    public int maxPathSum(TreeNode root){
        maxSum = Integer.MIN_VALUE;
        maxPathSum1(root);
        return maxSum;
    }
    public int maxPathSum1(TreeNode root) {
        if(root == null) return 0;

        int leftSum = Math.max(0,maxPathSum1(root.left));
        int rightSum = Math.max(0,maxPathSum1(root.right));

        int currentSum = root.val + leftSum+rightSum;

        maxSum = Math.max(currentSum,maxSum);
        return root.val+Math.max(leftSum,rightSum);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 189
leetcode 100
class Solution {
   public boolean isSameTree(TreeNode p, TreeNode q) {
        return solve(p, q);
    }

    private boolean solve(TreeNode p, TreeNode q) {
        if (p == null && q == null)
            return true;

        if (p == null || q == null || p.val != q.val)
            return false;

        return solve(p.left, q.left) && solve(p.right, q.right);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 190
leetcode 103
 class Solution {
    private List<List<Integer>> res;

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        res = new ArrayList<>();
        traverse(root, 0);
        return res;
    }

    private void traverse(TreeNode root, int index) {
        if (root == null) {
            return;
        }
        if (index >= res.size()) {
            res.add(new ArrayList<>());
        }

        var curr = (ArrayList<Integer>) res.get(index);
        if (index % 2 == 0) {
            curr.add(root.val);
        } else {
            curr.addFirst(root.val);
        }

        traverse(root.left, index + 1);
        traverse(root.right, index + 1);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 191
leetcode 101
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return (root==null) || (isSymmetric(root.left,root.right)) ;
    }
    private  boolean isSymmetric(TreeNode left, TreeNode right) {
        if (left==null || right==null){
            return left==right;
        }
        if (left.val!=right.val){
            return false;
        }
        return isSymmetric(left.left,right.right)&& isSymmetric(left.right,right.left);
    }

}
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 192
// Pair class to store a node and its vertical position
class Pair {
    private Node key; // Node of the binary tree
    private int value; // Vertical position of the node

    // Constructor
    public Pair(Node key, int value) {
        this.key = key;
        this.value = value;
    }

    // Getters
    public Node getKey() {
        return key;
    }

    public int getValue() {
        return value;
    }
}

// Main Solution class
public class Solution {
    // Function to return the
    // top view of the binary tree
    public List<Integer> topView(Node root) {
        // List to store the result
        List<Integer> ans = new ArrayList<>();
        
        // Check if the tree is empty
        if (root == null) {
            return ans;
        }
        
        // Map to store the top view nodes
        // based on their vertical positions
        Map<Integer, Integer> mpp = new TreeMap<>();
        
        // Queue for BFS traversal, each element
        // is a pair containing node 
        // and its vertical position
        Queue<Pair> q = new LinkedList<>();
        
        // Push the root node with its vertical
        // position (0) into the queue
        q.add(new Pair(root, 0));
        
        // BFS traversal
        while (!q.isEmpty()) {
            // Retrieve the node and its vertical
            // position from the front of the queue
            Pair pair = q.poll();
            Node node = pair.getKey();
            int line = pair.getValue();
            
            // If the vertical position is not already
            // in the map, add the node's data to the map
            if (!mpp.containsKey(line)) {
                mpp.put(line, node.data);
            }
            
            // Process left child
            if (node.left != null) {
                // Push the left child with a decreased
                // vertical position into the queue
                q.add(new Pair(node.left, line - 1));
            }
            
            // Process right child
            if (node.right != null) {
                // Push the right child with an increased
                // vertical position into the queue
                q.add(new Pair(node.right, line + 1));
            }
        }
        
        // Transfer values from the
        // map to the result list
        for (int value : mpp.values()) {
            ans.add(value);
        }
        
        return ans;
    }
}

A TreeMap in Java is a type of map (key-value pairs) where all the keys are sorted in natural order (e.g., ascending for numbers,
alphabetical for strings). It uses a binary search tree internally to maintain this sorted order.

Key Features:
Stores Key-Value Pairs: Just like a HashMap, but keys are always sorted.
Sorting: Keys are sorted automatically when you add them.
No Duplicates: Keys must be unique (values can be duplicates).
-----------------------trust the process you will win. brute force pannale optimize pannirlam
question 193
 leetcode 199
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();

        rightView(root, ans, 0);

        return ans;
    }

    private void rightView(TreeNode curr, List<Integer> ans, int currDepth) {
        if (curr == null)
            return;

        if (currDepth == ans.size())
            ans.add(curr.val);

        rightView(curr.right, ans, currDepth + 1);
        rightView(curr.left, ans, currDepth + 1);
    }
}
-----------------------trust the process you will win. brute force pannale optimize pannirlam

