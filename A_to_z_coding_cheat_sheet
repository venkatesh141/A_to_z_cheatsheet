A_to_z_coding_cheat_sheet


patterns  -->
   
-----------------------trust the process you will win.
Input Format: N = 6  ques 1
Result:   
1          1
12        21
123      321
1234    4321
12345  54321
123456654321


solution

    
static void pattern(int n)
{
	int spaces = 2*(n-1);

	for(int i=1;i<=n;i++)
	{

		for(int j=1;j<=i;j++)
		{
			System.out.print(j);
		}
        for(int j=1;j<=spaces;j++)
        {
        	System.out.print(" ");
        } 

        for(int j=i;j>=1;j--)
        {
        	System.out.print(j);
        }
        System.out.println();
        spaces-=2;

	}
}
end
-----------------------trust the process you will definitely win.

  int n=6   ques 2

     A     
    ABA    
   ABCBA   
  ABCDCBA  
 ABCDEDCBA 
ABCDEFEDCBA
    
solution

public static void pattern(int n)
{
	for(int i=0;i<n;i++)
		{
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}

			char ch='A';
			int breakpoint = (2*i+1)/2;
			for(int j=1;j<=2*i+1;j++)
			{
				System.out.print(ch);
				if(j<=breakpoint)
					ch++;
				else
					ch--;
			}
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}
			System.out.println();

		}
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6   ques 3
Result:   
************
*****  *****
****    ****
***      ***
**        **
*          *
*          *
**        **
***      ***
****    ****
*****  *****
************


public static void pat(int n)
{
    int spaces=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        spaces+=2;
        System.out.println();
    }
    spaces = 2*n-2;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        spaces-=2;
        System.out.println();
    }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 3 ques 4
Result: 
*    *
**  **
******
**  **
*    *

public static void pattern(int n)
{
int spaces = 2*n-2;
      
      // Outer loop for printing row.
      for(int i = 1;i<=2*n-1;i++){
          
          // stars for first half
          int stars = i;
          
          // stars for the second half.
          if(i>n) stars = 2*n - i;
          
          //for printing the stars
          for(int j=1;j<=stars;j++){
              System.out.print("*");
          }
          
          //for printing the spaces
          for(int j = 1;j<=spaces;j++){
              System.out.print(" ");
          }
          
          //for printing the stars
          for(int j = 1;j<=stars;j++){
              System.out.print("*");
          }
          
          // As soon as the stars for each iteration are printed, we move to the
          // next row and give a line break otherwise all stars
          // would get printed in 1 line.
          System.out.println();
          if(i<n) spaces -=2;
          else spaces +=2;
      }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6 ques 5
Result:   
******
*    *
*    *
*    *
*    *
******

public static void fun(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 || j==0 || i==n-1 || j==n-1)
            {
                System.out.print("*");
            }
            else
            {
                System.out.print(" ");
            }
            
        }
        System.out..println();
    }
}
end
----------------------trust the process you will definitely win

Input Format: N = 3 ques 6
Result: 
3 3 3 3 3 
3 2 2 2 3 
3 2 1 2 3 
3 2 2 2 3 
3 3 3 3 3

static void pattern22(int n)
{
      
      for(int i=0;i<2*n-1;i++){
         for(int j=0;j<2*n-1;j++){
             
             
             int top = i;
             int bottom = j;
             int right = (2*n - 2) - j;
             int left = (2*n - 2) - i;
             System.out.print(n- Math.min(Math.min(top,bottom), Math.min(left,right)) + " ");
         }
           System.out.println();
     }
}
end
----------------------trust the process you will definitely win
 square root of a number optimized approach ques 7

public static int floor(int n)
{
    int res=1,i=1;
    while(res<=n)
    {
        i++;
        res=i*i;
    }
    return i-1;
}
end
----------------------trust the process you will definitely win
ques 8

 find missing number
 int ans=0;
      int n=nums.length;
        int sum=(n*(n+1))/2;
        for(int i=0;i<n;i++)
        {
            ans+=nums[i];
        }
        return sum-ans;
    end
----------------------trust the process you will definitely win
question 9

  sort colors
  
  st=0,mid=0,end=n-1;
  if(n==1)->return;
  while(mid<=end)
  {
     if(arr[mid]==2)
     {
           swap(arr[mid],arr[end])
           end--;
     }
     else if(arr[mid]==0)
     {
          swap(arr[mid],arr[st])
          st++;
          mid++;
     }
     else
     {
         mid++;
     }  
  }
  end

----------------------trust the process you will definitely win
question 10
check if two arrays are equal are not
public static boolean check(int[] arr1, int[] arr2) {
        // Your code here
        int n1=arr1.length;
        int n2=arr2.length;
        if(n1!=n2)
          return false;
         for(int i=0;i<n1;i++)
         {
             for(int j=0;j<n2;j++)
             {
                 if(arr2[j]==Integer.MIN_VALUE)
                 continue;
                 
                 if(arr1[i]==arr2[j])
                 {
                     arr2[j]=Integer.MIN_VALUE;
                     break;
                 }
             }
         }
         for(int i=0;i<n2;i++)
         {
             if(arr2[i]!=Integer.MIN_VALUE)
               return false;
         }
         return true;
         
    }
end
----------------------trust the process you will definitely win
question 11 merge sort 

   public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Base case: array is already sorted if it has one or zero elements
        }
        
        int mid = array.length / 2;
        int[] left = new int[mid];
        int[] right = new int[array.length - mid];
        System.arraycopy(array, 0, left, 0, mid);
        System.arraycopy(array, mid, right, 0, array.length - mid);
        mergeSort(left);
        mergeSort(right);
        merge(array, left, right);
    }
    
   
    private static void merge(int[] array, int[] left, int[] right) {
        int leftIndex = 0, rightIndex = 0, arrayIndex = 0;
        
   
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] <= right[rightIndex]) {
                array[arrayIndex++] = left[leftIndex++];
            } else {
                array[arrayIndex++] = right[rightIndex++];
            }
        }
        
   
        while (leftIndex < left.length) {
            array[arrayIndex++] = left[leftIndex++];
        }
        
   
        while (rightIndex < right.length) {
            array[arrayIndex++] = right[rightIndex++];
        }
    }
end
----------------------trust the process you will definitely win
question 12 bubble sort

    private static void bubbleSortRecursive(int[] array, int n) {
        
        if (n == 1) {
            return;
        }
        
        
        for (int i = 0; i < n - 1; i++) {
            if (array[i] > array[i + 1]) {
                // Swap the elements if they are in the wrong order
                int temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        
        
        bubbleSortRecursive(array, n - 1);
    }
end
----------------------trust the process you will definitely win
qusstion 13 insertion sort 

 public static void insertionSort(int[] arr, int n) {
        if (n <= 1) {
            return;
        }

        // Insert the nth element into its correct position first (out of order)
        int last = arr[n - 1];
        int j = n - 2;

        while (j >= 0 && arr[j] > last) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = last;

        // Recursively sort the first n-1 elements (after insertion, which is incorrect)
        insertionSort(arr, n - 1);
    }
----------------------trust the process you will definitely win
Implementation of linked list question 14

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

        public void append(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            return;
        }

        Node last = head;
        while (last.next != null) {
            last = last.next;
        }

        last.next = newNode;
    }

    public void delete(int ele)
    {
        if(head!=null && head.data==ele)
         {
             head=head.next;
             return;
         }
         Node current=head;
         Node previous=null;
         while(current!=null && current.data!=ele)
         {
           previous=current;
           current=current.next;
          }
          if(current==null)
          {
             System.out.pritnln("element is not found");
             return;
          }
          previous.next=current.next;
         
    }

    // Method to display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        linkedList.append(1);
        linkedList.append(2);
        linkedList.append(3);

        System.out.print("Linked List: ");
        linkedList.display();
    }
}
----------------------trust the process you will definitely win
stack implementation question 15

public class Stack {
     int maxSize; 
     int[] stackArray;
     int top; 

    
    public Stack(int maxSize) {
        this.maxSize = maxSize;
        this.stackArray = new int[maxSize];
        this.top = -1; // Stack is initially empty
    }

    
    public void push(int element) {
        if (isFull()) {
            System.out.println("Stack overflow! Cannot push element " + element);
            return;
        }
        top++;
        stackArray[top] = element;
    }

    
    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack underflow! Cannot pop element");
            return -1; 
        }
        int poppedElement = stackArray[top];
        top--;
        return poppedElement;
    }

    
    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty! Cannot peek");
            return -1; 
        }
        return stackArray[top];
    }

    
    public boolean isEmpty() {
        return top == -1;
    }

    
    public boolean isFull() {
        return top == maxSize - 1;
    }

    
    public static void main(String[] args) {
        Stack stack = new Stack(5); 
        stack.push(10);   
        System.out.println("Popped element: " + stack.pop());
        System.out.println("Top element of the stack: " + stack.peek());
        while (!stack.isEmpty()) {
            System.out.println("Popped element: " + stack.pop());
        }
    }
}

----------------------trust the process you will definitely win
queue implementation question 16

public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // Constructor
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }

    // Enqueue: Add an element to the end of the queue
    public void enqueue(int data) {
        if (isFull()) {
            throw new RuntimeException("Queue is full");
        }
        rear = (rear + 1) % capacity;
        queue[rear] = data;
        size++;
    }

    // Dequeue: Remove and return the element from the front of the queue
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        int data = queue[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }

    // Peek: Return the front element without removing it
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        return queue[front];
    }

    // Check if the queue is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Check if the queue is full
    public boolean isFull() {
        return size == capacity;
    }

    // Get the size of the queue
    public int size() {
        return size;
    }

    // Display the queue
    public void display() {
        System.out.print("Queue: ");
        for (int i = 0; i < size; i++) {
            System.out.print(queue[(front + i) % capacity] + " ");
        }
        System.out.println();
    }
}


to traverse queue

    while (!queue.isEmpty()) {
            System.out.println("Dequeued element: " + queue.dequeue());
        }
----------------------trust the process you will definitely win
binary tree implementation question 17
class Node {
    int data;
    Node left, right;

    // Constructor to create a new node
    public Node(int item) {
        data = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    // Constructor
    BinaryTree() {
        root = null;
    }

    // Function to add nodes in a level-order manner
    public void add(int data) {
        root = addRecursively(root, data);
    }

    // Recursive function to add nodes
    private Node addRecursively(Node current, int data) {
        // If tree is empty, create a root node
        if (current == null) {
            return new Node(data);
        }

        // Insert nodes based on availability of left or right child
        if (current.left == null) {
            current.left = addRecursively(current.left, data);
        } else {
            current.right = addRecursively(current.right, data);
        }

        return current;
    }

    // In-order traversal (left, root, right)
    public void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.data + " ");
            inOrderTraversal(node.right);
        }
    }

    // Pre-order traversal (root, left, right)
    public void preOrderTraversal(Node node) {
        if (node != null) {
            System.out.print(node.data + " ");
            preOrderTraversal(node.left);
            preOrderTraversal(node.right);
        }
    }

    // Post-order traversal (left, right, root)
    public void postOrderTraversal(Node node) {
        if (node != null) {
            postOrderTraversal(node.left);
            postOrderTraversal(node.right);
            System.out.print(node.data + " ");
        }
    }
}
public class Main {
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        // Adding nodes in a binary tree fashion (not binary search tree)
        tree.add(1);  // Root
        tree.add(2);  // Left child of root
        tree.add(3);  // Right child of root
        tree.add(4);  // Left child of node 2
        tree.add(5);  // Right child of node 2

        System.out.println("In-order traversal:");
        tree.inOrderTraversal(tree.root);  // Output: 4 2 5 1 3 

        System.out.println("\nPre-order traversal:");
        tree.preOrderTraversal(tree.root);  // Output: 1 2 4 5 3 

        System.out.println("\nPost-order traversal:");
        tree.postOrderTraversal(tree.root);  // Output: 4 5 2 3 1
    }
}


----------------------trust the process you will definitely win
question 18 

selection sort
    static void selectionSort(int[] arr, int n, int index) {
        // Base case: If index is at the last element
        if (index == n)
            return;

        // Find the minimum element in the unsorted part of the array
        int minIndex = index;
        for (int i = index + 1; i < n; i++) {
            if (arr[i] < arr[minIndex]) {
                minIndex = i;
            }
        }

        // Swap the found minimum element with the current element at index
        int temp = arr[minIndex];
        arr[minIndex] = arr[index];
        arr[index] = temp;

        // Recursively call selectionSort for the next index
        selectionSort(arr, n, index + 1);
    }

----------------------trust the process you will definitely win
question 19 sum of first n natural nos

    static int func(int n){
        
            // Base Condition.
            if(n == 0){
                
                return 0;
            }
            
            // Problem broken down into 2 parts and then combined.
            return n + func(n-1);
            
----------------------trust the process you will definitely win
question 20 factorial of a number 

int factorial(n)
{
   if(n == 0)
   {
     return 1;
   }

return n * factorial(n-1);
}
----------------------trust the process you will definitely win
question 21 print fib series of a number
 static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    // Function to print the Fibonacci series up to the nth term
    static void printFibonacciSeries(int n) {
        for (int i = 0; i < n; i++) {
            System.out.print(fibonacci(i) + " ");
        }
    }
----------------------trust the process you will definitely win
question 22
Frequencies of Limited Range Array Elements
Input: n = 5, arr[] = [2, 3, 2, 3, 5], p = 5
Output: [0, 2, 2, 0, 1] 

    public static void frequencyCount(int arr[], int n, int p) {
        // do modify in the given array
        int[] temp=new int[n+1];
        
        for(int i=0;i<n;i++)
        {
            if(arr[i]>p)
            temp[i]=0;
            if(arr[i]<=p && arr[i]<=n)
            {
                temp[arr[i]]++;
            }
        }
        for(int i=0;i<n;i++)
        {
            arr[i]=temp[i+1];//hashed array that is y we are using i+1 
        }
        
    }
----------------------trust the process you will definitely win
question 23 
public int maxFrequency(int[] nums, int k) {
    // Variable to store the maximum frequency of an element
    int max = 0;

    // To track the total sum of the elements within the current window (between left and right)
    long total = 0;

    // Sorting the array so that we can try to make elements the same by adding 'k'
    Arrays.sort(nums);

    // Initializing two pointers for the sliding window: right and left
    int right = 0, left = 0;

    // Iterate through the array with the right pointer
    for (right = 0; right < nums.length; right++) {
        // Add the current element to the total sum
        total += nums[right];

        // Check if the current window [left, right] can be made equal to nums[right]
        // We check if the total value of all elements in the window after adding 'k' operations
        // is greater than or equal to making every element in the window equal to nums[right]
        // If not, shrink the window from the left
        while ((long) nums[right] * (right - left + 1) > total + k) {
            // Remove the leftmost element from the total sum
            total -= nums[left];
            // Move the left pointer to shrink the window
            left++;
        }

        // Update the maximum frequency found so far
        max = Math.max(max, right - left + 1);
    }

    // Return the maximum frequency
    return max;
}

----------------------trust the process you will definitely win
question 24 quick sort
public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Find the pivot element such that
            // elements smaller than pivot are on the left
            // elements greater than pivot are on the right
            int pivotIndex = partition(arr, low, high);

            // Recursively sort the left and right subarrays
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // Partition method to place the pivot element at its correct position
    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // Choose the rightmost element as pivot
        int i = (low - 1); // Index of smaller element

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;

                // Swap arr[i] and arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // Swap arr[i+1] with arr[high] (pivot)
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }
----------------------trust the process you will definitely win
question 25
second largest element
public static void second_largest(int[] arr)
{
	int n=arr.length;
	int first=Integer.MIN_VALUE,second=Integer.MIN_VALUE:

	for(int i=0;i<n;i++)
	{
		if(arr[i]>first)
		{
			second=first;
			first=arr[i];
		}
		else if(arr[i]>second && arr[i]<first)
		{
			second=arr[i];
		}
	}
	System.out.println(second);
}
----------------------trust the process you will definitely win
question 26
check if array is sorted or not
static boolean isSorted(int arr[], int n) {
    for (int i = 1; i < n; i++) {
      if (arr[i] < arr[i - 1])
        return false;
    }

    return true;
  }
----------------------trust the process you will definitely win
question 27
linear search 
int search(int arr[],int n,int num)
{
    int i;
    for(i=0;i<n;i++)
    {
        if(arr[i]==num)
        return i;
    }
    return -1;
}
----------------------trust the process you will definitely win
question 28 
Remove Duplicates from sorted array

    static int removeDuplicates(int[] arr) {
        int i = 0;
        for (int j = 1; j < arr.length; j++) {
            if (arr[i] != arr[j]) {
                i++;
                arr[i] = arr[j];
            }
        }
        return i + 1;//return just index that up to this index have only non duplicate

    }

----------------------trust the process you will definitely win
question 29
set matrix zeros leetcode 73
row length ku oru array , col length ku oru array create paniko
matrix ah traverse panni
  if mat[i][j]==0
  row[i]=1,col[j]=1
  set pannu
  
 again matrix ah traverse panni
     if(row[i]==1 or col[j]==1)
     mat[i][j]=0
     set pannu
     
     end
----------------------trust the process you will definitely win
question 30
kadane's algo max subarray
  leetcode 53
  sum=0,max=Integer.minvalue set panniko
  array ah traverse pannu
     {
     sum+=arr[i];
     if(sum>max)->max=sum
     if(sum<0)->sum=0
     }
return max
    end
----------------------trust the process you will definitely win
question 31
leetcode 121
 best time to buy and sell stock

 profit =0,besttime=arr[0];
 traverse array from index 1 to n
 {
   if(besttime>arr[i])
     besttime=arr[i];
    if(profit<(arr[i]-besttime))
    profit=arr[i]-besttime
}
return profit
----------------------trust the process you will definitely win
question 32
rotate 90 deg
leetcode 48
nested loops
i=0 to n
j=i to n
{
swap(mat[i][j],mat[j][i])
}
another nested loop
i=0 to n
j=0 to n/2
{
swap(ma[i][j],mat[i][n-j-1])
}
----------------------trust the process you will definitely win
question 33
leetcode 189
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
class Solution {
    public void rotate(int[] nums, int k) {
        
        k = k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public void reverse(int[] arr,int s,int e)
    {
        while(s<=e)
        {
            int t=arr[s];
            arr[s]=arr[e];
            arr[e]=t;
            s++;
            e--;
        }
    }
}
----------------------trust the process you will definitely win
question 34 
Move zeros to end leetcode 283
class Solution {
    public void moveZeroes(int[] arr) {
        int n=arr.length;
        int j=-1,i;
        for(i=0;i<n;i++)
        {
            if(arr[i]==0)
            {
                j=i;
                break;
            }
        }
        if(j==-1)
        return;
        for(i=j+1;i<n;i++)
        {
            if(arr[i]!=0)
            {
                int t=arr[i];
                arr[i]=arr[j];
                arr[j]=t;
                j++;
            }
        }

    }

}
 
----------------------trust the process you will definitely win
question 35
Union of two arrays
static ArrayList<Integer> FindUnion(int arr1[], int arr2[], int n, int m) {
   int i = 0, j = 0; // pointers
  ArrayList<Integer > Union=new ArrayList<>(); // Uninon vector
  while (i < n && j < m) {
    if (arr1[i] <= arr2[j]) // Case 1 and 2
    {
      if (Union.size() == 0 || Union.get(Union.size()-1) != arr1[i])
        Union.add(arr1[i]);
      i++;
    } else // case 3
    {
      if (Union.size() == 0 || Union.get(Union.size()-1) != arr2[j])
        Union.add(arr2[j]);
      j++;
    }
  }
  while (i < n) // IF any element left in arr1
  {
    if (Union.get(Union.size()-1) != arr1[i])
      Union.add(arr1[i]);
    i++;
  }
  while (j < m) // If any elements left in arr2
  {
    if (Union.get(Union.size()-1) != arr2[j])
      Union.add(arr2[j]);
    j++;
  }
  return Union;
}
----------------------trust the process you will definitely win
question 36
leetcode 485. Max Consecutive Ones
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        
        int count=0,max=0;
        int n=nums.length;
        for(int i=0;i<n;i++)
        {
            if(nums[i]==1)
              count++;
            else
               count=0;
        max=Math.max(count,max);
        }
        return max;
    }
    
}
----------------------trust the process you will definitely win
question 37
leetcode 136. Single Number
class Solution {
    public int singleNumber(int[] nums) {
        int xor_value=0;
        int n=nums.length;
        for(int i=0;i<n;i++)
        {
            xor_value ^=nums[i];
        }
        return xor_value;
    }
}
----------------------trust the process you will definitely win
question 38
get length of longest subarray with given sum // for positives values only
 public static int getLongestSubarray(int []a, long k) {
        int n = a.length; // size of the array.

        int left = 0, right = 0; // 2 pointers
        long sum = a[0];
        int maxLen = 0;
        while (right < n) {
            // if sum > k, reduce the subarray from left
            // until sum becomes less or equal to k:
            while (left <= right && sum > k) {
                sum -= a[left];
                left++;
            }

            // if sum = k, update the maxLen i.e. answer:
            if (sum == k) {
                maxLen = Math.max(maxLen, right - left + 1);
            }

            // Move forward thw right pointer:
            right++;
            if (right < n) sum += a[right];
        }

        return maxLen;
    }
----------------------trust the process you will definitely win
question 39
2 sum leetcode 1
   public static String twoSum(int n, int []arr, int target) {
        HashMap<Integer, Integer> mpp = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int num = arr[i];
            int moreNeeded = target - num;
            if (mpp.containsKey(moreNeeded)) {
                return "YES";
            }

            mpp.put(arr[i], i);
        }
        return "NO";
    }
----------------------trust the process you will definitely win
question 40
leetcode 169
Mooreâ€™s Voting Algorithm
class Solution {
    public int majorityElement(int[] nums) {
        //more than n/2 times
        int count=0;
        int candidate=0;
       for(int element : nums)
       {
         if(count==0)
          candidate=element;
         if(candidate==element)
          count++;
         else
           count--;
       }
     return candidate;
    }
}
----------------------trust the process you will definitely win
question 41
get length of longest subarray with given sum // for positives and negative values only
public static int getLongestSubarray(int []a, int k) {
        int n = a.length; // size of the array.

        int len = 0;
        for (int i = 0; i < n; i++) { // starting index
            int s = 0;
            for (int j = i; j < n; j++) { // ending index
                // add the current element to
                // the subarray a[i...j-1]:
                s += a[j];

                if (s == k)
                    len = Math.max(len, j - i + 1);
            }
        }
        return len;
    }
----------------------trust the process you will definitely win
question 42
leetcode 287 (question 6)
find duplicate O(n)
frequency array onu create panniko
freq[]
traverse the org arry
    if(freq[arr[i]]==0)
      freq[arr[i]]++;
     else
     return arr[i];
     end of loop
     return -1
     end
----------------------trust the process you will definitely win
question 43 pos no first neg no second ...  relative order should not change
leetcode 2149. Rearrange Array Elements by Sign
public int[] rearrangeArray(int[] nums) {
        
        int n = nums.length;
        int res[]=new int[n];
        int pos=0,neg=1;
        for(int i=0;i<n;i++)
        {
            if(nums[i]>=0)
            {
                res[pos]=nums[i];
                pos+=2;
            }
            else
            {
                res[neg]=nums[i];
                neg+=2;
            }
            
        }
     	return res;
}
----------------------trust the process you will definitely win
question 44
leetcode 31 
next permutation
 declare ind1=-1,ind2=-1;
   for(int i=n-2;i>=0;i--)
   {
       if(arr[i]<arr[i+1])
      {
        ind1=i;break;  
      }
   }
   if(ind1==-1)
   reverse(arr,0)-->0 is starting index
   else
   {
    for(int i=n-1;i>ind1;i--)
    {
      if(arr[i]>arr[ind1])
      {
        ind2=i;break;
      }
    }
    swap(arr,ind1,ind2);---passing index swaps based on position
    reverse(arr,ind1+1);
   }
   end
----------------------trust the process you will definitely win
question 45
leetcode 118   pascal triangle
int n=5;
 int dp[][]=new int[n][n];
for(int i=0;i<n;i++)
{
   for(int j=0;j<=i;j++)
   {
       if(j==0 || j==i)
        dp[i][j]=1;
       else
         dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
   }
}

 end
with out using arrays

public class PascalTriangle {
    public static void main(String[] args) {
        int n = 5; // Number of rows for Pascal's Triangle
        
        // Iterate through each row
        for (int i = 0; i < n; i++) {
            int value = 1; // The first value in each row is always 1
            System.out.print(value + " "); // Print the first value
            
            // Compute and print the rest of the values in the row
            for (int j = 1; j <= i; j++) {
                value = value * (i - j + 1) / j; // Binomial coefficient calculation
                System.out.print(value + " "); // Print values in the same row
            }
            
            System.out.println(); // Newline after each row
        }
    }
}

----------------------trust the process you will definitely win
question 46
leaders in an array 
public static ArrayList<Integer> 
                     printLeadersBruteForce(int[] arr, int n){
    
  ArrayList<Integer> ans= new ArrayList<>();
   int max = arr[n - 1];
    ans.add(arr[n-1]);
     for (int i = n - 2; i >= 0; i--)
      if (arr[i] > max) {
        ans.add(arr[i]);
        max = arr[i];
      }

  return ans;
}
----------------------trust the process you will definitely win
question 47
 find repeating and missing number

int n = a.length; 
        int[] hash = new int[n + 1]; 

        
        for (int i = 0; i < n; i++) {
            hash[a[i]]++;
        }

        
        int repeating = -1, missing = -1;
        for (int i = 1; i <= n; i++) {
            if (hash[i] == 2) repeating = i;
            else if (hash[i] == 0) missing = i;

            if (repeating != -1 && missing != -1)
                break;
        }
        int[] ans = {repeating, missing};
        return ans;
----------------------trust the process you will definitely win
question 48
leetcode 128. Longest Consecutive Sequence
class Solution {
    public int longestConsecutive(int[] nums) {
        
        if(nums.length==0)
        return 0;
        Arrays.sort(nums);
        int max=-1;
        int count=0;
        for(int i=1;i<nums.length;i++)
        {
            if(nums[i-1]==nums[i])
            continue;
            else if(nums[i]-nums[i-1]==1)
            count++;
            else
            {
                if(count>max)
                {
                    max=count;
                }
                count=0;
            }
        }
        if(count>max)
        max=count;

        return max+1;

    }
}
----------------------trust the process you will definitely win
question 49
 leetcode 88 
merge two sorted array 
      class Solution {
    public void merge(int[] nums1, int n1, int[] nums2, int n2) {
        
        int p1=n1-1;//nums1 size is n+m
        int p2=n2-1;
        int curr=n1+n2-1;
        
        while(p2>=0)
        {
            if(p1>=0 && nums1[p1]>nums2[p2])
            {
                nums1[curr--] = nums1[p1--];

            }
            else
            {
                nums1[curr--] = nums2[p2--];
            }
        }
    }
}
----------------------trust the process you will definitely win
question 50
binary search tree implementation
// Node class to represent a node in the tree
class Node {
    int data;
    Node left, right;

    public Node(int data) {
        this.data = data;
        left = right = null;
    }
}

// Binary Search Tree class
class BinarySearchTree {
    Node root;

    // Constructor
    BinarySearchTree() {
        root = null;
    }

    // This method calls the recursive insert method
    void insert(int data) {
        root = insertRec(root, data);
    }

    // A recursive function to insert a new key in the BST
    Node insertRec(Node root, int data) {
        // If the tree is empty, return a new node
        if (root == null) {
            root = new Node(data);
            return root;
        }

        // Otherwise, recur down the tree
        if (data < root.data)
            root.left = insertRec(root.left, data);
        else 
            root.right = insertRec(root.right, data);

        // Return the (unchanged) node pointer
        return root;
    }

    // This method calls the recursive search method
    boolean search(int data) {
        return searchRec(root, data);
    }

    // A recursive function to search a key in the BST
    boolean searchRec(Node root, int data) {
        // Base Cases: root is null or key is present at root
        if (root == null)
            return false;
        if (root.data == data)
            return true;

        // Key is greater than root's key
        if (root.data < data)
            return searchRec(root.right, data);

        // Key is smaller than root's key
        return searchRec(root.left, data);
    }

    public static void main(String[] args) {
        BinarySearchTree tree = new BinarySearchTree();

        // Insert nodes into the tree
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // Search for a key in the BST
        int data = 40;
        if (tree.search(data))
            System.out.println("Key " + key + " found in the tree.");
        else
            System.out.println("Key " + key + " not found in the tree.");
    }
}
----------------------trust the process you will definitely win
question 51
binary search
public static int search(int a[],int target,int l,int r)
    {
       if(l<=r)
       {
          int mid=(l+r)/2;
          if(a[mid]==target)
          {
            return mid;
          }
          else if(a[mid]<target)
          {
            l=mid+1;
            search(a,target,l,r);
          }
          else
          {
            r=mid-1;
            search(a,target,l,r);
          }
        }
        return -1;
    }
----------------------trust the process you will definitely win
question 52
leetcode 62
        unique path 

         int[][] dp=new int[m][n];
         
         for(int i=0;i<m;i++)
         {
             dp[i][0]=1;
         }
         for(int j=0;j<n;j++)
         {
             dp[0][j]=1;
         }
         for(int i=1;i<m;i++)
         {
             for(int j=1;j<n;j++)
             {
                 dp[i][j]=dp[i-1][j]+dp[i][j-1];
             }
         }
         return dp[m-1][n-1];       
         end
----------------------trust the process you will definitely win
question 53
leetcode 54
   public List<Integer> spiralOrder(int[][] mat) {
        List<Integer> ans = new ArrayList<>();
        int n = mat.length; 
        int m = mat[0].length; 
        int top = 0, left = 0, bottom = n - 1, right = m - 1;   
        while (top <= bottom && left <= right) {
                       
            for (int i = left; i <= right; i++)
                ans.add(mat[top][i]);

            top++;
  
            for (int i = top; i <= bottom; i++)
                ans.add(mat[i][right]);

            right--;

            // For moving right to left.
            if (top <= bottom) {
                for (int i = right; i >= left; i--)
                    ans.add(mat[bottom][i]);

                bottom--;
            }

            // For moving bottom to top.
            if (left <= right) {
                for (int i = bottom; i >= top; i--)
                    ans.add(mat[i][left]);

                left++;
            }
        }
        return ans;

        
    }
----------------------trust the process you will definitely win
question 54
leetcode 229 Majority Element-II 

public List<Integer> majorityElement(int[] v) {
        
        int n = v.length; //size of the array

        int cnt1 = 0, cnt2 = 0; // counts
        int el1 = Integer.MIN_VALUE; // element 1
        int el2 = Integer.MIN_VALUE; // element 2

      
        for (int i = 0; i < n; i++) {
            if (cnt1 == 0 && el2 != v[i]) {
                cnt1 = 1;
                el1 = v[i];
            } else if (cnt2 == 0 && el1 != v[i]) {
                cnt2 = 1;
                el2 = v[i];
            } else if (v[i] == el1) cnt1++;
            else if (v[i] == el2) cnt2++;
            else {
                cnt1--; cnt2--;
            }
        }

        List<Integer> ls = new ArrayList<>(); 
        cnt1 = 0; cnt2 = 0;
        for (int i = 0; i < n; i++) {
            if (v[i] == el1) cnt1++;
            if (v[i] == el2) cnt2++;
        }

        int mini = (int)(n / 3) + 1;
        if (cnt1 >= mini) ls.add(el1);
        if (cnt2 >= mini) ls.add(el2);

        
        return ls;

    }
----------------------trust the process you will definitely win
question 55
leetcode 15
    public List<List<Integer>> threeSum(int[] arr) {
         
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(arr);
        int n=arr.length;

        for (int i = 0; i < n; i++) {
            //remove duplicates:
            if (i != 0 && arr[i] == arr[i - 1]) continue;

            //moving 2 pointers:
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                int sum = arr[i] + arr[j] + arr[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    List<Integer> temp = Arrays.asList(arr[i], arr[j], arr[k]);
                    ans.add(temp);
                    j++;
                    k--;
                    //skip the duplicates:
                    while (j < k && arr[j] == arr[j - 1]) j++;
                    while (j < k && arr[k] == arr[k + 1]) k--;
                }
            }
        }

        return ans;
    }
----------------------trust the process you will definitely win
question 56
leetcode 18
    public List<List<Integer>> fourSum(int[] arr, int target) {

        List<List<Integer>> ans = new ArrayList<>();
        int n = arr.length;
        Arrays.sort(arr);
        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && arr[i - 1] == arr[i]) continue;

            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && arr[j - 1] == arr[j]) continue;

                int k = j + 1;
                int l = n - 1;

                while (k < l) {
                    long sum = arr[i] + arr[j];
                    sum += arr[k] + arr[l];

                    if (sum == target) {
                        ans.add(Arrays.asList(arr[i], arr[j], arr[k], arr[l]));
                        k++;
                        l--;
                        while (k < l && arr[k - 1] == arr[k]) k++;
                        while (k < l && arr[l + 1] == arr[l]) l--;
                    } else if (sum < target) {
                        k++;
                    } else {
                        l--;
                    }
                }
            }
        }

        return ans;
        
    }
----------------------trust the process you will definitely win
question 57
Subarray with given XOR(Interview Bit)
 public static int subarraysWithXorK(int []a, int k) {
        int n = a.length; //size of the given array.
        int cnt = 0;

        // Step 1: Generating subarrays:
        for (int i = 0; i < n; i++) {
            int xorr = 0;
            for (int j = i; j < n; j++) {

                //step 2:calculate XOR of all
                // elements:
                xorr = xorr ^ a[j];

                // step 3:check XOR and count:
                if (xorr == k) cnt++;
            }
        }
        return cnt;
    }

----------------------trust the process you will definitely win
question 58
leetcode 56 merge intervals 

public int[][] merge(int[][] intervals) {

        List<int[]> res = new ArrayList<>();
         if(intervals.length==0)
         {
           return res.toArray(new int[0][]);
         }

         Arrays.sort(intervals,(a,b)->a[0]-b[0]);
          
          int start = intervals[0][0];
          int end = intervals[0][1];
          
          for(int[] i : intervals)
          {
            if(i[0]<=end)
            {
              end=Math.max(end,i[1]);
            }
            else
            {
              res.add(new int[]{start,end});
              start = i[0];
              end = i[1];
            }
          }
          res.add(new int[]{start,end});
          return res.toArray(new int[0][]);
    }
----------------------trust the process you will definitely win
question 59

public static int numberOfInversions(int[] a, int n) {
        // Count the number of pairs:
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (a[i] > a[j]) cnt++;
            }
        }
        return cnt;
    }
----------------------trust the process you will definitely win
question 60
leetcode 152
public int maxProduct(int[] arr) {
        int prod1 = arr[0],prod2 = arr[0],result = arr[0];
    
    for(int i=1;i<arr.length;i++) {
        int temp = Math.max(arr[i],Math.max(prod1*arr[i],prod2*arr[i]));
        prod2 = Math.min(arr[i],Math.min(prod1*arr[i],prod2*arr[i]));
        prod1 = temp;
        
        result = Math.max(result,prod1);
    }
    
    return result;
    }
----------------------trust the process you will definitely win
question 61
reverse pairs
 public static int countPairs(int[] a, int n) {

        // Count the number of pairs:
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (a[i] > 2 * a[j])
                    cnt++;
            }
        }
        return cnt;
    }
----------------------trust the process you will definitely win

question 62 coding ninjas
count inversion of array
import java.util.* ;
import java.io.*; 
public class Solution {
    public static long getInversions(long arr[], int n) {
        // Write your code here.
        long ans=mergesort(arr,0,n-1);
        return ans;
    }
    public static long mergesort(long[] arr,int left,int right)
    {
        long count=0;
        if(left>=right)
        return count;
        int mid=(left+right)/2;
        count+=mergesort(arr,left,mid);
        count+=mergesort(arr,mid+1,right);
        count+=merge(arr,left,mid,right);
        return count;
        
    }
    public static long merge(long[] a,int low,int mid,int high)
    {
        ArrayList<Long> ans=new ArrayList<>();
        long count=0;
    
        int left=low;
        int right=mid+1;
        while(left<=mid && right<=high)
        {
            if(a[left]<=a[right])
            {
                ans.add(a[left]);
                left++;

            }
            else
            {
               count+=(mid-left+1);
               ans.add(a[right]);
               right++;
            }
        }
        while(left<=mid)
        {
            ans.add(a[left]);
            left++;
        }
        while(right<=high)
        {
            ans.add(a[right]);
            right++;

        }
        for (int i = low; i <= high; i++) {
            a[i] = ans.get(i-low);
        }
        return count;

    }
}
----------------------trust the process you will definitely win
question 63 coding ninjas
binary search based problem so array should be sorted
You are given an array 'arr' sorted in non-decreasing order and a number 'x'. You must return the index of the lower bound of 'x'.
Input Format:
 N = 5, arr[] = {3,5,8,15,19}, x = 9
Result:
 3
Explanation:
 Index 3 is the smallest index such that arr[3] >= x.

public static int lowerBound(int []arr, int n, int x) {
        // Write your code here
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
----------------------trust the process you will definitely win
question 64 leetcode 35 
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
binary search based problem so array should be sorted
public int searchInsert(int[] arr, int x) {

      int n = arr.length; // size of the array
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = mid;
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;   
    }
----------------------trust the process you will definitely win
question 65 
find floor and ceil

The floor of x is the largest element in the array which is smaller than or equal to x.
The ceiling of x is the smallest element in the array greater than or equal to x.

Input Format: n = 6, arr[] ={3, 4, 4, 7, 8, 10}, x= 5
Result: 4 7
Explanation: The floor of 5 in the array is 4, and the ceiling of 5 in the array is 7.
binary search based problem so array should be sorted

 static int findFloor(int[] arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] <= x) {
                ans = arr[mid];
                //look for smaller index on the left
                low = mid + 1;
            } else {
                high = mid - 1; // look on the right
            }
        }
        return ans;
    }

    static int findCeil(int[] arr, int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            // maybe an answer
            if (arr[mid] >= x) {
                ans = arr[mid];
                //look for smaller index on the left
                high = mid - 1;
            } else {
                low = mid + 1; // look on the right
            }
        }
        return ans;
    }
----------------------trust the process you will definitely win
question 66
leetcode 34. Find First and Last Position of Element in Sorted Array
binary search based problem so array should be sorted
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int res[]={-1,-1};
        int left=helper(nums,target,true);
        int right=helper(nums,target,false);
        res[0]=left;
        res[1]=right;
        return res;
    }
    public int helper(int[] arr,int target,boolean isSearchingLeft)
    {
        int left=0,right=arr.length-1,ind=-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(arr[mid]>target)
            {
                right=mid-1;
            }
            else if(arr[mid]<target)
            {
                left=mid+1;
            }
            else
            {
                idx=mid;
                if(isSearchingLeft)
                {
                    right=mid-1;

                }
                else
                {
                    left=mid+1;
                }
            }
        }
        return ind;


    }
}
----------------------trust the process you will definitely win
question 67(gfg)
binary search based problem so array should be sorted
Number of occurrence(using bs)
class Solution {
    int count(int[] arr, int n, int x) {
        // code here
       int[] res=new int[2];
       res[0]=res[1]=-1;
       int left=bs(arr,x,true);
       int right=bs(arr,x,false);
       if(left==-1)
       return 0;
       return (right-left+1);
    }
    int bs(int[] arr,int x,boolean isSearchingLeft)
    {
        int left=0,right=arr.length-1,ind=-1;
        while(left<=right)
        {
            int mid=(left+right)/2;
            if(arr[mid]<x)
            {
                left=mid+1;
            }
            else if(arr[mid]>x)
            {
                right=mid-1;
            }
            else
            {
                ind=mid;
                if(isSearchingLeft)
                {
                   right=mid-1;
                }
                else
                {
                    left=mid+1;
                }
            }
            
        }
        return ind;
    }
}
----------------------trust the process you will definitely win
question 68
leetcode 33
search in a rotated sorted array
class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = (start+end) / 2;

            // Check if the target is found
            if (nums[mid] == target) {
                return mid;
            }

            // Determine if the left side is sorted
            if (nums[start] <= nums[mid]) {
                // Target is in the sorted left half
                if (target >= nums[start] && target < nums[mid]) {
                    end = mid - 1; // search in the left half
                } else {
                    start = mid + 1; // search in the right half
                }
            } else {
                // Right side is sorted
                if (target > nums[mid] && target <= nums[end]) {
                    start = mid + 1; // search in the right half
                } else {
                    end = mid - 1; // search in the left half
                }
            }
        }

        return -1; // Target not found
    }
}
----------------------trust the process you will definitely win
question 69 
leetcode 81
81. Search in Rotated Sorted Array II(handling duplicates)
class Solution {
    public boolean search(int[] arr, int target) {
        int start=0,end=arr.length-1;
        boolean ans=false;

        while(start<=end){
            int mid = (start+end)/2;
            if(arr[mid]==target){
                ans=true;
                break;
            }

            else if(arr[mid]==arr[start] && arr[mid]==arr[end]){ //to handle duplicate element case
                start++;
                end--;
            }

            else if(arr[start]<=arr[mid]){ //left sorted
                if(target>=arr[start] && target<arr[mid]){
                    end=mid-1;//left
                }else{
                    start=mid+1;//right
                }

            }else{ //right sorted
                if(target>arr[mid] && target<=arr[end]){
                    start=mid+1;//right
                }else{
                    end=mid-1;//left
                }
            }
        }

        return ans;
    }
}
----------------------trust the process you will definitely win
question 70
leetcode 153 (find min rotated sorted array)
class Solution {
    public static int findMin(int[] arr) {
        int start = 0, end = arr.length - 1;
        int ans = Integer.MAX_VALUE;
        while (start <= end) {
            int mid = (start + end) / 2;

            // Search space is already sorted,
            // then arr[low] will always be
            // the minimum in that search space:
            if (arr[start] <= arr[end]) {
                ans = Math.min(ans, arr[start]);
                break;
            }

            // If left part is sorted:
            if (arr[start] <= arr[mid]) {
                // Keep the minimum:
                ans = Math.min(ans, arr[start]);

                // Eliminate left half:
                start = mid + 1;//right 

            } else { // If right part is sorted:

                // Keep the minimum:
                ans = Math.min(ans, arr[mid]);

                // Eliminate right half:
                end = mid - 1;//left
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 71

public static int findKRotation(int[] arr) {
        int start = 0, end = arr.length - 1;
        int ans = Integer.MAX_VALUE;
        int index = -1;
        while (start <= end) {
            int mid = (start + end) / 2;
            //search space is already sorted
            //then arr[low] will always be
            //the minimum in that search space:
            if (arr[start] <= arr[end]) {
                if (arr[start] < ans) {
                    index = start;
                    ans = arr[start];
                }
                break;
            }

            //if left part is sorted:
            if (arr[start] <= arr[mid]) {
                // keep the minimum:
                if (arr[start] < ans) {
                    index = start;
                    ans = arr[start];
                }

                // Eliminate left half:
                start = mid + 1;//right
            } else { //if right part is sorted:

                // keep the minimum:
                if (arr[mid] < ans) {
                    index = mid;
                    ans = arr[mid];
                }

                // Eliminate right half:
                end = mid - 1;//left
            }
        }
        return index;
    }
----------------------trust the process you will definitely win
question 72
leetcode 540 single element in a sorted array

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0;
        int r = nums.length - 1;
        
        while (l<r) {
            int m = (l+r) / 2;
            
            // Ensure m is even so we can compare nums[m] with nums[m + 1]
            if (m % 2 == 1) {
                m--;
            }

            // If nums[m] equals nums[m + 1], the single element is in the right half
            if (nums[m] == nums[m + 1]) {
                l = m + 2;//right
            } 
            // Otherwise, it's in the left half
            else {
                r = m;//left
            }
        }

        // l will point to the single element
        return nums[l];
    }
}
----------------------trust the process you will definitely win
question 73
leetcode 162
class Solution {
    public int findPeakElement(int[] arr) {
        
        int left=0;
        int right=arr.length-1;

        while(left<right)
        {
            int mid=(left+right)/2;
            if(arr[mid]>arr[mid+1])
            {
                right=mid;//left
            }
            else
            {
                left=mid+1;//right
            }
        }
        return left;
    }
}
----------------------trust the process you will definitely win
question 74
find square root of a no (bs)
public static int floorSqrt(int n) {
        int low = 1, high = n;
        //Binary search on the answers:
        while (low <= high) {
            long mid = (low + high) / 2;
            long val = mid * mid;
            if (val <= (long)(n)) {
                //eliminate the left half:
                low = (int)(mid + 1);//right
            } else {
                //eliminate the right half:
                high = (int)(mid - 1);//left
            }
        }
        return high;
    }

----------------------trust the process you will definitely win
question 75
875. Koko Eating Bananas
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        //binary search
        Arrays.sort(piles);//sorting is not neccasary  you can find max in O(n)
        int start = 1;//one hour ku minimum ah ethana bananas sapdum a monkey min is 1 max is max(arr0
        //taking the largest value possible as end
        int max=piles[piles.length-1];
        int end = max;
        while(start < end){
            int mid =(start+end)/ 2;
            //check whether mid is a possible candidate or not
            if(isPossible(piles, mid, h)){
                end = mid;//left
            }else{
                start = mid + 1;//rigth
            }
        }
        return start;
    }
    public boolean isPossible(int[] piles, int value, int h){
        int hours = 0;
        for(int pile : piles){
            int div = pile / value;
            hours += div;
            if(pile % value != 0) hours++;
        }
        return hours <= h;
    }
}
----------------------trust the process you will definitely win
question 76
leetcode 1283 
 We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 

class Solution {
    public int smallestDivisor(int[] nums, int t) {
        int low = 1, high = 1, ans =-1;

        for(int i : nums) {
            if(i > high) high = i;
        }

        while(low <= high) {
            int mid = (low + high) / 2;

            int val = getThreshold(nums, mid);
            if(val <= t) {
                high = mid - 1;//left
                ans = mid;
            } else {
                low = mid +1;//right
            }
        }
        return ans;
    }
    
    public int getThreshold(int[] map, int val){
        
        int ans = 0;
        for(int i : map) {
            ans += (i + val - 1) / val;
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 77
leetcode 1482. Minimum Number of Days to Make m Bouquets
see coders campt youtube video to understand this question...
class Solution {

//oru boque ku k flowers theva padum
//min days to make m boques
//take adajacent flowers to make one boque
 class Solution {
    public int minDays(int[] bloomDay, int m, int k) {

        if((long) m * k > bloomDay.length) 
        return -1;

        int minDays = -1;
        int l = -1, r = Integer.MIN_VALUE, n = bloomDay.length;
        
        for(int i=0; i<n; i++)
        {
           r = Math.max(r, bloomDay[i]);
           l = Math.min(l,bloomDay[i]);
        } 
        

        while(l <= r) 
        {
            int mid = (l + r) / 2;
            if(isValid(mid, bloomDay, m, k))
            {
                minDays = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return minDays;
    }
    static boolean isValid(int mid, int[] bloomDay, int m, int k)
    {
        int cons = 0, numberOfB = 0;
        for(int i=0; i<bloomDay.length; i++)
        {
            if(bloomDay[i] <= mid)
            { 
            ++cons;
            }
            else
            { 
            cons = 0;
            }

            if(cons == k) {
                numberOfB++;
                cons = 0;
            }
        }
        return numberOfB >= m;
    }
}
----------------------trust the process you will definitely win
question 78

Input Format:
 N = 3, M = 27
Result:
 3
Explanation:
 The cube root of 27 is equal to 3.

 public static int func(int mid, int n, int m) {
        long ans = 1;
        for (int i = 1; i <= n; i++) {
            ans = ans * mid;
            if (ans > m) return 2;
        }
        if (ans == m) return 1;
        return 0;
    }

    public static int NthRoot(int n, int m) {
        // Use binary search on the answer space:
        int low = 1, high = m;
        while (low <= high) {
            int mid = (low + high) / 2;
            int midN = func(mid, n, m);
            if (midN == 1) {
                return mid;
            } else if (midN == 0) {
                low = mid + 1;//right
            } else {
                high = mid - 1;//left
            }
        }
        return -1;
    }
----------------------trust the process you will definitely win
question 79
leetcode 1011. least Capacity To Ship Packages Within D Days (ship runs only once per day)

class Solution {

    public int loadOnShip(int mid, int [] weights) {
    ///  This method calculates how many days it would take to load all the packages if the ship's capacity is mid.
        int sum = 0, dayCnt = 0;
        for(int i=0; i<weights.length; i++) {
            sum += weights[i];
            if(mid>=sum){
                continue;
            } else {
                dayCnt++;
                sum = weights[i];
            }
        }
        return dayCnt + 1;
    }

    public int shipWithinDays(int[] weights, int days) {
        int low = 0, high = 0;
        for(int w : weights){
            low = Math.max(low, w);
            high += w;
        }

        while(low<=high){
            int mid = (low+high)/2;
            int daysToLoad = loadOnShip(mid, weights);
            if(daysToLoad <= days) {
                high = mid - 1;//left
            } else {
                low = mid + 1;//right
            }
        }
        return low;
    }
}
----------------------trust the process you will definitely win
question 80
leetcode 1539. Kth Missing Positive Number
//take max value in array up to that value find kth missing value 
it starts from 1 only

class Solution {
    public int findKthPositive(int[] arr, int k) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2;

            int totMissing = arr[mid] - (mid + 1);

            if (totMissing < k)
                low = mid + 1;//right
            else
                high = mid - 1;//left
        }

        return k + high + 1;
    }
}
----------------------trust the process you will definitely win
question 81
leetcode 74. Search a 2D Matrix
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n=matrix.length;
        int m=matrix[0].length;

        int low=0,high=n*m-1;
        while(low<=high)
        {
            int mid=(low + high )/2;
            int row=mid/m,col=mid%m;
            if(matrix[row][col]==target)
            return true;
            else if(matrix[row][col]<target)
            low=mid+1;//right
            else
            high=mid-1;//left
        }
        return false;
    }
}
----------------------trust the process you will definitely win
question 82
aggressive cows only on take you forward

first stalls ah sort pannu cows =4

  stalls  0   3   4   7   10   9
  cows    c1  c2 c3   c4
  now find disance between two consective cows
  
  comb1  c1-c2 is 3 c2 -c3 is  1 c3 -c4 is 3   its is min is 1
       you can place 4 cows anywhere and their min 
       
       after take max among them           

 public static boolean canWePlace(int[] stalls, int dist, int cows) {
        int n = stalls.length; //size of array
        int cntCows = 1; //no. of cows placed
        int last = stalls[0]; //position of last placed cow.
        for (int i = 1; i < n; i++) {
            if (stalls[i] - last >= dist) {
                cntCows++; //place next cow.
                last = stalls[i]; //update the last location.
            }
            if (cntCows >= cows) return true;
        }
        return false;
    }
    public static int aggressiveCows(int[] stalls, int k) {
        int n = stalls.length; //size of array
        //sort the stalls[]:
        Arrays.sort(stalls);

        int low = 1, high = stalls[n - 1] - stalls[0];
        //apply binary search:
        while (low <= high) {
            int mid = (low + high) / 2;
            if (canWePlace(stalls, mid, k) == true) {
                low = mid + 1;//right
            } else high = mid - 1;//left
        }
        return high;
    }
----------------------trust the process you will definitely win
question 83
Allocate Minimum No of Pages
public static int countStudents(int[] arr,int pages)
{
    int n=arr.length;
    int students=1;
    int pagesStudent=0;
    for(int i=0;i<n;i++)
    {
        if(pagesStudent+arr[i]<=pages)
        {
            pagesStudent+=arr[i];
        }
        else
        {
            students++;
            pagesStudent=arr[i];
        }
    }
    return students;
}

public static int findPages(int[] arr,int n,int m)
{
    if(m>n)
        return -1;

    int low=-1,high=0;
    for(int i=0;i<arr.length;i++)
    {
        if(low<arr[i])
        {
            low=arr[i];
        }
        high+=arr[i];
    }
    while(low<=high)
    {
        int mid=(low+high)/2;
        int students=countStudents(arr,mid);
        if(students>m)
        {
            low=mid+1;//rigth
        }
        else
        {
            high=mid-1;//left
        }

    }
    return low;
}
----------------------trust the process you will definitely win
question 84
leetcode 410. Split Array Largest Sum
class Solution {
    private boolean isPossible(int[] nums, int maxSum, int k) {
        int subarrays = 1, sum = 0;

        for (int num : nums) {
            if(sum+num<=maxSum)
            {
                sum+=num;
            }
            else
            {
                sum = num;
                subarrays++;

                if (subarrays > k)
                    return false;
            }
        }

        return true;
    }

    public int splitArray(int[] nums, int k) {
        int low = nums[0], high = 0;
        for (int num : nums) {
            low = Math.max(low, num);
            high += num;
        }

        int result = -1;
        while (low <= high) {
            int mid = (low+high) / 2;

            if (isPossible(nums, mid, k)) {
                result = mid;
                high = mid - 1;//left
            } else {
                low = mid + 1;//right
            }
        }

        return result;
    }
}
----------------------trust the process you will definitely win
question 85


public static int countPainters(int[] boards,int time)
{
   int n=boards.length;
   int painters=1;
   int boardsPainter=0;
   for(int i=0;i<n;i++)
   {
       if(boardsPainter + boards[i]<=time)
       {
         boardsPainter+=boards[i];
       }
       else
       {
          painters++;
          boardsPainter = boards[i];
       }

   }
   retun painters;
}



public static int findLargestMinDistance(int[] boards,int k)
{
    int low=-1,high=0;
    for(int i=0;i<boards.length;i++)
    {
        if(low<boards[i])
        {
            low=boards[i];
        }
        high+=boards[i];
    }

    while(low<=high)
    {
        int mid = (low+high)/2;
        int painters = countPainters(boards,mid);
        if(painters > k)
        {
            low = mid+1;//right
        }
        else
        {
            high = mid-1;//left
        }
    }

    return low;
}
----------------------trust the process you will definitely win
question 86

leetcode 27
class Solution {
    public int removeElement(int[] nums, int val) {

        int c=0;
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]!=val)
            {
                nums[c++]=nums[i];
            }
        }
        
        return c;
    }
}
----------------------trust the process you will definitely win
question 87

public class FibonacciMemoization {
    public static int fib(int n, int[] memo) {
        // Base cases
        if (n <= 1) {
            return n;
        }

        // If already calculated, return the stored result
        if (memo[n] != -1) {
            return memo[n];
        }

        // Recursively calculate Fibonacci and store in the memo array
        memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
        return memo[n];
    }

    public static void main(String[] args) {
        int n = 10; // Example

        // Array to store results, initialized to -1
        int[] memo = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            memo[i] = -1;
        }

        System.out.println("Fibonacci of " + n + " is: " + fib(n, memo));
    }
}
----------------------trust the process you will definitely win
question 88 
leetcode 1021
class Solution {
    public String removeOuterParentheses(String s) {
        String ans="";
        int count=0;
        int n=s.length();
        for(int i=0;i<n;i++)
        {
            char curr=s.charAt(i);
            if(curr=='(' && count==0)
            {
                count++;
            }
            else if(curr=='(' &&count>=1)
            {
                ans+=curr;
                count++;
            }
            else if(curr==')' && count>1)
            {
                ans+=curr;
                count--;
            }
            else if(curr==')' && count==1)
            {
                count--;
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 89
leetcode 151
Reverse a sentences
public static  String result(String s)
{
	int left = 0;
	int right = s.length() - 1;

	String temp = "";
	String ans = "";

	//Iterate the string and keep on adding to form a word
	//If empty space is encountered then add the current word to the result
	while (left <= right)
	{
		char ch = s.charAt(left);
		if (ch != ' ')
		{
			temp += ch;
		}
		else if (ch == ' ')
		{
			if (!ans.equals(""))
			{
				ans = temp + " " + ans;
			}
			else
			{
				ans = temp;
			}
			temp = "";
		}
		left++;
	}

	//If not empty string then add to the result(Last word is added)
	if (!temp.equals(""))
	{
		if (!ans.equals(""))
		{
			ans = temp + " " + ans;
		}
		else
		{
			ans = temp;
		}
	}

	return ans;
}
----------------------trust the process you will definitely win
question 90
1903. Largest Odd Number in String
class Solution {
    public String largestOddNumber(String num) {

        for (int i = num.length()-1;i >= 0;i--){

            if ((num.charAt(i)-'0')%2 !=0 ) 
            return num.substring(0,i+1);
        }
        return "";
    }
}
----------------------trust the process you will definitely win
question 91
796. Rotate String
class Solution {
    public boolean rotateString(String s, String g) {
        if(s.length()!=g.length()) return false;
        s=s+""+s;
        if(s.indexOf(g)==-1)
        return false;
        return true;
    }
}
----------------------trust the process you will definitely win
question 92
leetcode 242
class Solution {
    public boolean isAnagram(String s, String t) {
        
           int a=s.length();
        int b=t.length();
        
        if(a!=b){
            return false;
        }
        
        int[] arr=new int[26];
        
        for(int i=0;i<a;i++){
            char ch=s.charAt(i);
            int index=ch-'a';
            arr[index]++;
        }
        for(int i=0;i<b;i++){
            char ch=t.charAt(i);
            int index=ch-'a';
            arr[index]--;
        }
        for(int i:arr){
            if(i!=0){
                return false;
            }
        }
        return true;
    }
}
----------------------trust the process you will definitely win
question 93
leetcode 14. Longest Common Prefix
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String prefix = strs[0];
        for(int index=1;index<strs.length;index++){
            while(strs[index].indexOf(prefix) != 0){
                prefix=prefix.substring(0,prefix.length()-1);
            }
        }
        return prefix;
    }
}
----------------------trust the process you will definitely win
question 94
leetcode 205
class Solution {
    public boolean isIsomorphic(String s, String t) {
        // Create arrays to store the index of characters in both strings
        int[] indexS = new int[200]; // Stores index of characters in string s
        int[] indexT = new int[200]; // Stores index of characters in string t
        
        // Get the length of both strings
        int len = s.length();
        
        // If the lengths of the two strings are different, they can't be isomorphic
        if(len != t.length()) {
            return false;
        }
        
        // Iterate through each character of the strings
        for(int i = 0; i < len; i++) {
            if(indexS[s.charAt(i)] != indexT[t.charAt(i)]) {
                return false; 
            }
            
            
            indexS[s.charAt(i)] = i + 1; 
            indexT[t.charAt(i)] = i + 1; 
        }
        
        // If the loop completes without returning false, strings are isomorphic
        return true;
    }
}
----------------------trust the process you will definitely win
question 95
leetcode 1614. Maximum Nesting Depth of the Parentheses
class Solution {
   public int maxDepth(String s) {
    int left = 0; // To track current depth
    int maxInt = 0; // To track maximum depth
    int i = 0; // Iterator for the string

    while (i <= s.length() - 1) {
        if (s.charAt(i) == '(') {
            left++; // Increment current depth
            maxInt = Math.max(left, maxInt); // Update maximum depth if needed
            i++; // Move to next character
        } else if (s.charAt(i) == ')') {
            left--; // Decrement current depth
            i++; // Move to next character
        } else {
            i++; // Move to next character for any non-parenthesis character
        }
    }
    return maxInt; // Return the maximum depth found
}
}
----------------------trust the process you will definitely win
question 97
leetcode 13. Roman to Integer
class Solution {
     public int romanToInt(String s) {
         int ans = 0, num = 0;
        for (int i = s.length()-1; i >= 0; i--) {
            switch(s.charAt(i)) {
                case 'I': num = 1; break;
                case 'V': num = 5; break;
                case 'X': num = 10; break;
                case 'L': num = 50; break;
                case 'C': num = 100; break;
                case 'D': num = 500; break;
                case 'M': num = 1000; break;
            }
            if (4 * num < ans) ans -= num;
            else ans += num;
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 98
leetcode 5
Longest palindromic substring
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int window = n;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<=n-window; j++)
            {
                String temp = s.substring(j, j+window);
                temp = checkPalindrome(temp);
                if(!temp.isEmpty())
                {
                    return temp;
                }
                
            }
            window--;
        }
        return "";
    }

    public String checkPalindrome(String str)
    {
        for(int i=0, j=str.length()-1; i<str.length() && j>=0; i++, j--)
        {
            if(str.charAt(i)!=str.charAt(j))
            {
                return "";
            }
        }
        return str;
    }
}

----------------------trust the process you will definitely win

ArrayList 10 hashmap 16 hashset 16 linked no predefined size

vector 10 stack 10 priority queue 11 hashtable 11 linkdhashmap 16

treemap nopredefinedsize treeset nopredefinedsize concurrent hashmap 16

linkedhashset 16 
----------------------trust the process you will definitely win
Collections.sort(people, (p1, p2) -> p1.name.compareTo(p2.name));
Collections.sort(people, (p1, p2) -> Integer.compare(p1.age, p2.age));
----------------------trust the process you will definitely win
question 99
Integer to roman
public class IntegerToRoman {
    public static String intToRoman(int num) {
        String result = "";  // Use a simple string for concatenation

        // Define arrays for roman numerals and corresponding integer values
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] numerals = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        for (int i = 0; i < values.length; i++) {
            while (num >= values[i]) {
                result = result + numerals[i];  // Concatenate the result manually
                num -= values[i];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int number = 1994;  // Example input
        System.out.println("Integer: " + number + " = " + intToRoman(number));
    }
}
----------------------trust the process you will definitely win
question 100
leetcode 451
class Solution {
    public String frequencySort(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        for(char ch : s.toCharArray()) {
            map.put(ch, map.getOrDefault(ch,0)+1);
        }
        List<Character> [] bucket = new List[s.length()+1];
        for(Character key : map.keySet()) {
            int freq = map.get(key);
            if(bucket[freq] == null) {
                bucket[freq]=new ArrayList<>();
            }
            bucket[freq].add(key);
        }

        String result = "";
       for (int i = bucket.length - 1; i >= 0; i--) {
          if  (bucket[i] != null) {
          for (char ch : bucket[i]) {
            for (int j = 0; j < map.get(ch); j++) {
                result += ch;  // Concatenate character to the result string
            }
          }
        }
     }
return result;

    }
}

----------------------trust the process you will definitely win
question 101
leetcode 8
class Solution {
    public int myAtoi(String s) {
        boolean neg = false;
        int ans=0, i=0;
        int len = s.length();
        while(i<len && s.charAt(i) == ' '){
            i++;
        }
        if(i<len){
            char c = s.charAt(i);
            if(c == '-'){
                neg = true;
                i++;
            }
            else if(c == '+'){
                i++;
            }
        }
        while(i<len && s.charAt(i)>='0' && s.charAt(i)<='9')
        {
            int digit = s.charAt(i) - '0';

            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                return neg ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }

            ans = ans * 10 + digit;
            i++;
        }

        return neg ? -ans : ans;
    }
}
----------------------trust the process you will definitely win
question 102
geeksforgeeks
Given a string of lowercase alphabets, count all possible substrings (not necessarily distinct) that have exactly k distinct characters. 
class Solution {
    
 
    long countSubstring(String S, int K) {
        int n = S.length();
        int[] freq = new int[26];
        int uc = 0;
        long count = 0;
        int left = 0;

        for (int right = 0; right < n; right++) {
            if (freq[S.charAt(right) - 'a'] == 0) {
                uc++;
            }
            freq[S.charAt(right) - 'a']++;
            
            while (uc > K) {
                freq[S.charAt(left) - 'a']--;
                if (freq[S.charAt(left) - 'a'] == 0) {
                    uc--;
                }
                left++;
            }
            count += right - left + 1;
        }
        
        return count;
    }
    
    
    long substrCount(String S, int K) {
        if (S == null || K <= 0) {
            return 0;
        }
        
        return countSubstring(S, K) - countSubstring(S, K - 1);
    }
}
----------------------trust the process you will definitely win
 question 103
leetcode 1781. Sum of Beauty of All Substrings
class Solution {
    public int beautySum(String s) {

        int ans = 0;
        char arr[] = s.toCharArray();

        for(int i=0;i<arr.length;i++){
            int freq[] = new int[26];
            for(int j=i;j<arr.length;j++){
                freq[arr[j]-'a']++;
                int minFreq = arr.length;
                int maxFreq = 0;
                
                for(int k:freq){
                    if(k!=0){
                        minFreq = Math.min(minFreq,k);
                        maxFreq = Math.max(maxFreq,k);
                    }
                }       
                ans += (maxFreq - minFreq);
            }
        }
        return ans;
    }
}
----------------------trust the process you will definitely win
question 104
leetcode 237
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
----------------------trust the process you will definitely win
question 105
public class SubsequencePrinter {
    public static void main(String[] args) {
        String str = "abc";
        printSubsequences(str, 0, "");
    }

    // Recursive method to generate all subsequences
    public static void printSubsequences(String str, int index, String current) {
        // Base case: if we've reached the end of the string, print the current subsequence
        if (index == str.length()) {
            System.out.println(current);
            return;
        }

        // Recursive case: exclude the current character and move to the next
        printSubsequences(str, index + 1, current);

        // Recursive case: include the current character and move to the next
        printSubsequences(str, index + 1, current + str.charAt(index));
    }
}


----------------------trust the process you will definitely win
question 106
leetcode 240. Search a 2D Matrix II
public class Solution {
 public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target > matrix[row][col]) {
                row++;
            }
            else
            {
                col--;
            }
        }
        return false;
    }
}
----------------------trust the process you will definitely win
question 107
Doubly linked list implementation
up to lunch spring
after that 5 problems
// Node class for creating a node
    class Node {
        int data;
        Node next;
        Node prev;

        Node(int d) 
        { 
            data = d; 
            next = null;
            prev = null;
         }
    }

class DoublyLinkedList {
    Node head; // head of the list


    public DoublyLinkedList()
    {
     this.head=null;
    }
    
    // Insert a new node at the end of the list
    public void insert(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
            newNode.prev = current;
        }
        System.out.println(data + " inserted.");
    }

    // Delete a node with a specific value
    public void delete(int key) {
        Node temp = head;

        // If head node itself holds the key
        if (temp != null && temp.data == key) {
            head = temp.next;
            if (head != null) head.prev = null;
            System.out.println(key + " deleted.");
            return;
        }

        // Search for the key to be deleted
        while (temp != null && temp.data != key) {
            temp = temp.next;
        }

        // If the key was not present
        if (temp == null) {
            System.out.println(key + " not found.");
            return;
        }

        // Unlink the node from the list
        if (temp.next != null) temp.next.prev = temp.prev;
        if (temp.prev != null) temp.prev.next = temp.next;
        System.out.println(key + " deleted.");
    }

    // Reverse the doubly linked list
    public void reverse() {
        Node current = head;
        Node temp = null;

        // Swap next and prev pointers for each node
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        // Adjust head pointer to point to the last node
        if (temp != null) head = temp.prev;
        System.out.println("List reversed.");
    }

    // Display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    // Main function to test the linked list
    public static void main(String[] args) {
        DoublyLinkedList list = new DoublyLinkedList();
        
        list.insert(10);
        list.insert(20);
        list.insert(30);
        list.display();
        list.delete(20);
        list.display();
        list.reverse();
        list.display();
    }
----------------------trust the process you will definitely win
question 108
leetcode 876
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow=head,fast=head;
        while( fast!=null && fast.next!=null )
        {
            slow=slow.next;
            fast=fast.next.next;
        }
        return slow;
    }
}
----------------------trust the process you will definitely win
question 109
leetcode 206
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode node=null;
        while(head!=null)
        {
            ListNode next=head.next;
            head.next=node;
            node=head;
            head=next;
        }
        return node;
    }
}
----------------------trust the process you will definitely win
