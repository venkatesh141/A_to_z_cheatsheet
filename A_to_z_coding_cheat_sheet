A_to_z_coding_cheat_sheet


patterns  -->
   
-----------------------trust the process you will win.
Input Format: N = 6  ques 1
Result:   
1          1
12        21
12       321
1234    4321
12345  54321
123456654321


solution

    
static void pattern(int n)
{
	int spaces = 2*(n-1);

	for(int i=1;i<=n;i++)
	{

		for(int j=1;j<=i;j++)
		{
			System.out.print(j);
		}
        for(int j=1;j<=spaces;j++)
        {
        	System.out.print(" ");
        } 

        for(int j=i;j>=1;j--)
        {
        	System.out.print(j);
        }
        System.out.println();
        spaces-=2;

	}
}
end
-----------------------trust the process you will definitely win.

  int n=6   ques 2

     A     
    ABA    
   ABCBA   
  ABCDCBA  
 ABCDEDCBA 
ABCDEFEDCBA
    
solution

public static void pattern(int n)
{
	for(int i=0;i<n;i++)
		{
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}

			char ch='A';
			int breakpoint = (2*i+1)/2;
			for(int j=1;j<=2*i+1;j++)
			{
				System.out.print(ch);
				if(j<=breakpoint)
					ch++;
				else
					ch--;
			}
			for(int j=0;j<n-i-1;j++)
			{
				System.out.print(" ");
			}
			System.out.println();

		}
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6   ques 3
Result:   
************
*****  *****
****    ****
***      ***
**        **
*          *
*          *
**        **
***      ***
****    ****
*****  *****
************


public static void pat(int n)
{
    int spaces=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=n-i;j++)
        {
            System.out.print("*");
        }
        spaces+=2;
        System.out.println();
    }
    spaces = 2*n-2;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        for(int j=0;j<spaces;j++)
        {
            System.out.print(" ");
        }
        for(int j=1;j<=i;j++)
        {
            System.out.print("*");
        }
        spaces-=2;
        System.out.println();
    }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 3 ques 4
Result: 
*    *
**  **
******
**  **
*    *

public static void pattern(int n)
{
int spaces = 2*n-2;
      
      // Outer loop for printing row.
      for(int i = 1;i<=2*n-1;i++){
          
          // stars for first half
          int stars = i;
          
          // stars for the second half.
          if(i>n) stars = 2*n - i;
          
          //for printing the stars
          for(int j=1;j<=stars;j++){
              System.out.print("*");
          }
          
          //for printing the spaces
          for(int j = 1;j<=spaces;j++){
              System.out.print(" ");
          }
          
          //for printing the stars
          for(int j = 1;j<=stars;j++){
              System.out.print("*");
          }
          
          // As soon as the stars for each iteration are printed, we move to the
          // next row and give a line break otherwise all stars
          // would get printed in 1 line.
          System.out.println();
          if(i<n) spaces -=2;
          else spaces +=2;
      }
}
end
-----------------------trust the process you will definitely win.
Input Format: N = 6 ques 5
Result:   
******
*    *
*    *
*    *
*    *
******

public static void fun(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 || j==0 || i==n-1 || j==n-1)
            {
                System.out.print("*");
            }
            else
            {
                System.out.print(" ");
            }
            
        }
        System.out..println();
    }
}
end
----------------------trust the process you will definitely win

Input Format: N = 3 ques 6
Result: 
3 3 3 3 3 
3 2 2 2 3 
3 2 1 2 3 
3 2 2 2 3 
3 3 3 3 3

static void pattern22(int n)
{
      
      for(int i=0;i<2*n-1;i++){
         for(int j=0;j<2*n-1;j++){
             
             
             int top = i;
             int bottom = j;
             int right = (2*n - 2) - j;
             int left = (2*n - 2) - i;
             System.out.print(n- Math.min(Math.min(top,bottom), Math.min(left,right)) + " ");
         }
           System.out.println();
     }
}
end
----------------------trust the process you will definitely win
 square root of a number optimized approach ques 7

public static int floor(int n)
{
    int res=1,i=1;
    while(res<=n)
    {
        i++;
        res=i*i;
    }
    return i-1;
}
end
----------------------trust the process you will definitely win
ques 8

 find missing number
 int ans=0;
      int n=nums.length;
        int sum=(n*(n+1))/2;
        for(int i=0;i<n;i++)
        {
            ans+=nums[i];
        }
        return sum-ans;
    end
----------------------trust the process you will definitely win
question 9

  sort colors
  
  st=0,mid=0,end=n-1;
  if(n==1)->return;
  while(mid<=end)
  {
     if(arr[mid]==2)
     {
           swap(arr[mid],arr[end])
           end--;
     }
     else if(arr[mid]==0)
     {
          swap(arr[mid],arr[st])
          st++;
          mid++;
     }
     else
     {
         mid++;
     }  
  }
  end

----------------------trust the process you will definitely win
question 10
check if two arrays are equal are not
public static boolean check(int[] arr1, int[] arr2) {
        // Your code here
        int n1=arr1.length;
        int n2=arr2.length;
        if(n1!=n2)
          return false;
         for(int i=0;i<n1;i++)
         {
             for(int j=0;j<n2;j++)
             {
                 if(arr2[j]==Integer.MIN_VALUE)
                 continue;
                 
                 if(arr1[i]==arr2[j])
                 {
                     arr2[j]=Integer.MIN_VALUE;
                     break;
                 }
             }
         }
         for(int i=0;i<n2;i++)
         {
             if(arr2[i]!=Integer.MIN_VALUE)
               return false;
         }
         return true;
         
    }
end
----------------------trust the process you will definitely win
question 11 merge sort 

   public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Base case: array is already sorted if it has one or zero elements
        }
        
        int mid = array.length / 2;
        int[] left = new int[mid];
        int[] right = new int[array.length - mid];
        System.arraycopy(array, 0, left, 0, mid);
        System.arraycopy(array, mid, right, 0, array.length - mid);
        mergeSort(left);
        mergeSort(right);
        merge(array, left, right);
    }
    
   
    private static void merge(int[] array, int[] left, int[] right) {
        int leftIndex = 0, rightIndex = 0, arrayIndex = 0;
        
   
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] <= right[rightIndex]) {
                array[arrayIndex++] = left[leftIndex++];
            } else {
                array[arrayIndex++] = right[rightIndex++];
            }
        }
        
   
        while (leftIndex < left.length) {
            array[arrayIndex++] = left[leftIndex++];
        }
        
   
        while (rightIndex < right.length) {
            array[arrayIndex++] = right[rightIndex++];
        }
    }
end
----------------------trust the process you will definitely win
question 12 bubble sort

    private static void bubbleSortRecursive(int[] array, int n) {
        
        if (n == 1) {
            return;
        }
        
        
        for (int i = 0; i < n - 1; i++) {
            if (array[i] > array[i + 1]) {
                // Swap the elements if they are in the wrong order
                int temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        
        
        bubbleSortRecursive(array, n - 1);
    }
end
----------------------trust the process you will definitely win
qusstion 13 insertion sort 

 public static void recursiveInsertionSort(int[] arr, int n) {
        // Base case: If the array has only one element, it's already sorted
        if (n <= 1) {
            return;
        }

        // Sort the first n-1 elements
        recursiveInsertionSort(arr, n - 1);

        // Insert the nth element into its correct position
        int last = arr[n - 1];
        int j = n - 2;

        // Move elements that are greater than the last element one position ahead
        while (j >= 0 && arr[j] > last) {
            arr[j + 1] = arr[j];
            j--;
        }

        // Insert the last element at its correct position
        arr[j + 1] = last;
    }
----------------------trust the process you will definitely win
Implementation of linked list question 14

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

        public void append(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            return;
        }

        Node last = head;
        while (last.next != null) {
            last = last.next;
        }

        last.next = newNode;
    }

    // Method to display the linked list
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        linkedList.append(1);
        linkedList.append(2);
        linkedList.append(3);

        System.out.print("Linked List: ");
        linkedList.display();
    }
}
----------------------trust the process you will definitely win
stack implementation question 15

public class Stack {
     int maxSize; 
     int[] stackArray;
     int top; 

    
    public Stack(int maxSize) {
        this.maxSize = maxSize;
        this.stackArray = new int[maxSize];
        this.top = -1; // Stack is initially empty
    }

    
    public void push(int element) {
        if (isFull()) {
            System.out.println("Stack overflow! Cannot push element " + element);
            return;
        }
        top++;
        stackArray[top] = element;
    }

    
    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack underflow! Cannot pop element");
            return -1; 
        }
        int poppedElement = stackArray[top];
        top--;
        return poppedElement;
    }

    
    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty! Cannot peek");
            return -1; 
        }
        return stackArray[top];
    }

    
    public boolean isEmpty() {
        return top == -1;
    }

    
    public boolean isFull() {
        return top == maxSize - 1;
    }

    
    public static void main(String[] args) {
        Stack stack = new Stack(5); 
        stack.push(10);   
        System.out.println("Popped element: " + stack.pop());
        System.out.println("Top element of the stack: " + stack.peek());
        while (!stack.isEmpty()) {
            System.out.println("Popped element: " + stack.pop());
        }
    }
}

----------------------trust the process you will definitely win
queue implementation question 16

public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // Constructor
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }

    // Enqueue: Add an element to the end of the queue
    public void enqueue(int data) {
        if (size == capacity) {
            throw new RuntimeException("Queue is full");
        }
        rear = (rear + 1) % capacity;
        queue[rear] = data;
        size++;
    }

    // Dequeue: Remove and return the element from the front of the queue
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        int data = queue[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }

    // Peek: Return the front element without removing it
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
            return Integer.MIN_VALUE;
        }
        return queue[front];
    }

    // Check if the queue is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Check if the queue is full
    public boolean isFull() {
        return size == capacity;
    }

    // Get the size of the queue
    public int size() {
        return size;
    }

    // Display the queue
    public void display() {
        System.out.print("Queue: ");
        for (int i = 0; i < size; i++) {
            System.out.print(queue[(front + i) % capacity] + " ");
        }
        System.out.println();
    }
}


to traverse queue

    while (!queue.isEmpty()) {
            System.out.println("Dequeued element: " + queue.dequeue());
        }
----------------------trust the process you will definitely win
binary tree implementation question 17

class Node {
    int data;
    Node left, right;

    // Constructor
    public Node(int item) {
        data = item;
        left = right = null;
    }
}
public class BinaryTree {
    Node root;

    // Constructor
    public BinaryTree() {
        root = null;
    }

    // Method to insert a new node
    public void insert(int data) {
        root = insertRec(root, data);
    }

    // Recursive method to insert a new node
    private Node insertRec(Node root, int data) {
        if (root == null) {
            root = new Node(data);
            return root;
        }

        if (data < root.data) {
            root.left = insertRec(root.left, data);
        } else if (data > root.data) {
            root.right = insertRec(root.right, data);
        }

        return root;
    }

    // Method for in-order traversal
    public void inOrder() {
        inOrderRec(root);
        System.out.println();
    }

    // Recursive method for in-order traversal
    private void inOrderRec(Node root) {
        if (root != null) {
            inOrderRec(root.left);
            System.out.print(root.data + " ");
            inOrderRec(root.right);
        }
    }

    // Method for pre-order traversal
    public void preOrder() {
        preOrderRec(root);
        System.out.println();
    }

    // Recursive method for pre-order traversal
    private void preOrderRec(Node root) {
        if (root != null) {
            System.out.print(root.data + " ");
            preOrderRec(root.left);
            preOrderRec(root.right);
        }
    }

    // Method for post-order traversal
    public void postOrder() {
        postOrderRec(root);
        System.out.println();
    }

    // Recursive method for post-order traversal
    private void postOrderRec(Node root) {
        if (root != null) {
            postOrderRec(root.left);
            postOrderRec(root.right);
            System.out.print(root.data + " ");
        }
    }

    // Method to search for a value in the tree
    public boolean search(int data) {
        return searchRec(root, data);
    }

    // Recursive method to search for a value in the tree
    private boolean searchRec(Node root, int data) {
        if (root == null) {
            return false;
        }

        if (root.data == data) {
            return true;
        }

        return data < root.data
                ? searchRec(root.left, data)
                : searchRec(root.right, data);
    }

    // Main method to test the BinaryTree class
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        /* Create the following binary tree
              50
             /  \
            30   70
           / \   / \
          20 40 60 80
        */
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        System.out.println("In-order traversal:");
        tree.inOrder(); // Output: 20 30 40 50 60 70 80

        System.out.println("Pre-order traversal:");
        tree.preOrder(); // Output: 50 30 20 40 70 60 80

        System.out.println("Post-order traversal:");
        tree.postOrder(); // Output: 20 40 30 60 80 70 50

        System.out.println("Searching for 60: " + tree.search(60)); // Output: true
        System.out.println("Searching for 100: " + tree.search(100)); // Output: false
    }
}
----------------------trust the process you will definitely win
question 18 

implement stack using single queue

public class tuf {

    public static void main(String[] args) {
        stack s = new stack();
        s.push(3);
        s.push(2);
        s.push(4);
        s.push(1);
        System.out.println("Top of the stack: " + s.top());
        System.out.println("Size of the stack before removing element: " + s.size());
        System.out.println("The deleted element is: " + s.pop());
        System.out.println("Top of the stack after removing element: " + s.top());
        System.out.println("Size of the stack after removing element: " + s.size());
    }

}
class stack {
    Queue < Integer > q = new LinkedList < > ();
    void push(int x) {
        q.add(x);
        for (int i = 0; i < q.size() - 1; i++) {
            q.add(q.remove());
        }
    }
    int pop() {
        return q.remove();
    }
    int top() {
        return q.peek();
    }
    int size() {
        return q.size();
    }

----------------------trust the process you will definitely win
